"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-reconciler";
exports.ids = ["vendor-chunks/react-reconciler"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  ((exports.ConcurrentRoot = 1),\n  (exports.ContinuousEventPriority = 8),\n  (exports.DefaultEventPriority = 32),\n  (exports.DiscreteEventPriority = 2),\n  (exports.IdleEventPriority = 268435456),\n  (exports.LegacyRoot = 0),\n  (exports.NoEventPriority = 0));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckMsSUFBSSxzQkFBc0I7QUFDMUIsR0FBRywrQkFBK0I7QUFDbEMsR0FBRyw0QkFBNEI7QUFDL0IsR0FBRyw2QkFBNkI7QUFDaEMsR0FBRyx5QkFBeUI7QUFDNUIsR0FBRyxrQkFBa0I7QUFDckIsR0FBRyx1QkFBdUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcRWdvZm94eHhcXERvY3VtZW50c1xccG9ydGZvbGlvLXdlYnNpdGVcXG5vZGVfbW9kdWxlc1xccmVhY3QtcmVjb25jaWxlclxcY2pzXFxyZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKChleHBvcnRzLkNvbmN1cnJlbnRSb290ID0gMSksXG4gIChleHBvcnRzLkNvbnRpbnVvdXNFdmVudFByaW9yaXR5ID0gOCksXG4gIChleHBvcnRzLkRlZmF1bHRFdmVudFByaW9yaXR5ID0gMzIpLFxuICAoZXhwb3J0cy5EaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPSAyKSxcbiAgKGV4cG9ydHMuSWRsZUV2ZW50UHJpb3JpdHkgPSAyNjg0MzU0NTYpLFxuICAoZXhwb3J0cy5MZWdhY3lSb290ID0gMCksXG4gIChleHBvcnRzLk5vRXZlbnRQcmlvcml0eSA9IDApKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler.development.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \n true && (module.exports = function($$$config) {\n    function findHook(fiber, id) {\n        for(fiber = fiber.memoizedState; null !== fiber && 0 < id;)fiber = fiber.next, id--;\n        return fiber;\n    }\n    function copyWithSetImpl(obj, path, index, value) {\n        if (index >= path.length) return value;\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n        return updated;\n    }\n    function copyWithRename(obj, oldPath, newPath) {\n        if (oldPath.length !== newPath.length) console.warn(\"copyWithRename() expects paths of the same length\");\n        else {\n            for(var i = 0; i < newPath.length - 1; i++)if (oldPath[i] !== newPath[i]) {\n                console.warn(\"copyWithRename() expects paths to be the same except for the deepest key\");\n                return;\n            }\n            return copyWithRenameImpl(obj, oldPath, newPath, 0);\n        }\n    }\n    function copyWithRenameImpl(obj, oldPath, newPath, index) {\n        var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);\n        return updated;\n    }\n    function copyWithDeleteImpl(obj, path, index) {\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        if (index + 1 === path.length) return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;\n        updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n        return updated;\n    }\n    function shouldSuspendImpl() {\n        return !1;\n    }\n    function shouldErrorImpl() {\n        return null;\n    }\n    function createFiber(tag, pendingProps, key, mode) {\n        return new FiberNode(tag, pendingProps, key, mode);\n    }\n    function scheduleRoot(root, element) {\n        root.context === emptyContextObject && (updateContainerSync(element, root, null, null), flushSyncWork());\n    }\n    function scheduleRefresh(root, update) {\n        if (null !== resolveFamily) {\n            var staleFamilies = update.staleFamilies;\n            update = update.updatedFamilies;\n            flushPassiveEffects();\n            scheduleFibersWithFamiliesRecursively(root.current, update, staleFamilies);\n            flushSyncWork();\n        }\n    }\n    function setRefreshHandler(handler) {\n        resolveFamily = handler;\n    }\n    function warnInvalidHookAccess() {\n        console.error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\");\n    }\n    function warnInvalidContextAccess() {\n        console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n    }\n    function noop() {}\n    function warnForMissingKey() {}\n    function setToSortedString(set) {\n        var array = [];\n        set.forEach(function(value) {\n            array.push(value);\n        });\n        return array.sort().join(\", \");\n    }\n    function getIteratorFn(maybeIterable) {\n        if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[\"@@iterator\"];\n        return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function getComponentNameFromType(type) {\n        if (null == type) return null;\n        if (\"function\" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;\n        if (\"string\" === typeof type) return type;\n        switch(type){\n            case REACT_FRAGMENT_TYPE:\n                return \"Fragment\";\n            case REACT_PORTAL_TYPE:\n                return \"Portal\";\n            case REACT_PROFILER_TYPE:\n                return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n                return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n                return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n                return \"SuspenseList\";\n        }\n        if (\"object\" === typeof type) switch(\"number\" === typeof type.tag && console.error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), type.$$typeof){\n            case REACT_CONTEXT_TYPE:\n                return (type.displayName || \"Context\") + \".Provider\";\n            case REACT_CONSUMER_TYPE:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case REACT_FORWARD_REF_TYPE:\n                var innerType = type.render;\n                type = type.displayName;\n                type || (type = innerType.displayName || innerType.name || \"\", type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\");\n                return type;\n            case REACT_MEMO_TYPE:\n                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || \"Memo\";\n            case REACT_LAZY_TYPE:\n                innerType = type._payload;\n                type = type._init;\n                try {\n                    return getComponentNameFromType(type(innerType));\n                } catch (x) {}\n        }\n        return null;\n    }\n    function getComponentNameFromFiber(fiber) {\n        var type = fiber.type;\n        switch(fiber.tag){\n            case 24:\n                return \"Cache\";\n            case 9:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case 10:\n                return (type.displayName || \"Context\") + \".Provider\";\n            case 18:\n                return \"DehydratedFragment\";\n            case 11:\n                return fiber = type.render, fiber = fiber.displayName || fiber.name || \"\", type.displayName || (\"\" !== fiber ? \"ForwardRef(\" + fiber + \")\" : \"ForwardRef\");\n            case 7:\n                return \"Fragment\";\n            case 26:\n            case 27:\n            case 5:\n                return type;\n            case 4:\n                return \"Portal\";\n            case 3:\n                return \"Root\";\n            case 6:\n                return \"Text\";\n            case 16:\n                return getComponentNameFromType(type);\n            case 8:\n                return type === REACT_STRICT_MODE_TYPE ? \"StrictMode\" : \"Mode\";\n            case 22:\n                return \"Offscreen\";\n            case 12:\n                return \"Profiler\";\n            case 21:\n                return \"Scope\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 25:\n                return \"TracingMarker\";\n            case 1:\n            case 0:\n            case 14:\n            case 15:\n                if (\"function\" === typeof type) return type.displayName || type.name || null;\n                if (\"string\" === typeof type) return type;\n                break;\n            case 29:\n                type = fiber._debugInfo;\n                if (null != type) {\n                    for(var i = type.length - 1; 0 <= i; i--)if (\"string\" === typeof type[i].name) return type[i].name;\n                }\n                if (null !== fiber.return) return getComponentNameFromFiber(fiber.return);\n        }\n        return null;\n    }\n    function disabledLog() {}\n    function disableLogs() {\n        if (0 === disabledDepth) {\n            prevLog = console.log;\n            prevInfo = console.info;\n            prevWarn = console.warn;\n            prevError = console.error;\n            prevGroup = console.group;\n            prevGroupCollapsed = console.groupCollapsed;\n            prevGroupEnd = console.groupEnd;\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                value: disabledLog,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n            });\n        }\n        disabledDepth++;\n    }\n    function reenableLogs() {\n        disabledDepth--;\n        if (0 === disabledDepth) {\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                log: assign({}, props, {\n                    value: prevLog\n                }),\n                info: assign({}, props, {\n                    value: prevInfo\n                }),\n                warn: assign({}, props, {\n                    value: prevWarn\n                }),\n                error: assign({}, props, {\n                    value: prevError\n                }),\n                group: assign({}, props, {\n                    value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                    value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                    value: prevGroupEnd\n                })\n            });\n        }\n        0 > disabledDepth && console.error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n    }\n    function describeBuiltInComponentFrame(name) {\n        if (void 0 === prefix) try {\n            throw Error();\n        } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || \"\";\n            suffix = -1 < x.stack.indexOf(\"\\n    at\") ? \" (<anonymous>)\" : -1 < x.stack.indexOf(\"@\") ? \"@unknown:0:0\" : \"\";\n        }\n        return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n        if (!fn || reentry) return \"\";\n        var frame = componentFrameCache.get(fn);\n        if (void 0 !== frame) return frame;\n        reentry = !0;\n        frame = Error.prepareStackTrace;\n        Error.prepareStackTrace = void 0;\n        var previousDispatcher = null;\n        previousDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = null;\n        disableLogs();\n        try {\n            var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    try {\n                        if (construct) {\n                            var Fake = function() {\n                                throw Error();\n                            };\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    throw Error();\n                                }\n                            });\n                            if (\"object\" === typeof Reflect && Reflect.construct) {\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    var control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x$0) {\n                                    control = x$0;\n                                }\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x$1) {\n                                control = x$1;\n                            }\n                            (Fake = fn()) && \"function\" === typeof Fake.catch && Fake.catch(function() {});\n                        }\n                    } catch (sample) {\n                        if (sample && control && \"string\" === typeof sample.stack) return [\n                            sample.stack,\n                            control.stack\n                        ];\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            };\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\");\n            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, \"name\", {\n                value: \"DetermineComponentFrameRoot\"\n            });\n            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n            if (sampleStack && controlStack) {\n                var sampleLines = sampleStack.split(\"\\n\"), controlLines = controlStack.split(\"\\n\");\n                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(\"DetermineComponentFrameRoot\");)namePropDescriptor++;\n                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(\"DetermineComponentFrameRoot\");)_RunInRootFrame$Deter++;\n                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;\n                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                            var _frame = \"\\n\" + sampleLines[namePropDescriptor].replace(\" at new \", \" at \");\n                            fn.displayName && _frame.includes(\"<anonymous>\") && (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                            \"function\" === typeof fn && componentFrameCache.set(fn, _frame);\n                            return _frame;\n                        }\n                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n                    }\n                    break;\n                }\n            }\n        } finally{\n            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;\n        }\n        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\") ? describeBuiltInComponentFrame(sampleLines) : \"\";\n        \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n        return sampleLines;\n    }\n    function describeFiber(fiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return describeBuiltInComponentFrame(fiber.type);\n            case 16:\n                return describeBuiltInComponentFrame(\"Lazy\");\n            case 13:\n                return describeBuiltInComponentFrame(\"Suspense\");\n            case 19:\n                return describeBuiltInComponentFrame(\"SuspenseList\");\n            case 0:\n            case 15:\n                return fiber = describeNativeComponentFrame(fiber.type, !1), fiber;\n            case 11:\n                return fiber = describeNativeComponentFrame(fiber.type.render, !1), fiber;\n            case 1:\n                return fiber = describeNativeComponentFrame(fiber.type, !0), fiber;\n            default:\n                return \"\";\n        }\n    }\n    function getStackByFiberInDevAndProd(workInProgress) {\n        try {\n            var info = \"\";\n            do {\n                info += describeFiber(workInProgress);\n                var debugInfo = workInProgress._debugInfo;\n                if (debugInfo) for(var i = debugInfo.length - 1; 0 <= i; i--){\n                    var entry = debugInfo[i];\n                    if (\"string\" === typeof entry.name) {\n                        var JSCompiler_temp_const = info, env = entry.env;\n                        var JSCompiler_inline_result = describeBuiltInComponentFrame(entry.name + (env ? \" [\" + env + \"]\" : \"\"));\n                        info = JSCompiler_temp_const + JSCompiler_inline_result;\n                    }\n                }\n                workInProgress = workInProgress.return;\n            }while (workInProgress);\n            return info;\n        } catch (x) {\n            return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n        }\n    }\n    function getCurrentFiberStackInDev() {\n        return null === current ? \"\" : getStackByFiberInDevAndProd(current);\n    }\n    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {\n        var previousFiber = current;\n        ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;\n        isRendering = !1;\n        current = fiber;\n        try {\n            return callback(arg0, arg1, arg2, arg3, arg4);\n        } finally{\n            current = previousFiber;\n        }\n        throw Error(\"runWithFiberInDEV should never be called in production. This is a bug in React.\");\n    }\n    function getNearestMountedFiber(fiber) {\n        var node = fiber, nearestMounted = fiber;\n        if (fiber.alternate) for(; node.return;)node = node.return;\n        else {\n            fiber = node;\n            do node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;\n            while (fiber);\n        }\n        return 3 === node.tag ? nearestMounted : null;\n    }\n    function assertIsMounted(fiber) {\n        if (getNearestMountedFiber(fiber) !== fiber) throw Error(\"Unable to find node on an unmounted component.\");\n    }\n    function findCurrentFiberUsingSlowPath(fiber) {\n        var alternate = fiber.alternate;\n        if (!alternate) {\n            alternate = getNearestMountedFiber(fiber);\n            if (null === alternate) throw Error(\"Unable to find node on an unmounted component.\");\n            return alternate !== fiber ? null : fiber;\n        }\n        for(var a = fiber, b = alternate;;){\n            var parentA = a.return;\n            if (null === parentA) break;\n            var parentB = parentA.alternate;\n            if (null === parentB) {\n                b = parentA.return;\n                if (null !== b) {\n                    a = b;\n                    continue;\n                }\n                break;\n            }\n            if (parentA.child === parentB.child) {\n                for(parentB = parentA.child; parentB;){\n                    if (parentB === a) return assertIsMounted(parentA), fiber;\n                    if (parentB === b) return assertIsMounted(parentA), alternate;\n                    parentB = parentB.sibling;\n                }\n                throw Error(\"Unable to find node on an unmounted component.\");\n            }\n            if (a.return !== b.return) a = parentA, b = parentB;\n            else {\n                for(var didFindChild = !1, _child = parentA.child; _child;){\n                    if (_child === a) {\n                        didFindChild = !0;\n                        a = parentA;\n                        b = parentB;\n                        break;\n                    }\n                    if (_child === b) {\n                        didFindChild = !0;\n                        b = parentA;\n                        a = parentB;\n                        break;\n                    }\n                    _child = _child.sibling;\n                }\n                if (!didFindChild) {\n                    for(_child = parentB.child; _child;){\n                        if (_child === a) {\n                            didFindChild = !0;\n                            a = parentB;\n                            b = parentA;\n                            break;\n                        }\n                        if (_child === b) {\n                            didFindChild = !0;\n                            b = parentB;\n                            a = parentA;\n                            break;\n                        }\n                        _child = _child.sibling;\n                    }\n                    if (!didFindChild) throw Error(\"Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.\");\n                }\n            }\n            if (a.alternate !== b) throw Error(\"Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        if (3 !== a.tag) throw Error(\"Unable to find node on an unmounted component.\");\n        return a.stateNode.current === a ? fiber : alternate;\n    }\n    function findCurrentHostFiber(parent) {\n        parent = findCurrentFiberUsingSlowPath(parent);\n        return null !== parent ? findCurrentHostFiberImpl(parent) : null;\n    }\n    function findCurrentHostFiberImpl(node) {\n        var tag = node.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n        for(node = node.child; null !== node;){\n            tag = findCurrentHostFiberImpl(node);\n            if (null !== tag) return tag;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function findCurrentHostFiberWithNoPortalsImpl(node) {\n        var tag = node.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n        for(node = node.child; null !== node;){\n            if (4 !== node.tag && (tag = findCurrentHostFiberWithNoPortalsImpl(node), null !== tag)) return tag;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function createCursor(defaultValue) {\n        return {\n            current: defaultValue\n        };\n    }\n    function pop(cursor, fiber) {\n        0 > index$jscomp$0 ? console.error(\"Unexpected pop.\") : (fiber !== fiberStack[index$jscomp$0] && console.error(\"Unexpected Fiber popped.\"), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);\n    }\n    function push(cursor, value, fiber) {\n        index$jscomp$0++;\n        valueStack[index$jscomp$0] = cursor.current;\n        fiberStack[index$jscomp$0] = fiber;\n        cursor.current = value;\n    }\n    function clz32Fallback(x) {\n        x >>>= 0;\n        return 0 === x ? 32 : 31 - (log$1(x) / LN2 | 0) | 0;\n    }\n    function getLabelForLane(lane) {\n        if (lane & 1) return \"SyncHydrationLane\";\n        if (lane & 2) return \"Sync\";\n        if (lane & 4) return \"InputContinuousHydration\";\n        if (lane & 8) return \"InputContinuous\";\n        if (lane & 16) return \"DefaultHydration\";\n        if (lane & 32) return \"Default\";\n        if (lane & 64) return \"TransitionHydration\";\n        if (lane & 4194176) return \"Transition\";\n        if (lane & 62914560) return \"Retry\";\n        if (lane & 67108864) return \"SelectiveHydration\";\n        if (lane & 134217728) return \"IdleHydration\";\n        if (lane & 268435456) return \"Idle\";\n        if (lane & 536870912) return \"Offscreen\";\n        if (lane & 1073741824) return \"Deferred\";\n    }\n    function getHighestPriorityLanes(lanes) {\n        var pendingSyncLanes = lanes & 42;\n        if (0 !== pendingSyncLanes) return pendingSyncLanes;\n        switch(lanes & -lanes){\n            case 1:\n                return 1;\n            case 2:\n                return 2;\n            case 4:\n                return 4;\n            case 8:\n                return 8;\n            case 16:\n                return 16;\n            case 32:\n                return 32;\n            case 64:\n                return 64;\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return lanes & 4194176;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return lanes & 62914560;\n            case 67108864:\n                return 67108864;\n            case 134217728:\n                return 134217728;\n            case 268435456:\n                return 268435456;\n            case 536870912:\n                return 536870912;\n            case 1073741824:\n                return 0;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), lanes;\n        }\n    }\n    function getNextLanes(root, wipLanes) {\n        var pendingLanes = root.pendingLanes;\n        if (0 === pendingLanes) return 0;\n        var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, warmLanes = root.warmLanes;\n        root = 0 !== root.finishedLanes;\n        var nonIdlePendingLanes = pendingLanes & 134217727;\n        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = nonIdlePendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = pendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))));\n        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, warmLanes = wipLanes & -wipLanes, suspendedLanes >= warmLanes || 32 === suspendedLanes && 0 !== (warmLanes & 4194176)) ? wipLanes : nextLanes;\n    }\n    function checkIfRootIsPrerendering(root, renderLanes) {\n        return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);\n    }\n    function computeExpirationTime(lane, currentTime) {\n        switch(lane){\n            case 1:\n            case 2:\n            case 4:\n            case 8:\n                return currentTime + 250;\n            case 16:\n            case 32:\n            case 64:\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return currentTime + 5e3;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return -1;\n            case 67108864:\n            case 134217728:\n            case 268435456:\n            case 536870912:\n            case 1073741824:\n                return -1;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), -1;\n        }\n    }\n    function claimNextTransitionLane() {\n        var lane = nextTransitionLane;\n        nextTransitionLane <<= 1;\n        0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);\n        return lane;\n    }\n    function claimNextRetryLane() {\n        var lane = nextRetryLane;\n        nextRetryLane <<= 1;\n        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);\n        return lane;\n    }\n    function createLaneMap(initial) {\n        for(var laneMap = [], i = 0; 31 > i; i++)laneMap.push(initial);\n        return laneMap;\n    }\n    function markRootUpdated$1(root, updateLane) {\n        root.pendingLanes |= updateLane;\n        268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);\n    }\n    function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {\n        var previouslyPendingLanes = root.pendingLanes;\n        root.pendingLanes = remainingLanes;\n        root.suspendedLanes = 0;\n        root.pingedLanes = 0;\n        root.warmLanes = 0;\n        root.expiredLanes &= remainingLanes;\n        root.entangledLanes &= remainingLanes;\n        root.errorRecoveryDisabledLanes &= remainingLanes;\n        root.shellSuspendCounter = 0;\n        var entanglements = root.entanglements, expirationTimes = root.expirationTimes, hiddenUpdates = root.hiddenUpdates;\n        for(remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;){\n            var index = 31 - clz32(remainingLanes), lane = 1 << index;\n            entanglements[index] = 0;\n            expirationTimes[index] = -1;\n            var hiddenUpdatesForLane = hiddenUpdates[index];\n            if (null !== hiddenUpdatesForLane) for(hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++){\n                var update = hiddenUpdatesForLane[index];\n                null !== update && (update.lane &= -536870913);\n            }\n            remainingLanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);\n        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));\n    }\n    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n        root.pendingLanes |= spawnedLane;\n        root.suspendedLanes &= ~spawnedLane;\n        var spawnedLaneIndex = 31 - clz32(spawnedLane);\n        root.entangledLanes |= spawnedLane;\n        root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194218;\n    }\n    function markRootEntangled(root, entangledLanes) {\n        var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n        for(root = root.entanglements; rootEntangledLanes;){\n            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;\n            lane & entangledLanes | root[index] & entangledLanes && (root[index] |= entangledLanes);\n            rootEntangledLanes &= ~lane;\n        }\n    }\n    function addFiberToLanesMap(root, fiber, lanes) {\n        if (isDevToolsPresent) for(root = root.pendingUpdatersLaneMap; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            root[index].add(fiber);\n            lanes &= ~lane;\n        }\n    }\n    function movePendingFibersToMemoized(root, lanes) {\n        if (isDevToolsPresent) for(var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap, memoizedUpdaters = root.memoizedUpdaters; 0 < lanes;){\n            var index = 31 - clz32(lanes);\n            root = 1 << index;\n            index = pendingUpdatersLaneMap[index];\n            0 < index.size && (index.forEach(function(fiber) {\n                var alternate = fiber.alternate;\n                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);\n            }), index.clear());\n            lanes &= ~root;\n        }\n    }\n    function lanesToEventPriority(lanes) {\n        lanes &= -lanes;\n        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;\n    }\n    function injectInternals(internals) {\n        if (\"undefined\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;\n        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n        if (hook.isDisabled) return !0;\n        if (!hook.supportsFiber) return console.error(\"The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools\"), !0;\n        try {\n            rendererID = hook.inject(internals), injectedHook = hook;\n        } catch (err) {\n            console.error(\"React instrumentation encountered an error: %s.\", err);\n        }\n        return hook.checkDCE ? !0 : !1;\n    }\n    function onCommitRoot$1(root, eventPriority) {\n        if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberRoot) try {\n            var didError = 128 === (root.current.flags & 128);\n            switch(eventPriority){\n                case 2:\n                    var schedulerPriority = ImmediatePriority;\n                    break;\n                case 8:\n                    schedulerPriority = UserBlockingPriority;\n                    break;\n                case 32:\n                    schedulerPriority = NormalPriority$1;\n                    break;\n                case 268435456:\n                    schedulerPriority = IdlePriority;\n                    break;\n                default:\n                    schedulerPriority = NormalPriority$1;\n            }\n            injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n    }\n    function setIsStrictModeForDevtools(newIsStrictMode) {\n        \"function\" === typeof log && unstable_setDisableYieldValue(newIsStrictMode);\n        if (injectedHook && \"function\" === typeof injectedHook.setStrictMode) try {\n            injectedHook.setStrictMode(rendererID, newIsStrictMode);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n    }\n    function injectProfilingHooks(profilingHooks) {\n        injectedProfilingHooks = profilingHooks;\n    }\n    function markCommitStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();\n    }\n    function markComponentRenderStarted(fiber) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);\n    }\n    function markComponentRenderStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();\n    }\n    function markRenderStarted(lanes) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);\n    }\n    function markRenderStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();\n    }\n    function markStateUpdateScheduled(fiber, lane) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n    }\n    function is(x, y) {\n        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;\n    }\n    function createCapturedValueAtFiber(value, source) {\n        if (\"object\" === typeof value && null !== value) {\n            var existing = CapturedStacks.get(value);\n            if (void 0 !== existing) return existing;\n            source = {\n                value: value,\n                source: source,\n                stack: getStackByFiberInDevAndProd(source)\n            };\n            CapturedStacks.set(value, source);\n            return source;\n        }\n        return {\n            value: value,\n            source: source,\n            stack: getStackByFiberInDevAndProd(source)\n        };\n    }\n    function pushTreeFork(workInProgress, totalChildren) {\n        warnIfNotHydrating();\n        forkStack[forkStackIndex++] = treeForkCount;\n        forkStack[forkStackIndex++] = treeForkProvider;\n        treeForkProvider = workInProgress;\n        treeForkCount = totalChildren;\n    }\n    function pushTreeId(workInProgress, totalChildren, index) {\n        warnIfNotHydrating();\n        idStack[idStackIndex++] = treeContextId;\n        idStack[idStackIndex++] = treeContextOverflow;\n        idStack[idStackIndex++] = treeContextProvider;\n        treeContextProvider = workInProgress;\n        var baseIdWithLeadingBit = treeContextId;\n        workInProgress = treeContextOverflow;\n        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n        baseIdWithLeadingBit &= ~(1 << baseLength);\n        index += 1;\n        var length = 32 - clz32(totalChildren) + baseLength;\n        if (30 < length) {\n            var numberOfOverflowBits = baseLength - baseLength % 5;\n            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);\n            baseIdWithLeadingBit >>= numberOfOverflowBits;\n            baseLength -= numberOfOverflowBits;\n            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;\n            treeContextOverflow = length + workInProgress;\n        } else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;\n    }\n    function pushMaterializedTreeId(workInProgress) {\n        warnIfNotHydrating();\n        null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));\n    }\n    function popTreeContext(workInProgress) {\n        for(; workInProgress === treeForkProvider;)treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;\n        for(; workInProgress === treeContextProvider;)treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;\n    }\n    function warnIfNotHydrating() {\n        isHydrating || console.error(\"Expected to be hydrating. This is a bug in React. Please file an issue.\");\n    }\n    function requiredContext(c) {\n        null === c && console.error(\"Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.\");\n        return c;\n    }\n    function pushHostContainer(fiber, nextRootInstance) {\n        push(rootInstanceStackCursor, nextRootInstance, fiber);\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, null, fiber);\n        nextRootInstance = getRootHostContext(nextRootInstance);\n        pop(contextStackCursor, fiber);\n        push(contextStackCursor, nextRootInstance, fiber);\n    }\n    function popHostContainer(fiber) {\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n        pop(rootInstanceStackCursor, fiber);\n    }\n    function getHostContext() {\n        return requiredContext(contextStackCursor.current);\n    }\n    function pushHostContext(fiber) {\n        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);\n        var context = requiredContext(contextStackCursor.current), nextContext = getChildHostContext(context, fiber.type);\n        context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));\n    }\n    function popHostContext(fiber) {\n        contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));\n        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), isPrimaryRenderer ? HostTransitionContext._currentValue = NotPendingTransition : HostTransitionContext._currentValue2 = NotPendingTransition);\n    }\n    function findNotableNode(node, indent) {\n        return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;\n    }\n    function indentation(indent) {\n        return \"  \" + \"  \".repeat(indent);\n    }\n    function added(indent) {\n        return \"+ \" + \"  \".repeat(indent);\n    }\n    function removed(indent) {\n        return \"- \" + \"  \".repeat(indent);\n    }\n    function describeFiberType(fiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return fiber.type;\n            case 16:\n                return \"Lazy\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 0:\n            case 15:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            case 11:\n                return fiber = fiber.type.render, fiber.displayName || fiber.name || null;\n            case 1:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            default:\n                return null;\n        }\n    }\n    function describeTextNode(content, maxLength) {\n        return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{\"...\"}' : \"{\" + content.slice(0, maxLength - 7) + '...\"}' : \"{\" + content + \"}\") : content.length > maxLength ? 5 > maxLength ? '{\"...\"}' : content.slice(0, maxLength - 3) + \"...\" : content;\n    }\n    function describeTextDiff(clientText, serverProps, indent) {\n        var maxLength = 120 - 2 * indent;\n        if (null === serverProps) return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n        if (\"string\" === typeof serverProps) {\n            for(var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++);\n            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = \"...\" + clientText.slice(firstDiff - 8), serverProps = \"...\" + serverProps.slice(firstDiff - 8));\n            return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\" + removed(indent) + describeTextNode(serverProps, maxLength) + \"\\n\";\n        }\n        return indentation(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n    }\n    function objectName(object) {\n        return Object.prototype.toString.call(object).replace(/^\\[object (.*)\\]$/, function(m, p0) {\n            return p0;\n        });\n    }\n    function describeValue(value, maxLength) {\n        switch(typeof value){\n            case \"string\":\n                return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '\"...\"' : value.slice(0, maxLength - 4) + '...\"' : value;\n            case \"object\":\n                if (null === value) return \"null\";\n                if (isArrayImpl(value)) return \"[...]\";\n                if (value.$$typeof === REACT_ELEMENT_TYPE) return (maxLength = getComponentNameFromType(value.type)) ? \"<\" + maxLength + \">\" : \"<...>\";\n                var name = objectName(value);\n                if (\"Object\" === name) {\n                    name = \"\";\n                    maxLength -= 2;\n                    for(var propName in value)if (value.hasOwnProperty(propName)) {\n                        var jsonPropName = JSON.stringify(propName);\n                        jsonPropName !== '\"' + propName + '\"' && (propName = jsonPropName);\n                        maxLength -= propName.length - 2;\n                        jsonPropName = describeValue(value[propName], 15 > maxLength ? maxLength : 15);\n                        maxLength -= jsonPropName.length;\n                        if (0 > maxLength) {\n                            name += \"\" === name ? \"...\" : \", ...\";\n                            break;\n                        }\n                        name += (\"\" === name ? \"\" : \",\") + propName + \":\" + jsonPropName;\n                    }\n                    return \"{\" + name + \"}\";\n                }\n                return name;\n            case \"function\":\n                return (maxLength = value.displayName || value.name) ? \"function \" + maxLength : \"function\";\n            default:\n                return String(value);\n        }\n    }\n    function describePropValue(value, maxLength) {\n        return \"string\" !== typeof value || needsEscaping.test(value) ? \"{\" + describeValue(value, maxLength - 2) + \"}\" : value.length > maxLength - 2 ? 5 > maxLength ? '\"...\"' : '\"' + value.slice(0, maxLength - 5) + '...\"' : '\"' + value + '\"';\n    }\n    function describeExpandedElement(type, props, rowPrefix) {\n        var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;\n        for(propName in props)if (props.hasOwnProperty(propName) && \"children\" !== propName) {\n            var propValue = describePropValue(props[propName], 120 - rowPrefix.length - propName.length - 1);\n            remainingRowLength -= propName.length + propValue.length + 2;\n            properties.push(propName + \"=\" + propValue);\n        }\n        return 0 === properties.length ? rowPrefix + \"<\" + type + \">\\n\" : 0 < remainingRowLength ? rowPrefix + \"<\" + type + \" \" + properties.join(\" \") + \">\\n\" : rowPrefix + \"<\" + type + \"\\n\" + rowPrefix + \"  \" + properties.join(\"\\n\" + rowPrefix + \"  \") + \"\\n\" + rowPrefix + \">\\n\";\n    }\n    function describePropertiesDiff(clientObject, serverObject, indent) {\n        var properties = \"\", remainingServerProperties = assign({}, serverObject), propName;\n        for(propName in clientObject)if (clientObject.hasOwnProperty(propName)) {\n            delete remainingServerProperties[propName];\n            var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);\n            serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\", properties += removed(indent) + propName + \": \" + maxLength + \"\\n\") : properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\";\n        }\n        for(var _propName in remainingServerProperties)remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + \": \" + clientObject + \"\\n\");\n        return properties;\n    }\n    function describeElementDiff(type, clientProps, serverProps, indent) {\n        var content = \"\", serverPropNames = new Map();\n        for(propName$jscomp$0 in serverProps)serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);\n        if (1 === serverPropNames.size && serverPropNames.has(\"children\")) content += describeExpandedElement(type, clientProps, indentation(indent));\n        else {\n            for(var _propName2 in clientProps)if (clientProps.hasOwnProperty(_propName2) && \"children\" !== _propName2) {\n                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());\n                if (void 0 !== serverPropName) {\n                    serverPropNames.delete(_propName2.toLowerCase());\n                    var propName$jscomp$0 = clientProps[_propName2];\n                    serverPropName = serverProps[serverPropName];\n                    var clientPropValue = describePropValue(propName$jscomp$0, maxLength$jscomp$0);\n                    maxLength$jscomp$0 = describePropValue(serverPropName, maxLength$jscomp$0);\n                    \"object\" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && \"object\" === typeof serverPropName && null !== serverPropName && \"Object\" === objectName(propName$jscomp$0) && \"Object\" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf(\"...\") || -1 < maxLength$jscomp$0.indexOf(\"...\")) ? content += indentation(indent + 1) + _propName2 + \"={{\\n\" + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + \"}}\\n\" : (content += added(indent + 1) + _propName2 + \"=\" + clientPropValue + \"\\n\", content += removed(indent + 1) + _propName2 + \"=\" + maxLength$jscomp$0 + \"\\n\");\n                } else content += indentation(indent + 1) + _propName2 + \"=\" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + \"\\n\";\n            }\n            serverPropNames.forEach(function(propName) {\n                if (\"children\" !== propName) {\n                    var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;\n                    content += removed(indent + 1) + propName + \"=\" + describePropValue(serverProps[propName], maxLength) + \"\\n\";\n                }\n            });\n            content = \"\" === content ? indentation(indent) + \"<\" + type + \">\\n\" : indentation(indent) + \"<\" + type + \"\\n\" + content + indentation(indent) + \">\\n\";\n        }\n        type = serverProps.children;\n        clientProps = clientProps.children;\n        if (\"string\" === typeof type || \"number\" === typeof type || \"bigint\" === typeof type) {\n            serverPropNames = \"\";\n            if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) serverPropNames = \"\" + clientProps;\n            content += describeTextDiff(serverPropNames, \"\" + type, indent + 1);\n        } else if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) content = null == type ? content + describeTextDiff(\"\" + clientProps, null, indent + 1) : content + describeTextDiff(\"\" + clientProps, void 0, indent + 1);\n        return content;\n    }\n    function describeSiblingFiber(fiber, indent) {\n        var type = describeFiberType(fiber);\n        if (null === type) {\n            type = \"\";\n            for(fiber = fiber.child; fiber;)type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;\n            return type;\n        }\n        return indentation(indent) + \"<\" + type + \">\\n\";\n    }\n    function describeNode(node, indent) {\n        var skipToNode = findNotableNode(node, indent);\n        if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode)) return indentation(indent) + \"...\\n\" + describeNode(skipToNode, indent + 1);\n        skipToNode = \"\";\n        var debugInfo = node.fiber._debugInfo;\n        if (debugInfo) for(var i = 0; i < debugInfo.length; i++){\n            var serverComponentName = debugInfo[i].name;\n            \"string\" === typeof serverComponentName && (skipToNode += indentation(indent) + \"<\" + serverComponentName + \">\\n\", indent++);\n        }\n        debugInfo = \"\";\n        i = node.fiber.pendingProps;\n        if (6 === node.fiber.tag) debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;\n        else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName) if (void 0 === node.serverProps) {\n            debugInfo = indent;\n            var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = \"\";\n            for(propName in i)if (i.hasOwnProperty(propName) && \"children\" !== propName) {\n                var propValue = describePropValue(i[propName], 15);\n                maxLength -= propName.length + propValue.length + 2;\n                if (0 > maxLength) {\n                    content += \" ...\";\n                    break;\n                }\n                content += \" \" + propName + \"=\" + propValue;\n            }\n            debugInfo = indentation(debugInfo) + \"<\" + serverComponentName + content + \">\\n\";\n            indent++;\n        } else null === node.serverProps ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : \"string\" === typeof node.serverProps ? console.error(\"Should not have matched a non HostText fiber to a Text node. This is a bug in React.\") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++);\n        var propName = \"\";\n        i = node.fiber.child;\n        for(serverComponentName = 0; i && serverComponentName < node.children.length;)maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;\n        i && 0 < node.children.length && (propName += indentation(indent) + \"...\\n\");\n        i = node.serverTail;\n        null === node.serverProps && indent--;\n        for(node = 0; node < i.length; node++)serverComponentName = i[node], propName = \"string\" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + \"\\n\") : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));\n        return skipToNode + debugInfo + propName;\n    }\n    function describeDiff(rootNode) {\n        try {\n            return \"\\n\\n\" + describeNode(rootNode, 0);\n        } catch (x) {\n            return \"\";\n        }\n    }\n    function buildHydrationDiffNode(fiber, distanceFromLeaf) {\n        if (null === fiber.return) {\n            if (null === hydrationDiffRootDEV) hydrationDiffRootDEV = {\n                fiber: fiber,\n                children: [],\n                serverProps: void 0,\n                serverTail: [],\n                distanceFromLeaf: distanceFromLeaf\n            };\n            else {\n                if (hydrationDiffRootDEV.fiber !== fiber) throw Error(\"Saw multiple hydration diff roots in a pass. This is a bug in React.\");\n                hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);\n            }\n            return hydrationDiffRootDEV;\n        }\n        var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;\n        if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber) return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;\n        distanceFromLeaf = {\n            fiber: fiber,\n            children: [],\n            serverProps: void 0,\n            serverTail: [],\n            distanceFromLeaf: distanceFromLeaf\n        };\n        siblings.push(distanceFromLeaf);\n        return distanceFromLeaf;\n    }\n    function warnNonHydratedInstance(fiber, rejectedCandidate) {\n        didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));\n    }\n    function throwOnHydrationMismatch(fiber) {\n        var diff = \"\", diffRoot = hydrationDiffRootDEV;\n        null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));\n        queueHydrationError(createCapturedValueAtFiber(Error(\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\nhttps://react.dev/link/hydration-mismatch\" + diff), fiber));\n        throw HydrationMismatchException;\n    }\n    function prepareToHydrateHostInstance(fiber, hostContext) {\n        if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n        hydrateInstance(fiber.stateNode, fiber.type, fiber.memoizedProps, hostContext, fiber) || throwOnHydrationMismatch(fiber);\n    }\n    function popToNextHostParent(fiber) {\n        for(hydrationParentFiber = fiber.return; hydrationParentFiber;)switch(hydrationParentFiber.tag){\n            case 3:\n            case 27:\n                rootOrSingletonContext = !0;\n                return;\n            case 5:\n            case 13:\n                rootOrSingletonContext = !1;\n                return;\n            default:\n                hydrationParentFiber = hydrationParentFiber.return;\n        }\n    }\n    function popHydrationState(fiber) {\n        if (!supportsHydration || fiber !== hydrationParentFiber) return !1;\n        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;\n        var shouldClear = !1;\n        supportsSingletons ? 3 !== fiber.tag && 27 !== fiber.tag && (5 !== fiber.tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && (shouldClear = !0) : 3 !== fiber.tag && (5 !== fiber.tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && (shouldClear = !0);\n        if (shouldClear && nextHydratableInstance) {\n            for(shouldClear = nextHydratableInstance; shouldClear;){\n                var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(shouldClear);\n                diffNode.serverTail.push(description);\n                shouldClear = \"Suspense\" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(shouldClear) : getNextHydratableSibling(shouldClear);\n            }\n            throwOnHydrationMismatch(fiber);\n        }\n        popToNextHostParent(fiber);\n        if (13 === fiber.tag) {\n            if (!supportsHydration) throw Error(\"Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n            fiber = fiber.memoizedState;\n            fiber = null !== fiber ? fiber.dehydrated : null;\n            if (!fiber) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n            nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);\n        } else nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n        return !0;\n    }\n    function resetHydrationState() {\n        supportsHydration && (nextHydratableInstance = hydrationParentFiber = null, didSuspendOrErrorDEV = isHydrating = !1);\n    }\n    function queueHydrationError(error) {\n        null === hydrationErrors ? hydrationErrors = [\n            error\n        ] : hydrationErrors.push(error);\n    }\n    function emitPendingHydrationWarnings() {\n        var diffRoot = hydrationDiffRootDEV;\n        null !== diffRoot && (hydrationDiffRootDEV = null, diffRoot = describeDiff(diffRoot), console.error(\"A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\n%s%s\", \"https://react.dev/link/hydration-mismatch\", diffRoot));\n    }\n    function finishQueueingConcurrentUpdates() {\n        for(var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;){\n            var fiber = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var queue = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var update = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var lane = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            if (null !== queue && null !== update) {\n                var pending = queue.pending;\n                null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n                queue.pending = update;\n            }\n            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);\n        }\n    }\n    function enqueueUpdate$1(fiber, queue, update, lane) {\n        concurrentQueues[concurrentQueuesIndex++] = fiber;\n        concurrentQueues[concurrentQueuesIndex++] = queue;\n        concurrentQueues[concurrentQueuesIndex++] = update;\n        concurrentQueues[concurrentQueuesIndex++] = lane;\n        concurrentlyUpdatedLanes |= lane;\n        fiber.lanes |= lane;\n        fiber = fiber.alternate;\n        null !== fiber && (fiber.lanes |= lane);\n    }\n    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n        enqueueUpdate$1(fiber, queue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function enqueueConcurrentRenderForLane(fiber, lane) {\n        enqueueUpdate$1(fiber, null, null, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n        sourceFiber.lanes |= lane;\n        var alternate = sourceFiber.alternate;\n        null !== alternate && (alternate.lanes |= lane);\n        for(var isHidden = !1, parent = sourceFiber.return; null !== parent;)parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)), sourceFiber = parent, parent = parent.return;\n        isHidden && null !== update && 3 === sourceFiber.tag && (parent = sourceFiber.stateNode, isHidden = 31 - clz32(lane), parent = parent.hiddenUpdates, sourceFiber = parent[isHidden], null === sourceFiber ? parent[isHidden] = [\n            update\n        ] : sourceFiber.push(update), update.lane = lane | 536870912);\n    }\n    function getRootForUpdatedFiber(sourceFiber) {\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(\"Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.\");\n        nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(\"Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.\"));\n        null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n        for(var node = sourceFiber, parent = node.return; null !== parent;)null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;\n        return 3 === node.tag ? node.stateNode : null;\n    }\n    function pushNestedEffectDurations() {\n        var prevEffectDuration = profilerEffectDuration;\n        profilerEffectDuration = 0;\n        return prevEffectDuration;\n    }\n    function popNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration = prevEffectDuration;\n        return elapsedTime;\n    }\n    function bubbleNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration += prevEffectDuration;\n        return elapsedTime;\n    }\n    function startProfilerTimer(fiber) {\n        profilerStartTime = now();\n        0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);\n    }\n    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            fiber.selfBaseDuration = elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function recordEffectDuration() {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            profilerStartTime = -1;\n            profilerEffectDuration += elapsedTime;\n        }\n    }\n    function startEffectTimer() {\n        profilerStartTime = now();\n    }\n    function transferActualDuration(fiber) {\n        for(var child = fiber.child; child;)fiber.actualDuration += child.actualDuration, child = child.sibling;\n    }\n    function ensureRootIsScheduled(root) {\n        root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);\n        mightHavePendingSyncWork = !0;\n        null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = !0, scheduleImmediateTask(processRootScheduleInMicrotask)) : didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateTask(processRootScheduleInMicrotask));\n    }\n    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {\n        if (!isFlushingWork && mightHavePendingSyncWork) {\n            isFlushingWork = !0;\n            do {\n                var didPerformSomeWork = !1;\n                for(var root = firstScheduledRoot; null !== root;){\n                    if (!onlyLegacy) if (0 !== syncTransitionLanes) {\n                        var pendingLanes = root.pendingLanes;\n                        if (0 === pendingLanes) var nextLanes = 0;\n                        else {\n                            var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;\n                            nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;\n                            nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);\n                            nextLanes = nextLanes & 201326677 ? nextLanes & 201326677 | 1 : nextLanes ? nextLanes | 2 : 0;\n                        }\n                        0 !== nextLanes && (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    } else nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root, root === workInProgressRoot ? nextLanes : 0), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root, nextLanes) || (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    root = root.next;\n                }\n            }while (didPerformSomeWork);\n            isFlushingWork = !1;\n        }\n    }\n    function processRootScheduleInMicrotask() {\n        mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = !1;\n        var syncTransitionLanes = 0;\n        0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);\n        for(var currentTime = now$1(), prev = null, root = firstScheduledRoot; null !== root;){\n            var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);\n            if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);\n            else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = !0;\n            root = next;\n        }\n        flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);\n    }\n    function scheduleTaskForRootDuringMicrotask(root, currentTime) {\n        for(var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];\n            if (-1 === expirationTime) {\n                if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index] = computeExpirationTime(lane, currentTime);\n            } else expirationTime <= currentTime && (root.expiredLanes |= lane);\n            lanes &= ~lane;\n        }\n        currentTime = workInProgressRoot;\n        suspendedLanes = workInProgressRootRenderLanes;\n        suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0);\n        pingedLanes = root.callbackNode;\n        if (0 === suspendedLanes || root === currentTime && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) return null !== pingedLanes && cancelCallback(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;\n        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {\n            currentTime = suspendedLanes & -suspendedLanes;\n            if (currentTime !== root.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode$1) cancelCallback(pingedLanes);\n            else return currentTime;\n            switch(lanesToEventPriority(suspendedLanes)){\n                case 2:\n                case 8:\n                    suspendedLanes = UserBlockingPriority;\n                    break;\n                case 32:\n                    suspendedLanes = NormalPriority$1;\n                    break;\n                case 268435456:\n                    suspendedLanes = IdlePriority;\n                    break;\n                default:\n                    suspendedLanes = NormalPriority$1;\n            }\n            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);\n            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode$1) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);\n            root.callbackPriority = currentTime;\n            root.callbackNode = suspendedLanes;\n            return currentTime;\n        }\n        null !== pingedLanes && cancelCallback(pingedLanes);\n        root.callbackPriority = 2;\n        root.callbackNode = null;\n        return 2;\n    }\n    function performWorkOnRootViaSchedulerTask(root, didTimeout) {\n        nestedUpdateScheduled = currentUpdateIsNested = !1;\n        var originalCallbackNode = root.callbackNode;\n        if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode) return null;\n        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;\n        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0);\n        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;\n        performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);\n        scheduleTaskForRootDuringMicrotask(root, now$1());\n        return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;\n    }\n    function performSyncWorkOnRoot(root, lanes) {\n        if (flushPassiveEffects()) return null;\n        currentUpdateIsNested = nestedUpdateScheduled;\n        nestedUpdateScheduled = !1;\n        performWorkOnRoot(root, lanes, !0);\n    }\n    function cancelCallback(callbackNode) {\n        callbackNode !== fakeActCallbackNode$1 && null !== callbackNode && cancelCallback$1(callbackNode);\n    }\n    function scheduleImmediateTask(cb) {\n        null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {\n            cb();\n            return null;\n        });\n        supportsMicrotasks ? scheduleMicrotask(function() {\n            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, cb) : cb();\n        }) : scheduleCallback$3(ImmediatePriority, cb);\n    }\n    function requestTransitionLane() {\n        0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());\n        return currentEventTransitionLane;\n    }\n    function entangleAsyncAction(transition, thenable) {\n        if (null === currentEntangledListeners) {\n            var entangledListeners = currentEntangledListeners = [];\n            currentEntangledPendingCount = 0;\n            currentEntangledLane = requestTransitionLane();\n            currentEntangledActionThenable = {\n                status: \"pending\",\n                value: void 0,\n                then: function(resolve) {\n                    entangledListeners.push(resolve);\n                }\n            };\n        }\n        currentEntangledPendingCount++;\n        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n        return thenable;\n    }\n    function pingEngtangledActionScope() {\n        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {\n            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = \"fulfilled\");\n            var listeners = currentEntangledListeners;\n            currentEntangledListeners = null;\n            currentEntangledLane = 0;\n            currentEntangledActionThenable = null;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])();\n        }\n    }\n    function chainThenableValue(thenable, result) {\n        var listeners = [], thenableWithOverride = {\n            status: \"pending\",\n            value: null,\n            reason: null,\n            then: function(resolve) {\n                listeners.push(resolve);\n            }\n        };\n        thenable.then(function() {\n            thenableWithOverride.status = \"fulfilled\";\n            thenableWithOverride.value = result;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])(result);\n        }, function(error) {\n            thenableWithOverride.status = \"rejected\";\n            thenableWithOverride.reason = error;\n            for(error = 0; error < listeners.length; error++)(0, listeners[error])(void 0);\n        });\n        return thenableWithOverride;\n    }\n    function initializeUpdateQueue(fiber) {\n        fiber.updateQueue = {\n            baseState: fiber.memoizedState,\n            firstBaseUpdate: null,\n            lastBaseUpdate: null,\n            shared: {\n                pending: null,\n                lanes: 0,\n                hiddenCallbacks: null\n            },\n            callbacks: null\n        };\n    }\n    function cloneUpdateQueue(current, workInProgress) {\n        current = current.updateQueue;\n        workInProgress.updateQueue === current && (workInProgress.updateQueue = {\n            baseState: current.baseState,\n            firstBaseUpdate: current.firstBaseUpdate,\n            lastBaseUpdate: current.lastBaseUpdate,\n            shared: current.shared,\n            callbacks: null\n        });\n    }\n    function createUpdate(lane) {\n        return {\n            lane: lane,\n            tag: UpdateState,\n            payload: null,\n            callback: null,\n            next: null\n        };\n    }\n    function enqueueUpdate(fiber, update, lane) {\n        var updateQueue = fiber.updateQueue;\n        if (null === updateQueue) return null;\n        updateQueue = updateQueue.shared;\n        if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {\n            var componentName = getComponentNameFromFiber(fiber);\n            console.error(\"An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\\n\\nPlease update the following component: %s\", componentName);\n            didWarnUpdateInsideUpdate = !0;\n        }\n        if ((executionContext & RenderContext) !== NoContext) return componentName = updateQueue.pending, null === componentName ? update.next = update : (update.next = componentName.next, componentName.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;\n        enqueueUpdate$1(fiber, updateQueue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function entangleTransitions(root, fiber, lane) {\n        fiber = fiber.updateQueue;\n        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194176))) {\n            var queueLanes = fiber.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            fiber.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n        var queue = workInProgress.updateQueue, current = workInProgress.alternate;\n        if (null !== current && (current = current.updateQueue, queue === current)) {\n            var newFirst = null, newLast = null;\n            queue = queue.firstBaseUpdate;\n            if (null !== queue) {\n                do {\n                    var clone = {\n                        lane: queue.lane,\n                        tag: queue.tag,\n                        payload: queue.payload,\n                        callback: null,\n                        next: null\n                    };\n                    null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;\n                    queue = queue.next;\n                }while (null !== queue);\n                null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;\n            } else newFirst = newLast = capturedUpdate;\n            queue = {\n                baseState: current.baseState,\n                firstBaseUpdate: newFirst,\n                lastBaseUpdate: newLast,\n                shared: current.shared,\n                callbacks: current.callbacks\n            };\n            workInProgress.updateQueue = queue;\n            return;\n        }\n        workInProgress = queue.lastBaseUpdate;\n        null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;\n        queue.lastBaseUpdate = capturedUpdate;\n    }\n    function suspendIfUpdateReadFromEntangledAsyncAction() {\n        if (didReadFromEntangledAsyncAction) {\n            var entangledActionThenable = currentEntangledActionThenable;\n            if (null !== entangledActionThenable) throw entangledActionThenable;\n        }\n    }\n    function processUpdateQueue(workInProgress, props, instance$jscomp$0, renderLanes) {\n        didReadFromEntangledAsyncAction = !1;\n        var queue = workInProgress.updateQueue;\n        hasForceUpdate = !1;\n        currentlyProcessingQueue = queue.shared;\n        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;\n        if (null !== pendingQueue) {\n            queue.shared.pending = null;\n            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;\n            lastPendingUpdate.next = null;\n            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;\n            lastBaseUpdate = lastPendingUpdate;\n            var current = workInProgress.alternate;\n            null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));\n        }\n        if (null !== firstBaseUpdate) {\n            var newState = queue.baseState;\n            lastBaseUpdate = 0;\n            current = firstPendingUpdate = lastPendingUpdate = null;\n            pendingQueue = firstBaseUpdate;\n            do {\n                var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;\n                if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    null !== current && (current = current.next = {\n                        lane: 0,\n                        tag: pendingQueue.tag,\n                        payload: pendingQueue.payload,\n                        callback: null,\n                        next: null\n                    });\n                    a: {\n                        updateLane = workInProgress;\n                        var partialState = pendingQueue;\n                        var nextProps = props, instance = instance$jscomp$0;\n                        switch(partialState.tag){\n                            case ReplaceState:\n                                partialState = partialState.payload;\n                                if (\"function\" === typeof partialState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    var nextState = partialState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & 8) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            partialState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                    newState = nextState;\n                                    break a;\n                                }\n                                newState = partialState;\n                                break a;\n                            case CaptureUpdate:\n                                updateLane.flags = updateLane.flags & -65537 | 128;\n                            case UpdateState:\n                                nextState = partialState.payload;\n                                if (\"function\" === typeof nextState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    partialState = nextState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & 8) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            nextState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                } else partialState = nextState;\n                                if (null === partialState || void 0 === partialState) break a;\n                                newState = assign({}, newState, partialState);\n                                break a;\n                            case ForceUpdate:\n                                hasForceUpdate = !0;\n                        }\n                    }\n                    updateLane = pendingQueue.callback;\n                    null !== updateLane && (workInProgress.flags |= 64, isHiddenUpdate && (workInProgress.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [\n                        updateLane\n                    ] : isHiddenUpdate.push(updateLane));\n                } else isHiddenUpdate = {\n                    lane: updateLane,\n                    tag: pendingQueue.tag,\n                    payload: pendingQueue.payload,\n                    callback: pendingQueue.callback,\n                    next: null\n                }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;\n                pendingQueue = pendingQueue.next;\n                if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;\n                else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;\n            }while (1);\n            null === current && (lastPendingUpdate = newState);\n            queue.baseState = lastPendingUpdate;\n            queue.firstBaseUpdate = firstPendingUpdate;\n            queue.lastBaseUpdate = current;\n            null === firstBaseUpdate && (queue.shared.lanes = 0);\n            workInProgressRootSkippedLanes |= lastBaseUpdate;\n            workInProgress.lanes = lastBaseUpdate;\n            workInProgress.memoizedState = newState;\n        }\n        currentlyProcessingQueue = null;\n    }\n    function callCallback(callback, context) {\n        if (\"function\" !== typeof callback) throw Error(\"Invalid argument passed as callback. Expected a function. Instead received: \" + callback);\n        callback.call(context);\n    }\n    function commitHiddenCallbacks(updateQueue, context) {\n        var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n        if (null !== hiddenCallbacks) for(updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)callCallback(hiddenCallbacks[updateQueue], context);\n    }\n    function commitCallbacks(updateQueue, context) {\n        var callbacks = updateQueue.callbacks;\n        if (null !== callbacks) for(updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)callCallback(callbacks[updateQueue], context);\n    }\n    function shallowEqual(objA, objB) {\n        if (objectIs(objA, objB)) return !0;\n        if (\"object\" !== typeof objA || null === objA || \"object\" !== typeof objB || null === objB) return !1;\n        var keysA = Object.keys(objA), keysB = Object.keys(objB);\n        if (keysA.length !== keysB.length) return !1;\n        for(keysB = 0; keysB < keysA.length; keysB++){\n            var currentKey = keysA[keysB];\n            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return !1;\n        }\n        return !0;\n    }\n    function createThenableState() {\n        return {\n            didWarnAboutUncachedPromise: !1,\n            thenables: []\n        };\n    }\n    function isThenableResolved(thenable) {\n        thenable = thenable.status;\n        return \"fulfilled\" === thenable || \"rejected\" === thenable;\n    }\n    function noop$1() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n        null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = !0);\n        var trackedThenables = thenableState.thenables;\n        index = trackedThenables[index];\n        void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState.didWarnAboutUncachedPromise || (thenableState.didWarnAboutUncachedPromise = !0, console.error(\"A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.\")), thenable.then(noop$1, noop$1), thenable = index);\n        switch(thenable.status){\n            case \"fulfilled\":\n                return thenable.value;\n            case \"rejected\":\n                throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n            default:\n                if (\"string\" === typeof thenable.status) thenable.then(noop$1, noop$1);\n                else {\n                    thenableState = workInProgressRoot;\n                    if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error(\"async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n                    thenableState = thenable;\n                    thenableState.status = \"pending\";\n                    thenableState.then(function(fulfilledValue) {\n                        if (\"pending\" === thenable.status) {\n                            var fulfilledThenable = thenable;\n                            fulfilledThenable.status = \"fulfilled\";\n                            fulfilledThenable.value = fulfilledValue;\n                        }\n                    }, function(error) {\n                        if (\"pending\" === thenable.status) {\n                            var rejectedThenable = thenable;\n                            rejectedThenable.status = \"rejected\";\n                            rejectedThenable.reason = error;\n                        }\n                    });\n                }\n                switch(thenable.status){\n                    case \"fulfilled\":\n                        return thenable.value;\n                    case \"rejected\":\n                        throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n                }\n                suspendedThenable = thenable;\n                needsToResetSuspendedThenableDEV = !0;\n                throw SuspenseException;\n        }\n    }\n    function getSuspendedThenable() {\n        if (null === suspendedThenable) throw Error(\"Expected a suspended thenable. This is a bug in React. Please file an issue.\");\n        var thenable = suspendedThenable;\n        suspendedThenable = null;\n        needsToResetSuspendedThenableDEV = !1;\n        return thenable;\n    }\n    function checkIfUseWrappedInAsyncCatch(rejectedReason) {\n        if (rejectedReason === SuspenseException) throw Error(\"Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n    }\n    function pushDebugInfo(debugInfo) {\n        var previousDebugInfo = currentDebugInfo;\n        null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));\n        return previousDebugInfo;\n    }\n    function validateFragmentProps(element, fiber, returnFiber) {\n        for(var keys = Object.keys(element.props), i = 0; i < keys.length; i++){\n            var key = keys[i];\n            if (\"children\" !== key && \"key\" !== key) {\n                null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);\n                runWithFiberInDEV(fiber, function(erroredKey) {\n                    console.error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", erroredKey);\n                }, key);\n                break;\n            }\n        }\n    }\n    function unwrapThenable(thenable) {\n        var index = thenableIndexCounter$1;\n        thenableIndexCounter$1 += 1;\n        null === thenableState$1 && (thenableState$1 = createThenableState());\n        return trackUsedThenable(thenableState$1, thenable, index);\n    }\n    function coerceRef(workInProgress, element) {\n        element = element.props.ref;\n        workInProgress.ref = void 0 !== element ? element : null;\n    }\n    function throwOnInvalidObjectType(returnFiber, newChild) {\n        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\\n- Multiple copies of the \"react\" package is used.\\n- A library pre-bundled an old copy of \"react\" or \"react/jsx-runtime\".\\n- A compiler tries to \"inline\" JSX instead of using the runtime.');\n        returnFiber = Object.prototype.toString.call(newChild);\n        throw Error(\"Objects are not valid as a React child (found: \" + (\"[object Object]\" === returnFiber ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\" : returnFiber) + \"). If you meant to render a collection of children, use an array instead.\");\n    }\n    function warnOnFunctionType(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = !0, invalidChild = invalidChild.displayName || invalidChild.name || \"Component\", 3 === returnFiber.tag ? console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  root.render(%s)\", invalidChild, invalidChild, invalidChild) : console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  <%s>{%s}</%s>\", invalidChild, invalidChild, parentName, invalidChild, parentName));\n    }\n    function warnOnSymbolType(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = !0, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(\"Symbols are not valid as a React child.\\n  root.render(%s)\", invalidChild) : console.error(\"Symbols are not valid as a React child.\\n  <%s>%s</%s>\", parentName, invalidChild, parentName));\n    }\n    function createChildReconciler(shouldTrackSideEffects) {\n        function deleteChild(returnFiber, childToDelete) {\n            if (shouldTrackSideEffects) {\n                var deletions = returnFiber.deletions;\n                null === deletions ? (returnFiber.deletions = [\n                    childToDelete\n                ], returnFiber.flags |= 16) : deletions.push(childToDelete);\n            }\n        }\n        function deleteRemainingChildren(returnFiber, currentFirstChild) {\n            if (!shouldTrackSideEffects) return null;\n            for(; null !== currentFirstChild;)deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return null;\n        }\n        function mapRemainingChildren(currentFirstChild) {\n            for(var existingChildren = new Map(); null !== currentFirstChild;)null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return existingChildren;\n        }\n        function useFiber(fiber, pendingProps) {\n            fiber = createWorkInProgress(fiber, pendingProps);\n            fiber.index = 0;\n            fiber.sibling = null;\n            return fiber;\n        }\n        function placeChild(newFiber, lastPlacedIndex, newIndex) {\n            newFiber.index = newIndex;\n            if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;\n            newIndex = newFiber.alternate;\n            if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 33554434, lastPlacedIndex) : newIndex;\n            newFiber.flags |= 33554434;\n            return lastPlacedIndex;\n        }\n        function placeSingleChild(newFiber) {\n            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 33554434);\n            return newFiber;\n        }\n        function updateTextNode(returnFiber, current, textContent, lanes) {\n            if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, textContent);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updateElement(returnFiber, current, element, lanes) {\n            var elementType = element.type;\n            if (elementType === REACT_FRAGMENT_TYPE) return current = updateFragment(returnFiber, current, element.props.children, lanes, element.key), validateFragmentProps(element, current, returnFiber), current;\n            if (null !== current && (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || \"object\" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current._debugOwner = element._owner, current._debugInfo = currentDebugInfo, current;\n            current = createFiberFromElement(element, returnFiber.mode, lanes);\n            coerceRef(current, element);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updatePortal(returnFiber, current, portal, lanes) {\n            if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, portal.children || []);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updateFragment(returnFiber, current, fragment, lanes, key) {\n            if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, fragment);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function createChild(returnFiber, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return newChild = createFiberFromText(\"\" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                    case REACT_PORTAL_TYPE:\n                        return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        newChild = callLazyInitInDEV(newChild);\n                        returnFiber = createChild(returnFiber, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n            var key = null !== oldFiber ? oldFiber.key : null;\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;\n                    case REACT_PORTAL_TYPE:\n                        return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;\n                    case REACT_LAZY_TYPE:\n                        return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) {\n                    if (null !== key) return null;\n                    key = pushDebugInfo(newChild._debugInfo);\n                    returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n                    currentDebugInfo = key;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newIdx = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);\n                        newChild = callLazyInitInDEV(newChild);\n                        returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo7;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {\n            if (\"object\" !== typeof child || null === child) return knownKeys;\n            switch(child.$$typeof){\n                case REACT_ELEMENT_TYPE:\n                case REACT_PORTAL_TYPE:\n                    warnForMissingKey(returnFiber, workInProgress, child);\n                    var key = child.key;\n                    if (\"string\" !== typeof key) break;\n                    if (null === knownKeys) {\n                        knownKeys = new Set();\n                        knownKeys.add(key);\n                        break;\n                    }\n                    if (!knownKeys.has(key)) {\n                        knownKeys.add(key);\n                        break;\n                    }\n                    runWithFiberInDEV(workInProgress, function() {\n                        console.error(\"Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \\u2014 the behavior is unsupported and could change in a future version.\", key);\n                    });\n                    break;\n                case REACT_LAZY_TYPE:\n                    child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);\n            }\n            return knownKeys;\n        }\n        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n            for(var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; newIdx < newChildren.length; newIdx++)oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {\n            if (null == newChildren) throw Error(\"An iterable object provided no iterator.\");\n            for(var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; !step.done; newIdx++, step = newChildren.next())oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {\n            \"object\" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        var prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        a: {\n                            for(var key = newChild.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === key) {\n                                    key = newChild.type;\n                                    if (key === REACT_FRAGMENT_TYPE) {\n                                        if (7 === currentFirstChild.tag) {\n                                            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                            lanes = useFiber(currentFirstChild, newChild.props.children);\n                                            lanes.return = returnFiber;\n                                            lanes._debugOwner = newChild._owner;\n                                            lanes._debugInfo = currentDebugInfo;\n                                            validateFragmentProps(newChild, lanes, returnFiber);\n                                            returnFiber = lanes;\n                                            break a;\n                                        }\n                                    } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || \"object\" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {\n                                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                        lanes = useFiber(currentFirstChild, newChild.props);\n                                        coerceRef(lanes, newChild);\n                                        lanes.return = returnFiber;\n                                        lanes._debugOwner = newChild._owner;\n                                        lanes._debugInfo = currentDebugInfo;\n                                        returnFiber = lanes;\n                                        break a;\n                                    }\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                } else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);\n                        }\n                        returnFiber = placeSingleChild(returnFiber);\n                        currentDebugInfo = prevDebugInfo;\n                        return returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        a: {\n                            prevDebugInfo = newChild;\n                            for(newChild = prevDebugInfo.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === newChild) if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                    lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);\n                                    lanes.return = returnFiber;\n                                    returnFiber = lanes;\n                                    break a;\n                                } else {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                }\n                                else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);\n                            lanes.return = returnFiber;\n                            returnFiber = lanes;\n                        }\n                        return placeSingleChild(returnFiber);\n                    case REACT_LAZY_TYPE:\n                        return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                }\n                if (isArrayImpl(newChild)) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (getIteratorFn(newChild)) {\n                    prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                    key = getIteratorFn(newChild);\n                    if (\"function\" !== typeof key) throw Error(\"An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.\");\n                    var newChildren = key.call(newChild);\n                    if (newChildren === newChild) {\n                        if (0 !== returnFiber.tag || \"[object GeneratorFunction]\" !== Object.prototype.toString.call(returnFiber.type) || \"[object Generator]\" !== Object.prototype.toString.call(newChildren)) didWarnAboutGenerators || console.error(\"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"), didWarnAboutGenerators = !0;\n                    } else newChild.entries !== key || didWarnAboutMaps || (console.error(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"), didWarnAboutMaps = !0);\n                    returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);\n                    currentDebugInfo = prevDebugInfo;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return prevDebugInfo = \"\" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return deleteRemainingChildren(returnFiber, currentFirstChild);\n        }\n        return function(returnFiber, currentFirstChild, newChild, lanes) {\n            var prevDebugInfo = currentDebugInfo;\n            currentDebugInfo = null;\n            try {\n                thenableIndexCounter$1 = 0;\n                var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);\n                thenableState$1 = null;\n                return firstChildFiber;\n            } catch (x) {\n                if (x === SuspenseException) throw x;\n                var fiber = createFiber(29, x, null, returnFiber.mode);\n                fiber.lanes = lanes;\n                fiber.return = returnFiber;\n                var debugInfo = fiber._debugInfo = currentDebugInfo;\n                fiber._debugOwner = returnFiber._debugOwner;\n                if (null != debugInfo) {\n                    for(var i = debugInfo.length - 1; 0 <= i; i--)if (\"string\" === typeof debugInfo[i].stack) {\n                        fiber._debugOwner = debugInfo[i];\n                        break;\n                    }\n                }\n                return fiber;\n            } finally{\n                currentDebugInfo = prevDebugInfo;\n            }\n        };\n    }\n    function pushHiddenContext(fiber, context) {\n        var prevEntangledRenderLanes = entangledRenderLanes;\n        push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, context, fiber);\n        entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;\n    }\n    function reuseHiddenContextOnStack(fiber) {\n        push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);\n    }\n    function popHiddenContext(fiber) {\n        entangledRenderLanes = prevEntangledRenderLanesCursor.current;\n        pop(currentTreeHiddenStackCursor, fiber);\n        pop(prevEntangledRenderLanesCursor, fiber);\n    }\n    function pushPrimaryTreeSuspenseHandler(handler) {\n        var current = handler.alternate;\n        push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);\n        push(suspenseHandlerStackCursor, handler, handler);\n        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));\n    }\n    function pushOffscreenSuspenseHandler(fiber) {\n        if (22 === fiber.tag) {\n            if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {\n                var current = fiber.alternate;\n                null !== current && null !== current.memoizedState && (shellBoundary = fiber);\n            }\n        } else reuseSuspenseHandlerOnStack(fiber);\n    }\n    function reuseSuspenseHandlerOnStack(fiber) {\n        push(suspenseStackCursor, suspenseStackCursor.current, fiber);\n        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);\n    }\n    function popSuspenseHandler(fiber) {\n        pop(suspenseHandlerStackCursor, fiber);\n        shellBoundary === fiber && (shellBoundary = null);\n        pop(suspenseStackCursor, fiber);\n    }\n    function findFirstSuspended(row) {\n        for(var node = row; null !== node;){\n            if (13 === node.tag) {\n                var state = node.memoizedState;\n                if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state))) return node;\n            } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {\n                if (0 !== (node.flags & 128)) return node;\n            } else if (null !== node.child) {\n                node.child.return = node;\n                node = node.child;\n                continue;\n            }\n            if (node === row) break;\n            for(; null === node.sibling;){\n                if (null === node.return || node.return === row) return null;\n                node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function mountHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        null === hookTypesDev ? hookTypesDev = [\n            hookName\n        ] : hookTypesDev.push(hookName);\n    }\n    function updateHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {\n            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n            if (!didWarnAboutMismatchedHooksForComponent.has(componentName) && (didWarnAboutMismatchedHooksForComponent.add(componentName), null !== hookTypesDev)) {\n                for(var table = \"\", i = 0; i <= hookTypesUpdateIndexDev; i++){\n                    var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;\n                    for(oldHookName = i + 1 + \". \" + oldHookName; 30 > oldHookName.length;)oldHookName += \" \";\n                    oldHookName += newHookName + \"\\n\";\n                    table += oldHookName;\n                }\n                console.error(\"React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\\n\\n   Previous render            Next render\\n   ------------------------------------------------------\\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\", componentName, table);\n            }\n        }\n    }\n    function checkDepsAreArrayDev(deps) {\n        void 0 === deps || null === deps || isArrayImpl(deps) || console.error(\"%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.\", currentHookNameInDev, typeof deps);\n    }\n    function warnOnUseFormStateInDev() {\n        var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n        didWarnAboutUseFormState.has(componentName) || (didWarnAboutUseFormState.add(componentName), console.error(\"ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.\", componentName));\n    }\n    function throwInvalidHookError() {\n        throw Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n    }\n    function areHookInputsEqual(nextDeps, prevDeps) {\n        if (ignorePreviousDependencies) return !1;\n        if (null === prevDeps) return console.error(\"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\", currentHookNameInDev), !1;\n        nextDeps.length !== prevDeps.length && console.error(\"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\", currentHookNameInDev, \"[\" + prevDeps.join(\", \") + \"]\", \"[\" + nextDeps.join(\", \") + \"]\");\n        for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++)if (!objectIs(nextDeps[i], prevDeps[i])) return !1;\n        return !0;\n    }\n    function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n        renderLanes = nextRenderLanes;\n        currentlyRenderingFiber$1 = workInProgress;\n        hookTypesDev = null !== current ? current._debugHookTypes : null;\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        if (\"[object AsyncFunction]\" === Object.prototype.toString.call(Component) || \"[object AsyncGeneratorFunction]\" === Object.prototype.toString.call(Component)) nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber$1), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(\"async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\"));\n        workInProgress.memoizedState = null;\n        workInProgress.updateQueue = null;\n        workInProgress.lanes = 0;\n        ReactSharedInternals.H = null !== current && null !== current.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;\n        shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress.mode & 8) !== NoMode;\n        var children = callComponentInDEV(Component, props, secondArg);\n        shouldDoubleInvokeUserFnsInHooksDEV = !1;\n        didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress, Component, props, secondArg));\n        if (nextRenderLanes) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        finishRenderingHooks(current, workInProgress);\n        return children;\n    }\n    function finishRenderingHooks(current, workInProgress) {\n        workInProgress._debugHookTypes = hookTypesDev;\n        null === workInProgress.dependencies ? null !== thenableState && (workInProgress.dependencies = {\n            lanes: 0,\n            firstContext: null,\n            _debugThenableState: thenableState\n        }) : workInProgress.dependencies._debugThenableState = thenableState;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;\n        renderLanes = 0;\n        hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n        hookTypesUpdateIndexDev = -1;\n        null !== current && (current.flags & 31457280) !== (workInProgress.flags & 31457280) && console.error(\"Internal React error: Expected static flag was missing. Please notify the React team.\");\n        didScheduleRenderPhaseUpdate = !1;\n        thenableIndexCounter = 0;\n        thenableState = null;\n        if (didRenderTooFewHooks) throw Error(\"Rendered fewer hooks than expected. This may be caused by an accidental early return statement.\");\n        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));\n        needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = !1, current = !0) : current = !1;\n        current && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Unknown\", didWarnAboutUseWrappedInTryCatch.has(workInProgress) || didWarnAboutAsyncClientComponent.has(workInProgress) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress), console.error(\"`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.\")));\n    }\n    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n        currentlyRenderingFiber$1 = workInProgress;\n        var numberOfReRenders = 0;\n        do {\n            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);\n            thenableIndexCounter = 0;\n            didScheduleRenderPhaseUpdateDuringThisPass = !1;\n            if (numberOfReRenders >= RE_RENDER_LIMIT) throw Error(\"Too many re-renders. React limits the number of renders to prevent an infinite loop.\");\n            numberOfReRenders += 1;\n            ignorePreviousDependencies = !1;\n            workInProgressHook = currentHook = null;\n            if (null != workInProgress.updateQueue) {\n                var children = workInProgress.updateQueue;\n                children.lastEffect = null;\n                children.events = null;\n                children.stores = null;\n                null != children.memoCache && (children.memoCache.index = 0);\n            }\n            hookTypesUpdateIndexDev = -1;\n            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;\n            children = callComponentInDEV(Component, props, secondArg);\n        }while (didScheduleRenderPhaseUpdateDuringThisPass);\n        return children;\n    }\n    function TransitionAwareHostComponent() {\n        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];\n        maybeThenable = \"function\" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;\n        dispatcher = dispatcher.useState()[0];\n        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber$1.flags |= 1024);\n        return maybeThenable;\n    }\n    function checkDidRenderIdHook() {\n        var didRenderIdHook = 0 !== localIdCounter;\n        localIdCounter = 0;\n        return didRenderIdHook;\n    }\n    function bailoutHooks(current, workInProgress, lanes) {\n        workInProgress.updateQueue = current.updateQueue;\n        workInProgress.flags = (workInProgress.mode & 16) !== NoMode ? workInProgress.flags & -201328645 : workInProgress.flags & -2053;\n        current.lanes &= ~lanes;\n    }\n    function resetHooksOnUnwind(workInProgress) {\n        if (didScheduleRenderPhaseUpdate) {\n            for(workInProgress = workInProgress.memoizedState; null !== workInProgress;){\n                var queue = workInProgress.queue;\n                null !== queue && (queue.pending = null);\n                workInProgress = workInProgress.next;\n            }\n            didScheduleRenderPhaseUpdate = !1;\n        }\n        renderLanes = 0;\n        hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n        hookTypesUpdateIndexDev = -1;\n        currentHookNameInDev = null;\n        didScheduleRenderPhaseUpdateDuringThisPass = !1;\n        thenableIndexCounter = localIdCounter = 0;\n        thenableState = null;\n    }\n    function mountWorkInProgressHook() {\n        var hook = {\n            memoizedState: null,\n            baseState: null,\n            baseQueue: null,\n            queue: null,\n            next: null\n        };\n        null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;\n        return workInProgressHook;\n    }\n    function updateWorkInProgressHook() {\n        if (null === currentHook) {\n            var nextCurrentHook = currentlyRenderingFiber$1.alternate;\n            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;\n        } else nextCurrentHook = currentHook.next;\n        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next;\n        if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;\n        else {\n            if (null === nextCurrentHook) {\n                if (null === currentlyRenderingFiber$1.alternate) throw Error(\"Update hook called on initial render. This is likely a bug in React. Please file an issue.\");\n                throw Error(\"Rendered more hooks than during the previous render.\");\n            }\n            currentHook = nextCurrentHook;\n            nextCurrentHook = {\n                memoizedState: currentHook.memoizedState,\n                baseState: currentHook.baseState,\n                baseQueue: currentHook.baseQueue,\n                queue: currentHook.queue,\n                next: null\n            };\n            null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;\n        }\n        return workInProgressHook;\n    }\n    function useThenable(thenable) {\n        var index = thenableIndexCounter;\n        thenableIndexCounter += 1;\n        null === thenableState && (thenableState = createThenableState());\n        thenable = trackUsedThenable(thenableState, thenable, index);\n        index = currentlyRenderingFiber$1;\n        null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);\n        return thenable;\n    }\n    function use(usable) {\n        if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then) return useThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);\n        }\n        throw Error(\"An unsupported type was passed to use(): \" + String(usable));\n    }\n    function useMemoCache(size) {\n        var memoCache = null, updateQueue = currentlyRenderingFiber$1.updateQueue;\n        null !== updateQueue && (memoCache = updateQueue.memoCache);\n        if (null == memoCache) {\n            var current = currentlyRenderingFiber$1.alternate;\n            null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {\n                data: current.data.map(function(array) {\n                    return array.slice();\n                }),\n                index: 0\n            })));\n        }\n        null == memoCache && (memoCache = {\n            data: [],\n            index: 0\n        });\n        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = updateQueue);\n        updateQueue.memoCache = memoCache;\n        updateQueue = memoCache.data[memoCache.index];\n        if (void 0 === updateQueue || ignorePreviousDependencies) for(updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;\n        else updateQueue.length !== size && console.error(\"Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.\", updateQueue.length, size);\n        memoCache.index++;\n        return updateQueue;\n    }\n    function basicStateReducer(state, action) {\n        return \"function\" === typeof action ? action(state) : action;\n    }\n    function mountReducer(reducer, initialArg, init) {\n        var hook = mountWorkInProgressHook();\n        if (void 0 !== init) {\n            var initialState = init(initialArg);\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    init(initialArg);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        } else initialState = initialArg;\n        hook.memoizedState = hook.baseState = initialState;\n        reducer = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: reducer,\n            lastRenderedState: initialState\n        };\n        hook.queue = reducer;\n        reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, reducer);\n        return [\n            hook.memoizedState,\n            reducer\n        ];\n    }\n    function updateReducer(reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateReducerImpl(hook, currentHook, reducer);\n    }\n    function updateReducerImpl(hook, current, reducer) {\n        var queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;\n        if (null !== pendingQueue) {\n            if (null !== baseQueue) {\n                var baseFirst = baseQueue.next;\n                baseQueue.next = pendingQueue.next;\n                pendingQueue.next = baseFirst;\n            }\n            current.baseQueue !== baseQueue && console.error(\"Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.\");\n            current.baseQueue = baseQueue = pendingQueue;\n            queue.pending = null;\n        }\n        pendingQueue = hook.baseState;\n        if (null === baseQueue) hook.memoizedState = pendingQueue;\n        else {\n            current = baseQueue.next;\n            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction = !1;\n            do {\n                var updateLane = update.lane & -536870913;\n                if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    var revertLane = update.revertLane;\n                    if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {\n                        lane: 0,\n                        revertLane: 0,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    else if ((renderLanes & revertLane) === revertLane) {\n                        update = update.next;\n                        revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                        continue;\n                    } else updateLane = {\n                        lane: 0,\n                        revertLane: update.revertLane,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber$1.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;\n                    updateLane = update.action;\n                    shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);\n                    pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);\n                } else revertLane = {\n                    lane: updateLane,\n                    revertLane: update.revertLane,\n                    action: update.action,\n                    hasEagerState: update.hasEagerState,\n                    eagerState: update.eagerState,\n                    next: null\n                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber$1.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;\n                update = update.next;\n            }while (null !== update && update !== current);\n            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;\n            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = !0, didReadFromEntangledAsyncAction && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;\n            hook.memoizedState = pendingQueue;\n            hook.baseState = baseFirst;\n            hook.baseQueue = newBaseQueueLast;\n            queue.lastRenderedState = pendingQueue;\n        }\n        null === baseQueue && (queue.lanes = 0);\n        return [\n            hook.memoizedState,\n            queue.dispatch\n        ];\n    }\n    function rerenderReducer(reducer) {\n        var hook = updateWorkInProgressHook(), queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;\n        if (null !== lastRenderPhaseUpdate) {\n            queue.pending = null;\n            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n            do newState = reducer(newState, update.action), update = update.next;\n            while (update !== lastRenderPhaseUpdate);\n            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);\n            hook.memoizedState = newState;\n            null === hook.baseQueue && (hook.baseState = newState);\n            queue.lastRenderedState = newState;\n        }\n        return [\n            newState,\n            dispatch\n        ];\n    }\n    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber$1, hook = mountWorkInProgressHook();\n        if (isHydrating) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            var nextSnapshot = getServerSnapshot();\n            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(\"The result of getServerSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        } else {\n            nextSnapshot = getSnapshot();\n            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0));\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            0 !== (workInProgressRootRenderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n        }\n        hook.memoizedState = nextSnapshot;\n        getServerSnapshot = {\n            value: nextSnapshot,\n            getSnapshot: getSnapshot\n        };\n        hook.queue = getServerSnapshot;\n        mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [\n            subscribe\n        ]);\n        fiber.flags |= 2048;\n        pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), {\n            destroy: void 0\n        }, null);\n        return nextSnapshot;\n    }\n    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber$1, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;\n        if (isHydrating$jscomp$0) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            getServerSnapshot = getServerSnapshot();\n        } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {\n            var cachedSnapshot = getSnapshot();\n            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        }\n        if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot)) hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0;\n        hook = hook.queue;\n        var create = subscribeToStore.bind(null, fiber, hook, subscribe);\n        updateEffectImpl(2048, Passive, create, [\n            subscribe\n        ]);\n        if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {\n            fiber.flags |= 2048;\n            pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), {\n                destroy: void 0\n            }, null);\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            isHydrating$jscomp$0 || 0 !== (renderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n        }\n        return getServerSnapshot;\n    }\n    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n        fiber.flags |= 16384;\n        fiber = {\n            getSnapshot: getSnapshot,\n            value: renderedSnapshot\n        };\n        getSnapshot = currentlyRenderingFiber$1.updateQueue;\n        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = getSnapshot, getSnapshot.stores = [\n            fiber\n        ]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [\n            fiber\n        ] : renderedSnapshot.push(fiber));\n    }\n    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n        inst.value = nextSnapshot;\n        inst.getSnapshot = getSnapshot;\n        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n    }\n    function subscribeToStore(fiber, inst, subscribe) {\n        return subscribe(function() {\n            checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n        });\n    }\n    function checkIfSnapshotChanged(inst) {\n        var latestGetSnapshot = inst.getSnapshot;\n        inst = inst.value;\n        try {\n            var nextValue = latestGetSnapshot();\n            return !objectIs(inst, nextValue);\n        } catch (error) {\n            return !0;\n        }\n    }\n    function forceStoreRerender(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    }\n    function mountStateImpl(initialState) {\n        var hook = mountWorkInProgressHook();\n        if (\"function\" === typeof initialState) {\n            var initialStateInitializer = initialState;\n            initialState = initialStateInitializer();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    initialStateInitializer();\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        }\n        hook.memoizedState = hook.baseState = initialState;\n        hook.queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: basicStateReducer,\n            lastRenderedState: initialState\n        };\n        return hook;\n    }\n    function mountState(initialState) {\n        initialState = mountStateImpl(initialState);\n        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n        queue.dispatch = dispatch;\n        return [\n            initialState.memoizedState,\n            dispatch\n        ];\n    }\n    function mountOptimistic(passthrough) {\n        var hook = mountWorkInProgressHook();\n        hook.memoizedState = hook.baseState = passthrough;\n        var queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: null,\n            lastRenderedState: null\n        };\n        hook.queue = queue;\n        hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !0, queue);\n        queue.dispatch = hook;\n        return [\n            passthrough,\n            hook\n        ];\n    }\n    function updateOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n    }\n    function updateOptimisticImpl(hook, current, passthrough, reducer) {\n        hook.baseState = passthrough;\n        return updateReducerImpl(hook, currentHook, \"function\" === typeof reducer ? reducer : basicStateReducer);\n    }\n    function rerenderOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n        hook.baseState = passthrough;\n        return [\n            passthrough,\n            hook.queue.dispatch\n        ];\n    }\n    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {\n        if (isRenderPhaseUpdate(fiber)) throw Error(\"Cannot update form state while rendering.\");\n        fiber = actionQueue.action;\n        if (null !== fiber) {\n            var actionNode = {\n                payload: payload,\n                action: fiber,\n                next: null,\n                isTransition: !0,\n                status: \"pending\",\n                value: null,\n                reason: null,\n                listeners: [],\n                then: function(listener) {\n                    actionNode.listeners.push(listener);\n                }\n            };\n            null !== ReactSharedInternals.T ? setPendingState(!0) : actionNode.isTransition = !1;\n            setState(actionNode);\n            setPendingState = actionQueue.pending;\n            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);\n        }\n    }\n    function runActionStateAction(actionQueue, node) {\n        var action = node.action, payload = node.payload, prevState = actionQueue.state;\n        if (node.isTransition) {\n            var prevTransition = ReactSharedInternals.T, currentTransition = {};\n            ReactSharedInternals.T = currentTransition;\n            ReactSharedInternals.T._updatedFibers = new Set();\n            try {\n                var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;\n                null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n                handleActionReturnValue(actionQueue, node, returnValue);\n            } catch (error) {\n                onActionError(actionQueue, node, error);\n            } finally{\n                ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n            }\n        } else try {\n            currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);\n        } catch (error$2) {\n            onActionError(actionQueue, node, error$2);\n        }\n    }\n    function handleActionReturnValue(actionQueue, node, returnValue) {\n        null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then ? (returnValue.then(function(nextState) {\n            onActionSuccess(actionQueue, node, nextState);\n        }, function(error) {\n            return onActionError(actionQueue, node, error);\n        }), node.isTransition || console.error(\"An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`\")) : onActionSuccess(actionQueue, node, returnValue);\n    }\n    function onActionSuccess(actionQueue, actionNode, nextState) {\n        actionNode.status = \"fulfilled\";\n        actionNode.value = nextState;\n        notifyActionListeners(actionNode);\n        actionQueue.state = nextState;\n        actionNode = actionQueue.pending;\n        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));\n    }\n    function onActionError(actionQueue, actionNode, error) {\n        var last = actionQueue.pending;\n        actionQueue.pending = null;\n        if (null !== last) {\n            last = last.next;\n            do actionNode.status = \"rejected\", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;\n            while (actionNode !== last);\n        }\n        actionQueue.action = null;\n    }\n    function notifyActionListeners(actionNode) {\n        actionNode = actionNode.listeners;\n        for(var i = 0; i < actionNode.length; i++)(0, actionNode[i])();\n    }\n    function actionStateReducer(oldState, newState) {\n        return newState;\n    }\n    function mountActionState(action, initialStateProp) {\n        if (isHydrating) {\n            var ssrFormState = workInProgressRoot.formState;\n            if (null !== ssrFormState) {\n                a: {\n                    var isMatching = currentlyRenderingFiber$1;\n                    if (isHydrating) {\n                        if (nextHydratableInstance) {\n                            var markerInstance = canHydrateFormStateMarker(nextHydratableInstance, rootOrSingletonContext);\n                            if (markerInstance) {\n                                nextHydratableInstance = getNextHydratableSibling(markerInstance);\n                                isMatching = isFormStateMarkerMatching(markerInstance);\n                                break a;\n                            }\n                        }\n                        throwOnHydrationMismatch(isMatching);\n                    }\n                    isMatching = !1;\n                }\n                isMatching && (initialStateProp = ssrFormState[0]);\n            }\n        }\n        ssrFormState = mountWorkInProgressHook();\n        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;\n        isMatching = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: actionStateReducer,\n            lastRenderedState: initialStateProp\n        };\n        ssrFormState.queue = isMatching;\n        ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber$1, isMatching);\n        isMatching.dispatch = ssrFormState;\n        isMatching = mountStateImpl(!1);\n        var setPendingState = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !1, isMatching.queue);\n        isMatching = mountWorkInProgressHook();\n        markerInstance = {\n            state: initialStateProp,\n            dispatch: null,\n            action: action,\n            pending: null\n        };\n        isMatching.queue = markerInstance;\n        ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber$1, markerInstance, setPendingState, ssrFormState);\n        markerInstance.dispatch = ssrFormState;\n        isMatching.memoizedState = action;\n        return [\n            initialStateProp,\n            ssrFormState,\n            !1\n        ];\n    }\n    function updateActionState(action) {\n        var stateHook = updateWorkInProgressHook();\n        return updateActionStateImpl(stateHook, currentHook, action);\n    }\n    function updateActionStateImpl(stateHook, currentStateHook, action) {\n        currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];\n        stateHook = updateReducer(basicStateReducer)[0];\n        currentStateHook = \"object\" === typeof currentStateHook && null !== currentStateHook && \"function\" === typeof currentStateHook.then ? useThenable(currentStateHook) : currentStateHook;\n        var actionQueueHook = updateWorkInProgressHook(), actionQueue = actionQueueHook.queue, dispatch = actionQueue.dispatch;\n        action !== actionQueueHook.memoizedState && (currentlyRenderingFiber$1.flags |= 2048, pushEffect(HasEffect | Passive, actionStateActionEffect.bind(null, actionQueue, action), {\n            destroy: void 0\n        }, null));\n        return [\n            currentStateHook,\n            dispatch,\n            stateHook\n        ];\n    }\n    function actionStateActionEffect(actionQueue, action) {\n        actionQueue.action = action;\n    }\n    function rerenderActionState(action) {\n        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;\n        if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);\n        updateWorkInProgressHook();\n        stateHook = stateHook.memoizedState;\n        currentStateHook = updateWorkInProgressHook();\n        var dispatch = currentStateHook.queue.dispatch;\n        currentStateHook.memoizedState = action;\n        return [\n            stateHook,\n            dispatch,\n            !1\n        ];\n    }\n    function pushEffect(tag, create, inst, deps) {\n        tag = {\n            tag: tag,\n            create: create,\n            inst: inst,\n            deps: deps,\n            next: null\n        };\n        create = currentlyRenderingFiber$1.updateQueue;\n        null === create && (create = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = create);\n        inst = create.lastEffect;\n        null === inst ? create.lastEffect = tag.next = tag : (deps = inst.next, inst.next = tag, tag.next = deps, create.lastEffect = tag);\n        return tag;\n    }\n    function mountRef(initialValue) {\n        var hook = mountWorkInProgressHook();\n        initialValue = {\n            current: initialValue\n        };\n        return hook.memoizedState = initialValue;\n    }\n    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = mountWorkInProgressHook();\n        currentlyRenderingFiber$1.flags |= fiberFlags;\n        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, {\n            destroy: void 0\n        }, void 0 === deps ? null : deps);\n    }\n    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var inst = hook.memoizedState.inst;\n        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushEffect(hookFlags, create, inst, deps) : (currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(HasEffect | hookFlags, create, inst, deps));\n    }\n    function mountEffect(create, deps) {\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (currentlyRenderingFiber$1.mode & 64) === NoMode ? mountEffectImpl(142608384, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);\n    }\n    function mountLayoutEffect(create, deps) {\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (fiberFlags |= 67108864);\n        return mountEffectImpl(fiberFlags, Layout, create, deps);\n    }\n    function imperativeHandleEffect(create, ref) {\n        if (\"function\" === typeof ref) {\n            create = create();\n            var refCleanup = ref(create);\n            return function() {\n                \"function\" === typeof refCleanup ? refCleanup() : ref(null);\n            };\n        }\n        if (null !== ref && void 0 !== ref) return ref.hasOwnProperty(\"current\") || console.error(\"Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.\", \"an object with keys {\" + Object.keys(ref).join(\", \") + \"}\"), create = create(), ref.current = create, function() {\n            ref.current = null;\n        };\n    }\n    function mountImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (fiberFlags |= 67108864);\n        mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function updateImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function mountCallback(callback, deps) {\n        mountWorkInProgressHook().memoizedState = [\n            callback,\n            void 0 === deps ? null : deps\n        ];\n        return callback;\n    }\n    function updateCallback(callback, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        hook.memoizedState = [\n            callback,\n            deps\n        ];\n        return callback;\n    }\n    function mountMemo(nextCreate, deps) {\n        var hook = mountWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var nextValue = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            nextValue,\n            deps\n        ];\n        return nextValue;\n    }\n    function updateMemo(nextCreate, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        prevState = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            prevState,\n            deps\n        ];\n        return prevState;\n    }\n    function mountDeferredValue(value, initialValue) {\n        var hook = mountWorkInProgressHook();\n        return mountDeferredValueImpl(hook, value, initialValue);\n    }\n    function updateDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function rerenderDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function mountDeferredValueImpl(hook, value, initialValue) {\n        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824)) return hook.memoizedState = value;\n        hook.memoizedState = initialValue;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber$1.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return initialValue;\n    }\n    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n        if (objectIs(value, prevValue)) return value;\n        if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = !0), hook;\n        if (0 === (renderLanes & 42)) return didReceiveUpdate = !0, hook.memoizedState = value;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber$1.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return prevValue;\n    }\n    function startTransition(fiber, queue, pendingState, finishedState, callback) {\n        var previousPriority = getCurrentUpdatePriority();\n        setCurrentUpdatePriority(0 !== previousPriority && 8 > previousPriority ? previousPriority : 8);\n        var prevTransition = ReactSharedInternals.T, currentTransition = {};\n        ReactSharedInternals.T = currentTransition;\n        dispatchOptimisticSetState(fiber, !1, queue, pendingState);\n        currentTransition._updatedFibers = new Set();\n        try {\n            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;\n            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n            if (null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then) {\n                var thenableForFinishedState = chainThenableValue(returnValue, finishedState);\n                dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));\n            } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));\n        } catch (error) {\n            dispatchSetStateInternal(fiber, queue, {\n                then: function() {},\n                status: \"rejected\",\n                reason: error\n            }, requestUpdateLane(fiber));\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n        }\n    }\n    function ensureFormComponentIsStateful(formFiber) {\n        var existingStateHook = formFiber.memoizedState;\n        if (null !== existingStateHook) return existingStateHook;\n        existingStateHook = {\n            memoizedState: NotPendingTransition,\n            baseState: NotPendingTransition,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: NotPendingTransition\n            },\n            next: null\n        };\n        var initialResetState = {};\n        existingStateHook.next = {\n            memoizedState: initialResetState,\n            baseState: initialResetState,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialResetState\n            },\n            next: null\n        };\n        formFiber.memoizedState = existingStateHook;\n        formFiber = formFiber.alternate;\n        null !== formFiber && (formFiber.memoizedState = existingStateHook);\n        return existingStateHook;\n    }\n    function mountTransition() {\n        var stateHook = mountStateImpl(!1);\n        stateHook = startTransition.bind(null, currentlyRenderingFiber$1, stateHook.queue, !0, !1);\n        mountWorkInProgressHook().memoizedState = stateHook;\n        return [\n            !1,\n            stateHook\n        ];\n    }\n    function updateTransition() {\n        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    function rerenderTransition() {\n        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    function useHostTransitionStatus() {\n        return readContext(HostTransitionContext);\n    }\n    function mountId() {\n        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;\n        if (isHydrating) {\n            var treeId = treeContextOverflow;\n            var idWithLeadingBit = treeContextId;\n            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;\n            identifierPrefix = \":\" + identifierPrefix + \"R\" + treeId;\n            treeId = localIdCounter++;\n            0 < treeId && (identifierPrefix += \"H\" + treeId.toString(32));\n            identifierPrefix += \":\";\n        } else treeId = globalClientIdCounter++, identifierPrefix = \":\" + identifierPrefix + \"r\" + treeId.toString(32) + \":\";\n        return hook.memoizedState = identifierPrefix;\n    }\n    function mountRefresh() {\n        return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1);\n    }\n    function refreshCache(fiber, seedKey) {\n        for(var provider = fiber.return; null !== provider;){\n            switch(provider.tag){\n                case 24:\n                case 3:\n                    var lane = requestUpdateLane(provider);\n                    fiber = createUpdate(lane);\n                    var root = enqueueUpdate(provider, fiber, lane);\n                    null !== root && (scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));\n                    provider = createCache();\n                    null !== seedKey && void 0 !== seedKey && null !== root && console.error(\"The seed argument is not enabled outside experimental channels.\");\n                    fiber.payload = {\n                        cache: provider\n                    };\n                    return;\n            }\n            provider = provider.return;\n        }\n    }\n    function dispatchReducerAction(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0) {\n        \"function\" === typeof JSCompiler_OptimizeArgumentsArray_p0 && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        JSCompiler_OptimizeArgumentsArray_p0 = requestUpdateLane(fiber);\n        action = {\n            lane: JSCompiler_OptimizeArgumentsArray_p0,\n            revertLane: 0,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0), null !== action && (scheduleUpdateOnFiber(action, fiber, JSCompiler_OptimizeArgumentsArray_p0), entangleTransitionUpdate(action, queue, JSCompiler_OptimizeArgumentsArray_p0)));\n        markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p0);\n    }\n    function dispatchSetState(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1) {\n        \"function\" === typeof JSCompiler_OptimizeArgumentsArray_p1 && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        JSCompiler_OptimizeArgumentsArray_p1 = requestUpdateLane(fiber);\n        dispatchSetStateInternal(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1);\n        markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p1);\n    }\n    function dispatchSetStateInternal(fiber, queue, action, lane) {\n        var update = {\n            lane: lane,\n            revertLane: 0,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);\n        else {\n            var alternate = fiber.alternate;\n            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {\n                var prevDispatcher = ReactSharedInternals.H;\n                ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                try {\n                    var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);\n                    update.hasEagerState = !0;\n                    update.eagerState = eagerState;\n                    if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1;\n                } catch (error) {} finally{\n                    ReactSharedInternals.H = prevDispatcher;\n                }\n            }\n            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n            if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0;\n        }\n        return !1;\n    }\n    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n        null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(\"An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.\");\n        action = {\n            lane: 2,\n            revertLane: requestTransitionLane(),\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) {\n            if (throwIfDuringRender) throw Error(\"Cannot update optimistic state while rendering.\");\n            console.error(\"Cannot call startTransition while rendering.\");\n        } else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);\n        markStateUpdateScheduled(fiber, 2);\n    }\n    function isRenderPhaseUpdate(fiber) {\n        var alternate = fiber.alternate;\n        return fiber === currentlyRenderingFiber$1 || null !== alternate && alternate === currentlyRenderingFiber$1;\n    }\n    function enqueueRenderPhaseUpdate(queue, update) {\n        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;\n        var pending = queue.pending;\n        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n        queue.pending = update;\n    }\n    function entangleTransitionUpdate(root, queue, lane) {\n        if (0 !== (lane & 4194176)) {\n            var queueLanes = queue.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            queue.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function warnOnInvalidCallback(callback) {\n        if (null !== callback && \"function\" !== typeof callback) {\n            var key = String(callback);\n            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback));\n        }\n    }\n    function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n        var prevState = workInProgress.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);\n        if (workInProgress.mode & 8) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                partialState = getDerivedStateFromProps(nextProps, prevState);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        void 0 === partialState && (ctor = getComponentNameFromType(ctor) || \"Component\", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\", ctor)));\n        prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);\n        workInProgress.memoizedState = prevState;\n        0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = prevState);\n    }\n    function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n        var instance = workInProgress.stateNode;\n        if (\"function\" === typeof instance.shouldComponentUpdate) {\n            oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n            if (workInProgress.mode & 8) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            void 0 === oldProps && console.error(\"%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.\", getComponentNameFromType(ctor) || \"Component\");\n            return oldProps;\n        }\n        return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;\n    }\n    function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n        var oldState = instance.state;\n        \"function\" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);\n        \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n        instance.state !== oldState && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Component\", didWarnAboutStateAssignmentForComponent.has(workInProgress) || (didWarnAboutStateAssignmentForComponent.add(workInProgress), console.error(\"%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", workInProgress)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));\n    }\n    function resolveClassComponentProps(Component, baseProps) {\n        var newProps = baseProps;\n        if (\"ref\" in baseProps) {\n            newProps = {};\n            for(var propName in baseProps)\"ref\" !== propName && (newProps[propName] = baseProps[propName]);\n        }\n        if (Component = Component.defaultProps) {\n            newProps === baseProps && (newProps = assign({}, newProps));\n            for(var _propName in Component)void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);\n        }\n        return newProps;\n    }\n    function logUncaughtError(root, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = null;\n            var error = errorInfo.value;\n            if (null !== ReactSharedInternals.actQueue) ReactSharedInternals.thrownErrors.push(error);\n            else {\n                var onUncaughtError = root.onUncaughtError;\n                onUncaughtError(error, {\n                    componentStack: errorInfo.stack\n                });\n            }\n        } catch (e) {\n            setTimeout(function() {\n                throw e;\n            });\n        }\n    }\n    function logCaughtError(root, boundary, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = getComponentNameFromFiber(boundary);\n            var onCaughtError = root.onCaughtError;\n            onCaughtError(errorInfo.value, {\n                componentStack: errorInfo.stack,\n                errorBoundary: 1 === boundary.tag ? boundary.stateNode : null\n            });\n        } catch (e) {\n            setTimeout(function() {\n                throw e;\n            });\n        }\n    }\n    function createRootErrorUpdate(root, errorInfo, lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        lane.payload = {\n            element: null\n        };\n        lane.callback = function() {\n            runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);\n        };\n        return lane;\n    }\n    function createClassErrorUpdate(lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        return lane;\n    }\n    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n        if (\"function\" === typeof getDerivedStateFromError) {\n            var error = errorInfo.value;\n            update.payload = function() {\n                return getDerivedStateFromError(error);\n            };\n            update.callback = function() {\n                markFailedErrorBoundaryForHotReloading(fiber);\n                runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            };\n        }\n        var inst = fiber.stateNode;\n        null !== inst && \"function\" === typeof inst.componentDidCatch && (update.callback = function() {\n            markFailedErrorBoundaryForHotReloading(fiber);\n            runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            \"function\" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([\n                this\n            ]) : legacyErrorBoundariesThatAlreadyFailed.add(this));\n            callComponentDidCatchInDEV(this, errorInfo);\n            \"function\" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(\"%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.\", getComponentNameFromFiber(fiber) || \"Unknown\");\n        });\n    }\n    function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n        sourceFiber.flags |= 32768;\n        isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);\n        if (null !== value && \"object\" === typeof value && \"function\" === typeof value.then) {\n            returnFiber = sourceFiber.alternate;\n            null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);\n            isHydrating && (didSuspendOrErrorDEV = !0);\n            sourceFiber = suspenseHandlerStackCursor.current;\n            if (null !== sourceFiber) {\n                switch(sourceFiber.tag){\n                    case 13:\n                        return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([\n                            value\n                        ]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), !1;\n                    case 22:\n                        return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {\n                            transitions: null,\n                            markerInstances: null,\n                            retryQueue: new Set([\n                                value\n                            ])\n                        }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([\n                            value\n                        ]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), !1;\n                }\n                throw Error(\"Unexpected Suspense handler tag (\" + sourceFiber.tag + \"). This is a bug in React.\");\n            }\n            attachPingListener(root, value, rootRenderLanes);\n            renderDidSuspendDelayIfPossible();\n            return !1;\n        }\n        if (isHydrating) return didSuspendOrErrorDEV = !0, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.\", {\n            cause: value\n        }), sourceFiber))) : (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering the entire root.\", {\n            cause: value\n        }), sourceFiber)), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), !1;\n        var error = createCapturedValueAtFiber(Error(\"There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.\", {\n            cause: value\n        }), sourceFiber);\n        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [\n            error\n        ] : workInProgressRootConcurrentErrors.push(error);\n        workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);\n        if (null === returnFiber) return !0;\n        value = createCapturedValueAtFiber(value, sourceFiber);\n        sourceFiber = returnFiber;\n        do {\n            switch(sourceFiber.tag){\n                case 3:\n                    return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), !1;\n                case 1:\n                    if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && (\"function\" === typeof returnFiber.getDerivedStateFromError || null !== error && \"function\" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), !1;\n            }\n            sourceFiber = sourceFiber.return;\n        }while (null !== sourceFiber);\n        return !1;\n    }\n    function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n        workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n    }\n    function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n        Component = Component.render;\n        var ref = workInProgress.ref;\n        if (\"ref\" in nextProps) {\n            var propsWithoutRef = {};\n            for(var key in nextProps)\"ref\" !== key && (propsWithoutRef[key] = nextProps[key]);\n        } else propsWithoutRef = nextProps;\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);\n        key = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && key && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null === current) {\n            var type = Component.type;\n            if (\"function\" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return Component = resolveFunctionForHotReloading(type), workInProgress.tag = 15, workInProgress.type = Component, validateFunctionComponentInDev(workInProgress, type), updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes);\n            current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n            current.ref = workInProgress.ref;\n            current.return = workInProgress;\n            return workInProgress.child = current;\n        }\n        type = current.child;\n        if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n            var prevProps = type.memoizedProps;\n            Component = Component.compare;\n            Component = null !== Component ? Component : shallowEqual;\n            if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        workInProgress.flags |= 1;\n        current = createWorkInProgress(type, nextProps);\n        current.ref = workInProgress.ref;\n        current.return = workInProgress;\n        return workInProgress.child = current;\n    }\n    function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null !== current) {\n            var prevProps = current.memoizedProps;\n            if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) if (didReceiveUpdate = !1, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes)) 0 !== (current.flags & 131072) && (didReceiveUpdate = !0);\n            else return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n    }\n    function updateOffscreenComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, nextChildren = nextProps.children, nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2), prevState = null !== current ? current.memoizedState : null;\n        markRef(current, workInProgress);\n        if (\"hidden\" === nextProps.mode || nextIsDetached) {\n            if (0 !== (workInProgress.flags & 128)) {\n                nextProps = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;\n                if (null !== current) {\n                    nextChildren = workInProgress.child = current.child;\n                    for(nextIsDetached = 0; null !== nextChildren;)nextIsDetached = nextIsDetached | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;\n                    workInProgress.childLanes = nextIsDetached & ~nextProps;\n                } else workInProgress.childLanes = 0, workInProgress.child = null;\n                return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes);\n            }\n            if (0 !== (renderLanes & 536870912)) workInProgress.memoizedState = {\n                baseLanes: 0,\n                cachePool: null\n            }, null !== current && pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(workInProgress), pushOffscreenSuspenseHandler(workInProgress);\n            else return workInProgress.lanes = workInProgress.childLanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes);\n        } else null !== prevState ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(workInProgress), workInProgress.memoizedState = null) : (null !== current && pushTransition(workInProgress, null), reuseHiddenContextOnStack(workInProgress), reuseSuspenseHandlerOnStack(workInProgress));\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {\n        var JSCompiler_inline_result = peekCacheFromPool();\n        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {\n            parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n            pool: JSCompiler_inline_result\n        };\n        workInProgress.memoizedState = {\n            baseLanes: nextBaseLanes,\n            cachePool: JSCompiler_inline_result\n        };\n        null !== current && pushTransition(workInProgress, null);\n        reuseHiddenContextOnStack(workInProgress);\n        pushOffscreenSuspenseHandler(workInProgress);\n        null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, !0);\n        return null;\n    }\n    function markRef(current, workInProgress) {\n        var ref = workInProgress.ref;\n        if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 2097664);\n        else {\n            if (\"function\" !== typeof ref && \"object\" !== typeof ref) throw Error(\"Expected ref to be a function, an object returned by React.createRef(), or undefined/null.\");\n            if (null === current || current.ref !== ref) workInProgress.flags |= 2097664;\n        }\n    }\n    function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (Component.prototype && \"function\" === typeof Component.prototype.render) {\n            var componentName = getComponentNameFromType(Component) || \"Unknown\";\n            didWarnAboutBadClass[componentName] || (console.error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName), didWarnAboutBadClass[componentName] = !0);\n        }\n        workInProgress.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n        null === current && (validateFunctionComponentInDev(workInProgress, workInProgress.type), Component.contextTypes && (componentName = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypes[componentName] || (didWarnAboutContextTypes[componentName] = !0, console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\", componentName))));\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        Component = renderWithHooks(current, workInProgress, Component, nextProps, void 0, renderLanes);\n        nextProps = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && nextProps && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, Component, renderLanes);\n        return workInProgress.child;\n    }\n    function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        workInProgress.updateQueue = null;\n        nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);\n        finishRenderingHooks(current, workInProgress);\n        Component = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && Component && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateClassComponent(current$jscomp$0, workInProgress, Component, nextProps, renderLanes) {\n        switch(shouldErrorImpl(workInProgress)){\n            case !1:\n                var _instance = workInProgress.stateNode, state = new workInProgress.type(workInProgress.memoizedProps, _instance.context).state;\n                _instance.updater.enqueueSetState(_instance, state, null);\n                break;\n            case !0:\n                workInProgress.flags |= 128;\n                workInProgress.flags |= 65536;\n                _instance = Error(\"Simulated error coming from DevTools\");\n                var lane = renderLanes & -renderLanes;\n                workInProgress.lanes |= lane;\n                state = workInProgressRoot;\n                if (null === state) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n                lane = createClassErrorUpdate(lane);\n                initializeClassErrorUpdate(lane, state, workInProgress, createCapturedValueAtFiber(_instance, workInProgress));\n                enqueueCapturedUpdate(workInProgress, lane);\n        }\n        prepareToReadContext(workInProgress);\n        if (null === workInProgress.stateNode) {\n            state = emptyContextObject;\n            _instance = Component.contextType;\n            \"contextType\" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\" : \"object\" !== typeof _instance ? \" However, it is set to a \" + typeof _instance + \".\" : _instance.$$typeof === REACT_CONSUMER_TYPE ? \" Did you accidentally pass the Context.Consumer instead?\" : \" However, it is set to an object with keys {\" + Object.keys(_instance).join(\", \") + \"}.\", console.error(\"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(Component) || \"Component\", lane));\n            \"object\" === typeof _instance && null !== _instance && (state = readContext(_instance));\n            _instance = new Component(nextProps, state);\n            if (workInProgress.mode & 8) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    _instance = new Component(nextProps, state);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            state = workInProgress.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;\n            _instance.updater = classComponentUpdater;\n            workInProgress.stateNode = _instance;\n            _instance._reactInternals = workInProgress;\n            _instance._reactInternalInstance = fakeInternalInstance;\n            \"function\" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(\"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", state, null === _instance.state ? \"null\" : \"undefined\", state)));\n            if (\"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) {\n                var foundWillUpdateName = lane = state = null;\n                \"function\" === typeof _instance.componentWillMount && !0 !== _instance.componentWillMount.__suppressDeprecationWarning ? state = \"componentWillMount\" : \"function\" === typeof _instance.UNSAFE_componentWillMount && (state = \"UNSAFE_componentWillMount\");\n                \"function\" === typeof _instance.componentWillReceiveProps && !0 !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = \"componentWillReceiveProps\" : \"function\" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = \"UNSAFE_componentWillReceiveProps\");\n                \"function\" === typeof _instance.componentWillUpdate && !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = \"componentWillUpdate\" : \"function\" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n                if (null !== state || null !== lane || null !== foundWillUpdateName) {\n                    _instance = getComponentNameFromType(Component) || \"Component\";\n                    var newApiName = \"function\" === typeof Component.getDerivedStateFromProps ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                    didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\", _instance, newApiName, null !== state ? \"\\n  \" + state : \"\", null !== lane ? \"\\n  \" + lane : \"\", null !== foundWillUpdateName ? \"\\n  \" + foundWillUpdateName : \"\"));\n                }\n            }\n            _instance = workInProgress.stateNode;\n            state = getComponentNameFromType(Component) || \"Component\";\n            _instance.render || (Component.prototype && \"function\" === typeof Component.prototype.render ? console.error(\"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\", state) : console.error(\"No `render` method found on the %s instance: you may have forgotten to define `render`.\", state));\n            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(\"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\", state);\n            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(\"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\", state);\n            _instance.contextType && console.error(\"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\", state);\n            Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(\"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\", state));\n            Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\", state));\n            \"function\" === typeof _instance.componentShouldUpdate && console.error(\"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\", state);\n            Component.prototype && Component.prototype.isPureReactComponent && \"undefined\" !== typeof _instance.shouldComponentUpdate && console.error(\"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(Component) || \"A pure component\");\n            \"function\" === typeof _instance.componentDidUnmount && console.error(\"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\", state);\n            \"function\" === typeof _instance.componentDidReceiveProps && console.error(\"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", state);\n            \"function\" === typeof _instance.componentWillRecieveProps && console.error(\"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", state);\n            \"function\" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(\"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", state);\n            lane = _instance.props !== nextProps;\n            void 0 !== _instance.props && lane && console.error(\"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\", state);\n            _instance.defaultProps && console.error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\", state, state);\n            \"function\" !== typeof _instance.getSnapshotBeforeUpdate || \"function\" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(Component)));\n            \"function\" === typeof _instance.getDerivedStateFromProps && console.error(\"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof _instance.getDerivedStateFromError && console.error(\"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof Component.getSnapshotBeforeUpdate && console.error(\"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\", state);\n            (lane = _instance.state) && (\"object\" !== typeof lane || isArrayImpl(lane)) && console.error(\"%s.state: must be set to an object or null\", state);\n            \"function\" === typeof _instance.getChildContext && \"object\" !== typeof Component.childContextTypes && console.error(\"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\", state);\n            _instance = workInProgress.stateNode;\n            _instance.props = nextProps;\n            _instance.state = workInProgress.memoizedState;\n            _instance.refs = {};\n            initializeUpdateQueue(workInProgress);\n            state = Component.contextType;\n            _instance.context = \"object\" === typeof state && null !== state ? readContext(state) : emptyContextObject;\n            _instance.state === nextProps && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(\"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\", state)));\n            workInProgress.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, _instance);\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, _instance);\n            _instance.state = workInProgress.memoizedState;\n            state = Component.getDerivedStateFromProps;\n            \"function\" === typeof state && (applyDerivedStateFromProps(workInProgress, Component, state, nextProps), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (state = _instance.state, \"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(\"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", getComponentNameFromFiber(workInProgress) || \"Component\"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress, nextProps, _instance, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308);\n            (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864);\n            _instance = !0;\n        } else if (null === current$jscomp$0) {\n            _instance = workInProgress.stateNode;\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            lane = resolveClassComponentProps(Component, unresolvedOldProps);\n            _instance.props = lane;\n            var oldContext = _instance.context;\n            foundWillUpdateName = Component.contextType;\n            state = emptyContextObject;\n            \"object\" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));\n            newApiName = Component.getDerivedStateFromProps;\n            foundWillUpdateName = \"function\" === typeof newApiName || \"function\" === typeof _instance.getSnapshotBeforeUpdate;\n            unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;\n            foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, state);\n            hasForceUpdate = !1;\n            var oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            oldContext = workInProgress.memoizedState;\n            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? (\"function\" === typeof newApiName && (applyDerivedStateFromProps(workInProgress, Component, newApiName, nextProps), oldContext = workInProgress.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (\"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864)) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864), _instance = !1);\n        } else {\n            _instance = workInProgress.stateNode;\n            cloneUpdateQueue(current$jscomp$0, workInProgress);\n            state = workInProgress.memoizedProps;\n            foundWillUpdateName = resolveClassComponentProps(Component, state);\n            _instance.props = foundWillUpdateName;\n            newApiName = workInProgress.pendingProps;\n            oldState = _instance.context;\n            oldContext = Component.contextType;\n            lane = emptyContextObject;\n            \"object\" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));\n            unresolvedOldProps = Component.getDerivedStateFromProps;\n            (oldContext = \"function\" === typeof unresolvedOldProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, lane);\n            hasForceUpdate = !1;\n            oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            var newState = workInProgress.memoizedState;\n            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies) ? (\"function\" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, Component, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies)) ? (oldContext || \"function\" !== typeof _instance.UNSAFE_componentWillUpdate && \"function\" !== typeof _instance.componentWillUpdate || (\"function\" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), \"function\" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), \"function\" === typeof _instance.componentDidUpdate && (workInProgress.flags |= 4), \"function\" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : (\"function\" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : (\"function\" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), _instance = !1);\n        }\n        lane = _instance;\n        markRef(current$jscomp$0, workInProgress);\n        state = 0 !== (workInProgress.flags & 128);\n        if (lane || state) {\n            lane = workInProgress.stateNode;\n            ReactSharedInternals.getCurrentStack = null === workInProgress ? null : getCurrentFiberStackInDev;\n            isRendering = !1;\n            current = workInProgress;\n            if (state && \"function\" !== typeof Component.getDerivedStateFromError) Component = null, profilerStartTime = -1;\n            else {\n                markComponentRenderStarted(workInProgress);\n                Component = callRenderInDEV(lane);\n                if (workInProgress.mode & 8) {\n                    setIsStrictModeForDevtools(!0);\n                    try {\n                        callRenderInDEV(lane);\n                    } finally{\n                        setIsStrictModeForDevtools(!1);\n                    }\n                }\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= 1;\n            null !== current$jscomp$0 && state ? (workInProgress.child = reconcileChildFibers(workInProgress, current$jscomp$0.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes)) : reconcileChildren(current$jscomp$0, workInProgress, Component, renderLanes);\n            workInProgress.memoizedState = lane.state;\n            current$jscomp$0 = workInProgress.child;\n        } else current$jscomp$0 = bailoutOnAlreadyFinishedWork(current$jscomp$0, workInProgress, renderLanes);\n        renderLanes = workInProgress.stateNode;\n        _instance && renderLanes.props !== nextProps && (didWarnAboutReassigningProps || console.error(\"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\", getComponentNameFromFiber(workInProgress) || \"a component\"), didWarnAboutReassigningProps = !0);\n        return current$jscomp$0;\n    }\n    function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {\n        resetHydrationState();\n        workInProgress.flags |= 256;\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function validateFunctionComponentInDev(workInProgress, Component) {\n        Component && Component.childContextTypes && console.error(\"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\", Component.displayName || Component.name || \"Component\");\n        \"function\" === typeof Component.getDerivedStateFromProps && (workInProgress = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] || (console.error(\"%s: Function components do not support getDerivedStateFromProps.\", workInProgress), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] = !0));\n        \"object\" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(\"%s: Function components do not support contextType.\", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = !0));\n    }\n    function mountSuspenseOffscreenState(renderLanes) {\n        return {\n            baseLanes: renderLanes,\n            cachePool: getSuspendedCache()\n        };\n    }\n    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {\n        current = null !== current ? current.childLanes & ~renderLanes : 0;\n        primaryTreeDidDefer && (current |= workInProgressDeferredLane);\n        return current;\n    }\n    function updateSuspenseComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps;\n        shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);\n        var showFallback = !1, didSuspend = 0 !== (workInProgress.flags & 128), JSCompiler_temp;\n        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? !1 : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));\n        JSCompiler_temp && (showFallback = !0, workInProgress.flags &= -129);\n        JSCompiler_temp = 0 !== (workInProgress.flags & 32);\n        workInProgress.flags &= -33;\n        if (null === current) {\n            if (isHydrating) {\n                showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack(workInProgress);\n                if (isHydrating) {\n                    var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;\n                    (JSCompiler_temp$jscomp$0 = !nextInstance) || (JSCompiler_temp$jscomp$0 = canHydrateSuspenseInstance(nextInstance, rootOrSingletonContext), null !== JSCompiler_temp$jscomp$0 ? (warnIfNotHydrating(), workInProgress.memoizedState = {\n                        dehydrated: JSCompiler_temp$jscomp$0,\n                        treeContext: null !== treeContextProvider ? {\n                            id: treeContextId,\n                            overflow: treeContextOverflow\n                        } : null,\n                        retryLane: 536870912\n                    }, didSuspend = createFiber(18, null, null, NoMode), didSuspend.stateNode = JSCompiler_temp$jscomp$0, didSuspend.return = workInProgress, workInProgress.child = didSuspend, hydrationParentFiber = workInProgress, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = !0) : JSCompiler_temp$jscomp$0 = !1, JSCompiler_temp$jscomp$0 = !JSCompiler_temp$jscomp$0);\n                    JSCompiler_temp$jscomp$0 && (warnNonHydratedInstance(workInProgress, nextInstance), throwOnHydrationMismatch(workInProgress));\n                }\n                nextInstance = workInProgress.memoizedState;\n                if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance)) return isSuspenseInstanceFallback(nextInstance) ? workInProgress.lanes = 16 : workInProgress.lanes = 536870912, null;\n                popSuspenseHandler(workInProgress);\n            }\n            nextInstance = nextProps.children;\n            nextProps = nextProps.fallback;\n            if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = workInProgress.mode, nextInstance = mountWorkInProgressOffscreenFiber({\n                mode: \"hidden\",\n                children: nextInstance\n            }, showFallback), nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes, null), nextInstance.return = workInProgress, nextProps.return = workInProgress, nextInstance.sibling = nextProps, workInProgress.child = nextInstance, showFallback = workInProgress.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes), showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;\n            pushPrimaryTreeSuspenseHandler(workInProgress);\n            return mountSuspensePrimaryChildren(workInProgress, nextInstance);\n        }\n        JSCompiler_temp$jscomp$0 = current.memoizedState;\n        if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {\n            if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, nextProps = mountWorkInProgressOffscreenFiber({\n                mode: \"visible\",\n                children: nextProps.children\n            }, nextInstance), showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2, nextProps.return = workInProgress, showFallback.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, reconcileChildFibers(workInProgress, current.child, null, renderLanes), nextProps = workInProgress.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = showFallback);\n            else if (pushPrimaryTreeSuspenseHandler(workInProgress), isHydrating && console.error(\"We should not be hydrating here. This is a bug in React. Please file a bug.\"), isSuspenseInstanceFallback(nextInstance)) nextInstance = getSuspenseInstanceFallbackErrorDetails(nextInstance), JSCompiler_temp = nextInstance.digest, showFallback = nextInstance.message, nextProps = nextInstance.stack, nextInstance = nextInstance.componentStack, showFallback = showFallback ? Error(showFallback) : Error(\"The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.\"), showFallback.stack = nextProps || \"\", showFallback.digest = JSCompiler_temp, JSCompiler_temp = void 0 === nextInstance ? null : nextInstance, nextProps = {\n                value: showFallback,\n                source: null,\n                stack: JSCompiler_temp\n            }, \"string\" === typeof JSCompiler_temp && CapturedStacks.set(showFallback, nextProps), queueHydrationError(nextProps), workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, !1), JSCompiler_temp = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || JSCompiler_temp) {\n                JSCompiler_temp = workInProgressRoot;\n                if (null !== JSCompiler_temp) {\n                    nextProps = renderLanes & -renderLanes;\n                    if (0 !== (nextProps & 42)) nextProps = 1;\n                    else switch(nextProps){\n                        case 2:\n                            nextProps = 1;\n                            break;\n                        case 8:\n                            nextProps = 4;\n                            break;\n                        case 32:\n                            nextProps = 16;\n                            break;\n                        case 128:\n                        case 256:\n                        case 512:\n                        case 1024:\n                        case 2048:\n                        case 4096:\n                        case 8192:\n                        case 16384:\n                        case 32768:\n                        case 65536:\n                        case 131072:\n                        case 262144:\n                        case 524288:\n                        case 1048576:\n                        case 2097152:\n                        case 4194304:\n                        case 8388608:\n                        case 16777216:\n                        case 33554432:\n                            nextProps = 64;\n                            break;\n                        case 268435456:\n                            nextProps = 134217728;\n                            break;\n                        default:\n                            nextProps = 0;\n                    }\n                    nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes)) ? 0 : nextProps;\n                    if (0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane) throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;\n                }\n                isSuspenseInstancePending(nextInstance) || renderDidSuspendDelayIfPossible();\n                workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            } else isSuspenseInstancePending(nextInstance) ? (workInProgress.flags |= 128, workInProgress.child = current.child, workInProgress = retryDehydratedSuspenseBoundary.bind(null, current), registerSuspenseInstanceRetry(nextInstance, workInProgress), workInProgress = null) : (current = JSCompiler_temp$jscomp$0.treeContext, supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(nextInstance), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !1, null !== current && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress)), workInProgress = mountSuspensePrimaryChildren(workInProgress, nextProps.children), workInProgress.flags |= 4096);\n            return workInProgress;\n        }\n        if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, JSCompiler_temp$jscomp$0 = current.child, didSuspend = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {\n            mode: \"hidden\",\n            children: nextProps.children\n        }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 31457280, null !== didSuspend ? showFallback = createWorkInProgress(didSuspend, showFallback) : (showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2), showFallback.return = workInProgress, nextProps.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, nextProps = showFallback, showFallback = workInProgress.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (didSuspend = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== didSuspend ? {\n            parent: didSuspend,\n            pool: didSuspend\n        } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {\n            baseLanes: nextInstance.baseLanes | renderLanes,\n            cachePool: JSCompiler_temp$jscomp$0\n        }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;\n        pushPrimaryTreeSuspenseHandler(workInProgress);\n        renderLanes = current.child;\n        current = renderLanes.sibling;\n        renderLanes = createWorkInProgress(renderLanes, {\n            mode: \"visible\",\n            children: nextProps.children\n        });\n        renderLanes.return = workInProgress;\n        renderLanes.sibling = null;\n        null !== current && (JSCompiler_temp = workInProgress.deletions, null === JSCompiler_temp ? (workInProgress.deletions = [\n            current\n        ], workInProgress.flags |= 16) : JSCompiler_temp.push(current));\n        workInProgress.child = renderLanes;\n        workInProgress.memoizedState = null;\n        return renderLanes;\n    }\n    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {\n        primaryChildren = mountWorkInProgressOffscreenFiber({\n            mode: \"visible\",\n            children: primaryChildren\n        }, workInProgress.mode);\n        primaryChildren.return = workInProgress;\n        return workInProgress.child = primaryChildren;\n    }\n    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {\n        return createFiberFromOffscreen(offscreenProps, mode, 0, null);\n    }\n    function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {\n        reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n        current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);\n        current.flags |= 2;\n        workInProgress.memoizedState = null;\n        return current;\n    }\n    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n        fiber.lanes |= renderLanes;\n        var alternate = fiber.alternate;\n        null !== alternate && (alternate.lanes |= renderLanes);\n        scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n    }\n    function validateSuspenseListNestedChild(childSlot, index) {\n        var isAnArray = isArrayImpl(childSlot);\n        childSlot = !isAnArray && \"function\" === typeof getIteratorFn(childSlot);\n        return isAnArray || childSlot ? (isAnArray = isAnArray ? \"array\" : \"iterable\", console.error(\"A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>\", isAnArray, index, isAnArray), !1) : !0;\n    }\n    function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n        var renderState = workInProgress.memoizedState;\n        null === renderState ? workInProgress.memoizedState = {\n            isBackwards: isBackwards,\n            rendering: null,\n            renderingStartTime: 0,\n            last: lastContentRow,\n            tail: tail,\n            tailMode: tailMode\n        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);\n    }\n    function updateSuspenseListComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;\n        nextProps = nextProps.children;\n        if (void 0 !== revealOrder && \"forwards\" !== revealOrder && \"backwards\" !== revealOrder && \"together\" !== revealOrder && !didWarnAboutRevealOrder[revealOrder]) if (didWarnAboutRevealOrder[revealOrder] = !0, \"string\" === typeof revealOrder) switch(revealOrder.toLowerCase()){\n            case \"together\":\n            case \"forwards\":\n            case \"backwards\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            case \"forward\":\n            case \"backward\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            default:\n                console.error('\"%s\" is not a supported revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        }\n        else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        void 0 === tailMode || didWarnAboutTailOptions[tailMode] || (\"collapsed\" !== tailMode && \"hidden\" !== tailMode ? (didWarnAboutTailOptions[tailMode] = !0, console.error('\"%s\" is not a supported value for tail on <SuspenseList />. Did you mean \"collapsed\" or \"hidden\"?', tailMode)) : \"forwards\" !== revealOrder && \"backwards\" !== revealOrder && (didWarnAboutTailOptions[tailMode] = !0, console.error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is \"forwards\" or \"backwards\". Did you mean to specify revealOrder=\"forwards\"?', tailMode)));\n        a: if ((\"forwards\" === revealOrder || \"backwards\" === revealOrder) && void 0 !== nextProps && null !== nextProps && !1 !== nextProps) if (isArrayImpl(nextProps)) for(var i = 0; i < nextProps.length; i++){\n            if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;\n        }\n        else if (i = getIteratorFn(nextProps), \"function\" === typeof i) {\n            if (i = i.call(nextProps)) for(var step = i.next(), _i = 0; !step.done; step = i.next()){\n                if (!validateSuspenseListNestedChild(step.value, _i)) break a;\n                _i++;\n            }\n        } else console.error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        nextProps = suspenseStackCursor.current;\n        if (0 !== (nextProps & ForceSuspenseFallback)) nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress.flags |= 128;\n        else {\n            if (null !== current && 0 !== (current.flags & 128)) a: for(current = workInProgress.child; null !== current;){\n                if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n                else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n                else if (null !== current.child) {\n                    current.child.return = current;\n                    current = current.child;\n                    continue;\n                }\n                if (current === workInProgress) break a;\n                for(; null === current.sibling;){\n                    if (null === current.return || current.return === workInProgress) break a;\n                    current = current.return;\n                }\n                current.sibling.return = current.return;\n                current = current.sibling;\n            }\n            nextProps &= SubtreeSuspenseContextMask;\n        }\n        push(suspenseStackCursor, nextProps, workInProgress);\n        switch(revealOrder){\n            case \"forwards\":\n                renderLanes = workInProgress.child;\n                for(revealOrder = null; null !== renderLanes;)current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;\n                renderLanes = revealOrder;\n                null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);\n                initSuspenseListRenderState(workInProgress, !1, revealOrder, renderLanes, tailMode);\n                break;\n            case \"backwards\":\n                renderLanes = null;\n                revealOrder = workInProgress.child;\n                for(workInProgress.child = null; null !== revealOrder;){\n                    current = revealOrder.alternate;\n                    if (null !== current && null === findFirstSuspended(current)) {\n                        workInProgress.child = revealOrder;\n                        break;\n                    }\n                    current = revealOrder.sibling;\n                    revealOrder.sibling = renderLanes;\n                    renderLanes = revealOrder;\n                    revealOrder = current;\n                }\n                initSuspenseListRenderState(workInProgress, !0, renderLanes, null, tailMode);\n                break;\n            case \"together\":\n                initSuspenseListRenderState(workInProgress, !1, null, null, void 0);\n                break;\n            default:\n                workInProgress.memoizedState = null;\n        }\n        return workInProgress.child;\n    }\n    function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n        null !== current && (workInProgress.dependencies = current.dependencies);\n        profilerStartTime = -1;\n        workInProgressRootSkippedLanes |= workInProgress.lanes;\n        if (0 === (renderLanes & workInProgress.childLanes)) if (null !== current) {\n            if (propagateParentContextChanges(current, workInProgress, renderLanes, !1), 0 === (renderLanes & workInProgress.childLanes)) return null;\n        } else return null;\n        if (null !== current && workInProgress.child !== current.child) throw Error(\"Resuming work not yet implemented.\");\n        if (null !== workInProgress.child) {\n            current = workInProgress.child;\n            renderLanes = createWorkInProgress(current, current.pendingProps);\n            workInProgress.child = renderLanes;\n            for(renderLanes.return = workInProgress; null !== current.sibling;)current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;\n            renderLanes.sibling = null;\n        }\n        return workInProgress.child;\n    }\n    function checkScheduledUpdateOrContext(current, renderLanes) {\n        if (0 !== (current.lanes & renderLanes)) return !0;\n        current = current.dependencies;\n        return null !== current && checkIfContextChanged(current) ? !0 : !1;\n    }\n    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n        switch(workInProgress.tag){\n            case 3:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n                resetHydrationState();\n                break;\n            case 27:\n            case 5:\n                pushHostContext(workInProgress);\n                break;\n            case 4:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                break;\n            case 10:\n                pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);\n                break;\n            case 12:\n                0 !== (renderLanes & workInProgress.childLanes) && (workInProgress.flags |= 4);\n                workInProgress.flags |= 2048;\n                var stateNode = workInProgress.stateNode;\n                stateNode.effectDuration = -0;\n                stateNode.passiveEffectDuration = -0;\n                break;\n            case 13:\n                stateNode = workInProgress.memoizedState;\n                if (null !== stateNode) {\n                    if (null !== stateNode.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;\n                    if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                    return null !== current ? current.sibling : null;\n                }\n                pushPrimaryTreeSuspenseHandler(workInProgress);\n                break;\n            case 19:\n                var didSuspendBefore = 0 !== (current.flags & 128);\n                stateNode = 0 !== (renderLanes & workInProgress.childLanes);\n                stateNode || (propagateParentContextChanges(current, workInProgress, renderLanes, !1), stateNode = 0 !== (renderLanes & workInProgress.childLanes));\n                if (didSuspendBefore) {\n                    if (stateNode) return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                    workInProgress.flags |= 128;\n                }\n                didSuspendBefore = workInProgress.memoizedState;\n                null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);\n                push(suspenseStackCursor, suspenseStackCursor.current, workInProgress);\n                if (stateNode) break;\n                else return null;\n            case 22:\n            case 23:\n                return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes);\n            case 24:\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n        }\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n    function beginWork(current, workInProgress, renderLanes) {\n        if (workInProgress._debugNeedsRemount && null !== current) {\n            renderLanes = createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes);\n            var returnFiber = workInProgress.return;\n            if (null === returnFiber) throw Error(\"Cannot swap the root fiber.\");\n            current.alternate = null;\n            workInProgress.alternate = null;\n            renderLanes.index = workInProgress.index;\n            renderLanes.sibling = workInProgress.sibling;\n            renderLanes.return = workInProgress.return;\n            renderLanes.ref = workInProgress.ref;\n            renderLanes._debugInfo = workInProgress._debugInfo;\n            if (workInProgress === returnFiber.child) returnFiber.child = renderLanes;\n            else {\n                var prevSibling = returnFiber.child;\n                if (null === prevSibling) throw Error(\"Expected parent to have a child.\");\n                for(; prevSibling.sibling !== workInProgress;)if (prevSibling = prevSibling.sibling, null === prevSibling) throw Error(\"Expected to find the previous sibling.\");\n                prevSibling.sibling = renderLanes;\n            }\n            workInProgress = returnFiber.deletions;\n            null === workInProgress ? (returnFiber.deletions = [\n                current\n            ], returnFiber.flags |= 16) : workInProgress.push(current);\n            renderLanes.flags |= 2;\n            return renderLanes;\n        }\n        if (null !== current) if (current.memoizedProps !== workInProgress.pendingProps || workInProgress.type !== current.type) didReceiveUpdate = !0;\n        else {\n            if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n            didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;\n        }\n        else {\n            didReceiveUpdate = !1;\n            if (returnFiber = isHydrating) warnIfNotHydrating(), returnFiber = 0 !== (workInProgress.flags & 1048576);\n            returnFiber && (returnFiber = workInProgress.index, warnIfNotHydrating(), pushTreeId(workInProgress, treeForkCount, returnFiber));\n        }\n        workInProgress.lanes = 0;\n        switch(workInProgress.tag){\n            case 16:\n                a: if (returnFiber = workInProgress.pendingProps, current = callLazyInitInDEV(workInProgress.elementType), workInProgress.type = current, \"function\" === typeof current) shouldConstruct(current) ? (returnFiber = resolveClassComponentProps(current, returnFiber), workInProgress.tag = 1, workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateClassComponent(null, workInProgress, current, returnFiber, renderLanes)) : (workInProgress.tag = 0, validateFunctionComponentInDev(workInProgress, current), workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateFunctionComponent(null, workInProgress, current, returnFiber, renderLanes));\n                else {\n                    if (void 0 !== current && null !== current) {\n                        if (prevSibling = current.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {\n                            workInProgress.tag = 11;\n                            workInProgress.type = current = resolveForwardRefForHotReloading(current);\n                            workInProgress = updateForwardRef(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        } else if (prevSibling === REACT_MEMO_TYPE) {\n                            workInProgress.tag = 14;\n                            workInProgress = updateMemoComponent(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        }\n                    }\n                    workInProgress = \"\";\n                    null !== current && \"object\" === typeof current && current.$$typeof === REACT_LAZY_TYPE && (workInProgress = \" Did you wrap a component in React.lazy() more than once?\");\n                    current = getComponentNameFromType(current) || current;\n                    throw Error(\"Element type is invalid. Received a promise that resolves to: \" + current + \". Lazy element type must resolve to a class or function.\" + workInProgress);\n                }\n                return workInProgress;\n            case 0:\n                return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 1:\n                return returnFiber = workInProgress.type, prevSibling = resolveClassComponentProps(returnFiber, workInProgress.pendingProps), updateClassComponent(current, workInProgress, returnFiber, prevSibling, renderLanes);\n            case 3:\n                a: {\n                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                    if (null === current) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                    var nextProps = workInProgress.pendingProps;\n                    prevSibling = workInProgress.memoizedState;\n                    returnFiber = prevSibling.element;\n                    cloneUpdateQueue(current, workInProgress);\n                    processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n                    var nextState = workInProgress.memoizedState;\n                    nextProps = nextState.cache;\n                    pushProvider(workInProgress, CacheContext, nextProps);\n                    nextProps !== prevSibling.cache && propagateContextChanges(workInProgress, [\n                        CacheContext\n                    ], renderLanes, !0);\n                    suspendIfUpdateReadFromEntangledAsyncAction();\n                    nextProps = nextState.element;\n                    if (supportsHydration && prevSibling.isDehydrated) if (prevSibling = {\n                        element: nextProps,\n                        isDehydrated: !1,\n                        cache: nextState.cache\n                    }, workInProgress.updateQueue.baseState = prevSibling, workInProgress.memoizedState = prevSibling, workInProgress.flags & 256) {\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);\n                        break a;\n                    } else if (nextProps !== returnFiber) {\n                        returnFiber = createCapturedValueAtFiber(Error(\"This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.\"), workInProgress);\n                        queueHydrationError(returnFiber);\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);\n                        break a;\n                    } else for(supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinContainer(workInProgress.stateNode.containerInfo), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !0), current = mountChildFibers(workInProgress, null, nextProps, renderLanes), workInProgress.child = current; current;)current.flags = current.flags & -3 | 4096, current = current.sibling;\n                    else {\n                        resetHydrationState();\n                        if (nextProps === returnFiber) {\n                            workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                            break a;\n                        }\n                        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n                    }\n                    workInProgress = workInProgress.child;\n                }\n                return workInProgress;\n            case 26:\n                if (supportsResources) return markRef(current, workInProgress), null === current ? (current = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = current : isHydrating || (workInProgress.stateNode = createHoistableInstance(workInProgress.type, workInProgress.pendingProps, requiredContext(rootInstanceStackCursor.current), workInProgress)) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;\n            case 27:\n                if (supportsSingletons) return pushHostContext(workInProgress), null === current && supportsSingletons && isHydrating && (prevSibling = requiredContext(rootInstanceStackCursor.current), returnFiber = getHostContext(), prevSibling = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, prevSibling, returnFiber, !1), didSuspendOrErrorDEV || (returnFiber = diffHydratedPropsForDevWarnings(prevSibling, workInProgress.type, workInProgress.pendingProps, returnFiber), null !== returnFiber && (buildHydrationDiffNode(workInProgress, 0).serverProps = returnFiber)), hydrationParentFiber = workInProgress, rootOrSingletonContext = !0, nextHydratableInstance = getFirstHydratableChild(prevSibling)), returnFiber = workInProgress.pendingProps.children, null !== current || isHydrating ? reconcileChildren(current, workInProgress, returnFiber, renderLanes) : workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes), markRef(current, workInProgress), workInProgress.child;\n            case 5:\n                return null === current && isHydrating && (nextProps = getHostContext(), returnFiber = validateHydratableInstance(workInProgress.type, workInProgress.pendingProps, nextProps), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(prevSibling, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), null !== nextState ? (workInProgress.stateNode = nextState, didSuspendOrErrorDEV || (nextProps = diffHydratedPropsForDevWarnings(nextState, workInProgress.type, workInProgress.pendingProps, nextProps), null !== nextProps && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextProps)), hydrationParentFiber = workInProgress, nextHydratableInstance = getFirstHydratableChild(nextState), rootOrSingletonContext = !1, nextProps = !0) : nextProps = !1, nextState = !nextProps), nextState && (returnFiber && warnNonHydratedInstance(workInProgress, prevSibling), throwOnHydrationMismatch(workInProgress))), pushHostContext(workInProgress), prevSibling = workInProgress.type, nextProps = workInProgress.pendingProps, nextState = null !== current ? current.memoizedProps : null, returnFiber = nextProps.children, shouldSetTextContent(prevSibling, nextProps) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress.flags |= 32), null !== workInProgress.memoizedState && (prevSibling = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes), isPrimaryRenderer ? HostTransitionContext._currentValue = prevSibling : HostTransitionContext._currentValue2 = prevSibling), markRef(current, workInProgress), reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 6:\n                return null === current && isHydrating && (current = workInProgress.pendingProps, renderLanes = getHostContext(), current = validateHydratableTextInstance(current, renderLanes), renderLanes = nextHydratableInstance, (returnFiber = !renderLanes) || (returnFiber = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext), null !== returnFiber ? (workInProgress.stateNode = returnFiber, hydrationParentFiber = workInProgress, nextHydratableInstance = null, returnFiber = !0) : returnFiber = !1, returnFiber = !returnFiber), returnFiber && (current && warnNonHydratedInstance(workInProgress, renderLanes), throwOnHydrationMismatch(workInProgress))), null;\n            case 13:\n                return updateSuspenseComponent(current, workInProgress, renderLanes);\n            case 4:\n                return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), returnFiber = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes) : reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 11:\n                return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 7:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;\n            case 8:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 12:\n                return workInProgress.flags |= 4, workInProgress.flags |= 2048, returnFiber = workInProgress.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 10:\n                return returnFiber = workInProgress.type, prevSibling = workInProgress.pendingProps, nextProps = prevSibling.value, \"value\" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = !0, console.error(\"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?\")), pushProvider(workInProgress, returnFiber, nextProps), reconcileChildren(current, workInProgress, prevSibling.children, renderLanes), workInProgress.child;\n            case 9:\n                return prevSibling = workInProgress.type._context, returnFiber = workInProgress.pendingProps.children, \"function\" !== typeof returnFiber && console.error(\"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"), prepareToReadContext(workInProgress), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress), returnFiber = callComponentInDEV(returnFiber, prevSibling, void 0), markComponentRenderStopped(), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 14:\n                return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 15:\n                return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 19:\n                return updateSuspenseListComponent(current, workInProgress, renderLanes);\n            case 22:\n                return updateOffscreenComponent(current, workInProgress, renderLanes);\n            case 24:\n                return prepareToReadContext(workInProgress), returnFiber = readContext(CacheContext), null === current ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, nextProps = createCache(), prevSibling.pooledCache = nextProps, retainCache(nextProps), null !== nextProps && (prevSibling.pooledCacheLanes |= renderLanes), prevSibling = nextProps), workInProgress.memoizedState = {\n                    parent: returnFiber,\n                    cache: prevSibling\n                }, initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, prevSibling)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current.memoizedState, nextProps = workInProgress.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {\n                    parent: returnFiber,\n                    cache: returnFiber\n                }, workInProgress.memoizedState = prevSibling, 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = prevSibling), pushProvider(workInProgress, CacheContext, returnFiber)) : (returnFiber = nextProps.cache, pushProvider(workInProgress, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(workInProgress, [\n                    CacheContext\n                ], renderLanes, !0))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 29:\n                throw workInProgress.pendingProps;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function resetContextDependencies() {\n        lastContextDependency = currentlyRenderingFiber = null;\n        isDisallowedContextReadInDEV = !1;\n    }\n    function pushProvider(providerFiber, context, nextValue) {\n        isPrimaryRenderer ? (push(valueCursor, context._currentValue, providerFiber), context._currentValue = nextValue, push(rendererCursorDEV, context._currentRenderer, providerFiber), void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"), context._currentRenderer = rendererSigil) : (push(valueCursor, context._currentValue2, providerFiber), context._currentValue2 = nextValue, push(renderer2CursorDEV, context._currentRenderer2, providerFiber), void 0 !== context._currentRenderer2 && null !== context._currentRenderer2 && context._currentRenderer2 !== rendererSigil && console.error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"), context._currentRenderer2 = rendererSigil);\n    }\n    function popProvider(context, providerFiber) {\n        var currentValue = valueCursor.current;\n        isPrimaryRenderer ? (context._currentValue = currentValue, currentValue = rendererCursorDEV.current, pop(rendererCursorDEV, providerFiber), context._currentRenderer = currentValue) : (context._currentValue2 = currentValue, currentValue = renderer2CursorDEV.current, pop(renderer2CursorDEV, providerFiber), context._currentRenderer2 = currentValue);\n        pop(valueCursor, providerFiber);\n    }\n    function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n        for(; null !== parent;){\n            var alternate = parent.alternate;\n            (parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);\n            if (parent === propagationRoot) break;\n            parent = parent.return;\n        }\n        parent !== propagationRoot && console.error(\"Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {\n        var fiber = workInProgress.child;\n        null !== fiber && (fiber.return = workInProgress);\n        for(; null !== fiber;){\n            var list = fiber.dependencies;\n            if (null !== list) {\n                var nextFiber = fiber.child;\n                list = list.firstContext;\n                a: for(; null !== list;){\n                    var dependency = list;\n                    list = fiber;\n                    for(var i = 0; i < contexts.length; i++)if (dependency.context === contexts[i]) {\n                        list.lanes |= renderLanes;\n                        dependency = list.alternate;\n                        null !== dependency && (dependency.lanes |= renderLanes);\n                        scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);\n                        forcePropagateEntireTree || (nextFiber = null);\n                        break a;\n                    }\n                    list = dependency.next;\n                }\n            } else if (18 === fiber.tag) {\n                nextFiber = fiber.return;\n                if (null === nextFiber) throw Error(\"We just came from a parent so we must have had a parent. This is a bug in React.\");\n                nextFiber.lanes |= renderLanes;\n                list = nextFiber.alternate;\n                null !== list && (list.lanes |= renderLanes);\n                scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);\n                nextFiber = null;\n            } else nextFiber = fiber.child;\n            if (null !== nextFiber) nextFiber.return = fiber;\n            else for(nextFiber = fiber; null !== nextFiber;){\n                if (nextFiber === workInProgress) {\n                    nextFiber = null;\n                    break;\n                }\n                fiber = nextFiber.sibling;\n                if (null !== fiber) {\n                    fiber.return = nextFiber.return;\n                    nextFiber = fiber;\n                    break;\n                }\n                nextFiber = nextFiber.return;\n            }\n            fiber = nextFiber;\n        }\n    }\n    function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {\n        current = null;\n        for(var parent = workInProgress, isInsidePropagationBailout = !1; null !== parent;){\n            if (!isInsidePropagationBailout) {\n                if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;\n                else if (0 !== (parent.flags & 262144)) break;\n            }\n            if (10 === parent.tag) {\n                var currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent = currentParent.memoizedProps;\n                if (null !== currentParent) {\n                    var context = parent.type;\n                    objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [\n                        context\n                    ]);\n                }\n            } else if (parent === hostTransitionProviderCursor.current) {\n                currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [\n                    HostTransitionContext\n                ]);\n            }\n            parent = parent.return;\n        }\n        null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);\n        workInProgress.flags |= 262144;\n    }\n    function checkIfContextChanged(currentDependencies) {\n        for(currentDependencies = currentDependencies.firstContext; null !== currentDependencies;){\n            var context = currentDependencies.context;\n            if (!objectIs(isPrimaryRenderer ? context._currentValue : context._currentValue2, currentDependencies.memoizedValue)) return !0;\n            currentDependencies = currentDependencies.next;\n        }\n        return !1;\n    }\n    function prepareToReadContext(workInProgress) {\n        currentlyRenderingFiber = workInProgress;\n        lastContextDependency = null;\n        workInProgress = workInProgress.dependencies;\n        null !== workInProgress && (workInProgress.firstContext = null);\n    }\n    function readContext(context) {\n        isDisallowedContextReadInDEV && console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n        return readContextForConsumer(currentlyRenderingFiber, context);\n    }\n    function readContextDuringReconciliation(consumer, context) {\n        null === currentlyRenderingFiber && prepareToReadContext(consumer);\n        return readContextForConsumer(consumer, context);\n    }\n    function readContextForConsumer(consumer, context) {\n        var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n        context = {\n            context: context,\n            memoizedValue: value,\n            next: null\n        };\n        if (null === lastContextDependency) {\n            if (null === consumer) throw Error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n            lastContextDependency = context;\n            consumer.dependencies = {\n                lanes: 0,\n                firstContext: context,\n                _debugThenableState: null\n            };\n            consumer.flags |= 524288;\n        } else lastContextDependency = lastContextDependency.next = context;\n        return value;\n    }\n    function createCache() {\n        return {\n            controller: new AbortControllerLocal(),\n            data: new Map(),\n            refCount: 0\n        };\n    }\n    function retainCache(cache) {\n        cache.controller.signal.aborted && console.warn(\"A cache instance was retained after it was already freed. This likely indicates a bug in React.\");\n        cache.refCount++;\n    }\n    function releaseCache(cache) {\n        cache.refCount--;\n        0 > cache.refCount && console.warn(\"A cache instance was released after it was already freed. This likely indicates a bug in React.\");\n        0 === cache.refCount && scheduleCallback$1(NormalPriority, function() {\n            cache.controller.abort();\n        });\n    }\n    function peekCacheFromPool() {\n        var cacheResumedFromPreviousRender = resumedCache.current;\n        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;\n    }\n    function pushTransition(offscreenWorkInProgress, prevCachePool) {\n        null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\n    }\n    function getSuspendedCache() {\n        var cacheFromPool = peekCacheFromPool();\n        return null === cacheFromPool ? null : {\n            parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n            pool: cacheFromPool\n        };\n    }\n    function markUpdate(workInProgress) {\n        workInProgress.flags |= 4;\n    }\n    function doesRequireClone(current, completedWork) {\n        if (null !== current && current.child === completedWork.child) return !1;\n        if (0 !== (completedWork.flags & 16)) return !0;\n        for(current = completedWork.child; null !== current;){\n            if (0 !== (current.flags & 13878) || 0 !== (current.subtreeFlags & 13878)) return !0;\n            current = current.sibling;\n        }\n        return !1;\n    }\n    function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {\n        if (supportsMutation) for(needsVisibilityToggle = workInProgress.child; null !== needsVisibilityToggle;){\n            if (5 === needsVisibilityToggle.tag || 6 === needsVisibilityToggle.tag) appendInitialChild(parent, needsVisibilityToggle.stateNode);\n            else if (!(4 === needsVisibilityToggle.tag || supportsSingletons && 27 === needsVisibilityToggle.tag) && null !== needsVisibilityToggle.child) {\n                needsVisibilityToggle.child.return = needsVisibilityToggle;\n                needsVisibilityToggle = needsVisibilityToggle.child;\n                continue;\n            }\n            if (needsVisibilityToggle === workInProgress) break;\n            for(; null === needsVisibilityToggle.sibling;){\n                if (null === needsVisibilityToggle.return || needsVisibilityToggle.return === workInProgress) return;\n                needsVisibilityToggle = needsVisibilityToggle.return;\n            }\n            needsVisibilityToggle.sibling.return = needsVisibilityToggle.return;\n            needsVisibilityToggle = needsVisibilityToggle.sibling;\n        }\n        else if (supportsPersistence) for(var _node = workInProgress.child; null !== _node;){\n            if (5 === _node.tag) {\n                var instance = _node.stateNode;\n                needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, _node.type, _node.memoizedProps));\n                appendInitialChild(parent, instance);\n            } else if (6 === _node.tag) instance = _node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, _node.memoizedProps)), appendInitialChild(parent, instance);\n            else if (4 !== _node.tag) {\n                if (22 === _node.tag && null !== _node.memoizedState) instance = _node.child, null !== instance && (instance.return = _node), appendAllChildren(parent, _node, !0, !0);\n                else if (null !== _node.child) {\n                    _node.child.return = _node;\n                    _node = _node.child;\n                    continue;\n                }\n            }\n            if (_node === workInProgress) break;\n            for(; null === _node.sibling;){\n                if (null === _node.return || _node.return === workInProgress) return;\n                _node = _node.return;\n            }\n            _node.sibling.return = _node.return;\n            _node = _node.sibling;\n        }\n    }\n    function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n        if (supportsPersistence) for(var node = workInProgress.child; null !== node;){\n            if (5 === node.tag) {\n                var instance = node.stateNode;\n                needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, node.type, node.memoizedProps));\n                appendChildToContainerChildSet(containerChildSet, instance);\n            } else if (6 === node.tag) instance = node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, node.memoizedProps)), appendChildToContainerChildSet(containerChildSet, instance);\n            else if (4 !== node.tag) {\n                if (22 === node.tag && null !== node.memoizedState) instance = node.child, null !== instance && (instance.return = node), appendAllChildrenToContainer(containerChildSet, node, !(null !== node.memoizedProps && \"manual\" === node.memoizedProps.mode), !0);\n                else if (null !== node.child) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n            }\n            if (node === workInProgress) break;\n            for(; null === node.sibling;){\n                if (null === node.return || node.return === workInProgress) return;\n                node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n        }\n    }\n    function updateHostContainer(current, workInProgress) {\n        if (supportsPersistence && doesRequireClone(current, workInProgress)) {\n            current = workInProgress.stateNode;\n            var container = current.containerInfo, newChildSet = createContainerChildSet();\n            appendAllChildrenToContainer(newChildSet, workInProgress, !1, !1);\n            current.pendingChildren = newChildSet;\n            markUpdate(workInProgress);\n            finalizeContainerChildren(container, newChildSet);\n        }\n    }\n    function updateHostComponent(current, workInProgress, type, newProps) {\n        if (supportsMutation) current.memoizedProps !== newProps && markUpdate(workInProgress);\n        else if (supportsPersistence) {\n            var currentInstance = current.stateNode, _oldProps = current.memoizedProps;\n            if ((current = doesRequireClone(current, workInProgress)) || _oldProps !== newProps) {\n                var currentHostContext = getHostContext();\n                _oldProps = cloneInstance(currentInstance, type, _oldProps, newProps, !current, null);\n                _oldProps === currentInstance ? workInProgress.stateNode = currentInstance : (finalizeInitialChildren(_oldProps, type, newProps, currentHostContext) && markUpdate(workInProgress), workInProgress.stateNode = _oldProps, current ? appendAllChildren(_oldProps, workInProgress, !1, !1) : markUpdate(workInProgress));\n            } else workInProgress.stateNode = currentInstance;\n        }\n    }\n    function preloadInstanceAndSuspendIfNeeded(workInProgress, type, props) {\n        if (maySuspendCommit(type, props)) {\n            if (workInProgress.flags |= 16777216, !preloadInstance(type, props)) if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n            else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n        } else workInProgress.flags &= -16777217;\n    }\n    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {\n        if (mayResourceSuspendCommit(resource)) {\n            if (workInProgress.flags |= 16777216, !preloadResource(resource)) if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n            else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n        } else workInProgress.flags &= -16777217;\n    }\n    function scheduleRetryEffect(workInProgress, retryQueue) {\n        null !== retryQueue && (workInProgress.flags |= 4);\n        workInProgress.flags & 16384 && (retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);\n    }\n    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n        if (!isHydrating) switch(renderState.tailMode){\n            case \"hidden\":\n                hasRenderedATailFallback = renderState.tail;\n                for(var lastTailNode = null; null !== hasRenderedATailFallback;)null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;\n                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;\n                break;\n            case \"collapsed\":\n                lastTailNode = renderState.tail;\n                for(var _lastTailNode = null; null !== lastTailNode;)null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;\n                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;\n        }\n    }\n    function bubbleProperties(completedWork) {\n        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;\n        if (didBailout) if ((completedWork.mode & 2) !== NoMode) {\n            for(var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2;)newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 31457280, subtreeFlags |= _child2.flags & 31457280, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;\n            completedWork.treeBaseDuration = _treeBaseDuration;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 31457280, subtreeFlags |= _treeBaseDuration.flags & 31457280, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        else if ((completedWork.mode & 2) !== NoMode) {\n            _treeBaseDuration = completedWork.actualDuration;\n            _child2 = completedWork.selfBaseDuration;\n            for(var child = completedWork.child; null !== child;)newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;\n            completedWork.actualDuration = _treeBaseDuration;\n            completedWork.treeBaseDuration = _child2;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        completedWork.subtreeFlags |= subtreeFlags;\n        completedWork.childLanes = newChildLanes;\n        return didBailout;\n    }\n    function completeWork(current, workInProgress, renderLanes) {\n        var newProps = workInProgress.pendingProps;\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 16:\n            case 15:\n            case 0:\n            case 11:\n            case 7:\n            case 8:\n            case 12:\n            case 9:\n            case 14:\n                return bubbleProperties(workInProgress), null;\n            case 1:\n                return bubbleProperties(workInProgress), null;\n            case 3:\n                renderLanes = workInProgress.stateNode;\n                newProps = null;\n                null !== current && (newProps = current.memoizedState.cache);\n                workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048);\n                popProvider(CacheContext, workInProgress);\n                popHostContainer(workInProgress);\n                renderLanes.pendingContext && (renderLanes.context = renderLanes.pendingContext, renderLanes.pendingContext = null);\n                if (null === current || null === current.child) popHydrationState(workInProgress) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress)) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256) || (workInProgress.flags |= 1024, null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null));\n                updateHostContainer(current, workInProgress);\n                bubbleProperties(workInProgress);\n                return null;\n            case 26:\n                if (supportsResources) {\n                    renderLanes = workInProgress.type;\n                    var nextResource = workInProgress.memoizedState;\n                    null === current ? (markUpdate(workInProgress), null !== nextResource ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, renderLanes, newProps))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress) : updateHostComponent(current, workInProgress, renderLanes, newProps), bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, renderLanes, newProps));\n                    return null;\n                }\n            case 27:\n                if (supportsSingletons) {\n                    popHostContext(workInProgress);\n                    renderLanes = requiredContext(rootInstanceStackCursor.current);\n                    nextResource = workInProgress.type;\n                    if (null !== current && null != workInProgress.stateNode) supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress) : updateHostComponent(current, workInProgress, nextResource, newProps);\n                    else {\n                        if (!newProps) {\n                            if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                            bubbleProperties(workInProgress);\n                            return null;\n                        }\n                        current = getHostContext();\n                        popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (current = resolveSingletonInstance(nextResource, newProps, renderLanes, current, !0), workInProgress.stateNode = current, markUpdate(workInProgress));\n                    }\n                    bubbleProperties(workInProgress);\n                    return null;\n                }\n            case 5:\n                popHostContext(workInProgress);\n                renderLanes = workInProgress.type;\n                if (null !== current && null != workInProgress.stateNode) updateHostComponent(current, workInProgress, renderLanes, newProps);\n                else {\n                    if (!newProps) {\n                        if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                    current = getHostContext();\n                    popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (nextResource = requiredContext(rootInstanceStackCursor.current), nextResource = createInstance(renderLanes, newProps, nextResource, current, workInProgress), appendAllChildren(nextResource, workInProgress, !1, !1), workInProgress.stateNode = nextResource, finalizeInitialChildren(nextResource, renderLanes, newProps, current) && markUpdate(workInProgress));\n                }\n                bubbleProperties(workInProgress);\n                preloadInstanceAndSuspendIfNeeded(workInProgress, workInProgress.type, workInProgress.pendingProps);\n                return null;\n            case 6:\n                if (current && null != workInProgress.stateNode) renderLanes = current.memoizedProps, supportsMutation ? renderLanes !== newProps && markUpdate(workInProgress) : supportsPersistence && (renderLanes !== newProps ? (current = requiredContext(rootInstanceStackCursor.current), renderLanes = getHostContext(), workInProgress.stateNode = createTextInstance(newProps, current, renderLanes, workInProgress), markUpdate(workInProgress)) : workInProgress.stateNode = current.stateNode);\n                else {\n                    if (\"string\" !== typeof newProps && null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                    current = requiredContext(rootInstanceStackCursor.current);\n                    renderLanes = getHostContext();\n                    if (popHydrationState(workInProgress)) {\n                        if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n                        current = workInProgress.stateNode;\n                        renderLanes = workInProgress.memoizedProps;\n                        nextResource = !didSuspendOrErrorDEV;\n                        newProps = null;\n                        var returnFiber = hydrationParentFiber;\n                        if (null !== returnFiber) switch(returnFiber.tag){\n                            case 3:\n                                nextResource && (nextResource = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== nextResource && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextResource));\n                                break;\n                            case 27:\n                            case 5:\n                                newProps = returnFiber.memoizedProps, nextResource && (nextResource = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== nextResource && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextResource));\n                        }\n                        hydrateTextInstance(current, renderLanes, workInProgress, newProps) || throwOnHydrationMismatch(workInProgress);\n                    } else workInProgress.stateNode = createTextInstance(newProps, current, renderLanes, workInProgress);\n                }\n                bubbleProperties(workInProgress);\n                return null;\n            case 13:\n                newProps = workInProgress.memoizedState;\n                if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {\n                    nextResource = popHydrationState(workInProgress);\n                    if (null !== newProps && null !== newProps.dehydrated) {\n                        if (null === current) {\n                            if (!nextResource) throw Error(\"A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.\");\n                            if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n                            nextResource = workInProgress.memoizedState;\n                            nextResource = null !== nextResource ? nextResource.dehydrated : null;\n                            if (!nextResource) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n                            hydrateSuspenseInstance(nextResource, workInProgress);\n                            bubbleProperties(workInProgress);\n                            (workInProgress.mode & 2) !== NoMode && null !== newProps && (nextResource = workInProgress.child, null !== nextResource && (workInProgress.treeBaseDuration -= nextResource.treeBaseDuration));\n                        } else emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), workInProgress.flags |= 4, bubbleProperties(workInProgress), (workInProgress.mode & 2) !== NoMode && null !== newProps && (nextResource = workInProgress.child, null !== nextResource && (workInProgress.treeBaseDuration -= nextResource.treeBaseDuration));\n                        nextResource = !1;\n                    } else null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null), nextResource = !0;\n                    if (!nextResource) {\n                        if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;\n                        popSuspenseHandler(workInProgress);\n                        return null;\n                    }\n                }\n                popSuspenseHandler(workInProgress);\n                if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress;\n                renderLanes = null !== newProps;\n                current = null !== current && null !== current.memoizedState;\n                renderLanes && (newProps = workInProgress.child, nextResource = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (nextResource = newProps.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (returnFiber = newProps.memoizedState.cachePool.pool), returnFiber !== nextResource && (newProps.flags |= 2048));\n                renderLanes !== current && renderLanes && (workInProgress.child.flags |= 8192);\n                scheduleRetryEffect(workInProgress, workInProgress.updateQueue);\n                bubbleProperties(workInProgress);\n                (workInProgress.mode & 2) !== NoMode && renderLanes && (current = workInProgress.child, null !== current && (workInProgress.treeBaseDuration -= current.treeBaseDuration));\n                return null;\n            case 4:\n                return popHostContainer(workInProgress), updateHostContainer(current, workInProgress), null === current && preparePortalMount(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), bubbleProperties(workInProgress), null;\n            case 19:\n                pop(suspenseStackCursor, workInProgress);\n                nextResource = workInProgress.memoizedState;\n                if (null === nextResource) return bubbleProperties(workInProgress), null;\n                newProps = 0 !== (workInProgress.flags & 128);\n                returnFiber = nextResource.rendering;\n                if (null === returnFiber) if (newProps) cutOffTailIfNeeded(nextResource, !1);\n                else {\n                    if (workInProgressRootExitStatus !== RootInProgress || null !== current && 0 !== (current.flags & 128)) for(current = workInProgress.child; null !== current;){\n                        returnFiber = findFirstSuspended(current);\n                        if (null !== returnFiber) {\n                            workInProgress.flags |= 128;\n                            cutOffTailIfNeeded(nextResource, !1);\n                            current = returnFiber.updateQueue;\n                            workInProgress.updateQueue = current;\n                            scheduleRetryEffect(workInProgress, current);\n                            workInProgress.subtreeFlags = 0;\n                            current = renderLanes;\n                            for(renderLanes = workInProgress.child; null !== renderLanes;)resetWorkInProgress(renderLanes, current), renderLanes = renderLanes.sibling;\n                            push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress);\n                            return workInProgress.child;\n                        }\n                        current = current.sibling;\n                    }\n                    null !== nextResource.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(nextResource, !1), workInProgress.lanes = 4194304);\n                }\n                else {\n                    if (!newProps) if (current = findFirstSuspended(returnFiber), null !== current) {\n                        if (workInProgress.flags |= 128, newProps = !0, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(nextResource, !0), null === nextResource.tail && \"hidden\" === nextResource.tailMode && !returnFiber.alternate && !isHydrating) return bubbleProperties(workInProgress), null;\n                    } else 2 * now$1() - nextResource.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(nextResource, !1), workInProgress.lanes = 4194304);\n                    nextResource.isBackwards ? (returnFiber.sibling = workInProgress.child, workInProgress.child = returnFiber) : (current = nextResource.last, null !== current ? current.sibling = returnFiber : workInProgress.child = returnFiber, nextResource.last = returnFiber);\n                }\n                if (null !== nextResource.tail) return current = nextResource.tail, nextResource.rendering = current, nextResource.tail = current.sibling, nextResource.renderingStartTime = now$1(), current.sibling = null, renderLanes = suspenseStackCursor.current, renderLanes = newProps ? renderLanes & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes, workInProgress), current;\n                bubbleProperties(workInProgress);\n                return null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), newProps = null !== workInProgress.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), renderLanes = workInProgress.updateQueue, null !== renderLanes && scheduleRetryEffect(workInProgress, renderLanes.retryQueue), renderLanes = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (newProps = workInProgress.memoizedState.cachePool.pool), newProps !== renderLanes && (workInProgress.flags |= 2048), null !== current && pop(resumedCache, workInProgress), null;\n            case 24:\n                return renderLanes = null, null !== current && (renderLanes = current.memoizedState.cache), workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048), popProvider(CacheContext, workInProgress), bubbleProperties(workInProgress), null;\n            case 25:\n                return null;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function unwindWork(current, workInProgress) {\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 1:\n                return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 3:\n                return popProvider(CacheContext, workInProgress), popHostContainer(workInProgress), current = workInProgress.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;\n            case 26:\n            case 27:\n            case 5:\n                return popHostContext(workInProgress), null;\n            case 13:\n                popSuspenseHandler(workInProgress);\n                current = workInProgress.memoizedState;\n                if (null !== current && null !== current.dehydrated) {\n                    if (null === workInProgress.alternate) throw Error(\"Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.\");\n                    resetHydrationState();\n                }\n                current = workInProgress.flags;\n                return current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 19:\n                return pop(suspenseStackCursor, workInProgress), null;\n            case 4:\n                return popHostContainer(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), null !== current && pop(resumedCache, workInProgress), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 24:\n                return popProvider(CacheContext, workInProgress), null;\n            case 25:\n                return null;\n            default:\n                return null;\n        }\n    }\n    function unwindInterruptedWork(current, interruptedWork) {\n        popTreeContext(interruptedWork);\n        switch(interruptedWork.tag){\n            case 3:\n                popProvider(CacheContext, interruptedWork);\n                popHostContainer(interruptedWork);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                popHostContext(interruptedWork);\n                break;\n            case 4:\n                popHostContainer(interruptedWork);\n                break;\n            case 13:\n                popSuspenseHandler(interruptedWork);\n                break;\n            case 19:\n                pop(suspenseStackCursor, interruptedWork);\n                break;\n            case 10:\n                popProvider(interruptedWork.type, interruptedWork);\n                break;\n            case 22:\n            case 23:\n                popSuspenseHandler(interruptedWork);\n                popHiddenContext(interruptedWork);\n                null !== current && pop(resumedCache, interruptedWork);\n                break;\n            case 24:\n                popProvider(CacheContext, interruptedWork);\n        }\n    }\n    function shouldProfile(current) {\n        return (current.mode & 2) !== NoMode;\n    }\n    function commitHookLayoutEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitHookEffectListMount(flags, finishedWork) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(finishedWork), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && \"function\" !== typeof lastEffect)) {\n                        var hookName = void 0;\n                        hookName = 0 !== (updateQueue.tag & Layout) ? \"useLayoutEffect\" : 0 !== (updateQueue.tag & Insertion) ? \"useInsertionEffect\" : \"useEffect\";\n                        var addendum = void 0;\n                        addendum = null === lastEffect ? \" You returned null. If your effect does not require clean up, return undefined (or nothing).\" : \"function\" === typeof lastEffect.then ? \"\\n\\nIt looks like you wrote \" + hookName + \"(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\\n\\n\" + hookName + \"(() => {\\n  async function fetchData() {\\n    // You can await here\\n    const response = await MyAPI.getData(someId);\\n    // ...\\n  }\\n  fetchData();\\n}, [someId]); // Or [] if effect doesn't need props or state\\n\\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching\" : \" You returned: \" + lastEffect;\n                        runWithFiberInDEV(finishedWork, function(n, a) {\n                            console.error(\"%s must not return anything besides a function, which is used for clean-up.%s\", n, a);\n                        }, hookName, addendum);\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags) {\n                        var inst = updateQueue.inst, destroy = inst.destroy;\n                        void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(finishedWork), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), runWithFiberInDEV(finishedWork, callDestroyInDEV, finishedWork, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookPassiveMountEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitClassCallbacks(finishedWork) {\n        var updateQueue = finishedWork.updateQueue;\n        if (null !== updateQueue) {\n            var instance = finishedWork.stateNode;\n            finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), instance.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n            try {\n                runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }\n    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {\n        return instance.getSnapshotBeforeUpdate(prevProps, prevState);\n    }\n    function commitClassSnapshot(finishedWork, current) {\n        var prevProps = current.memoizedProps, prevState = current.memoizedState;\n        current = finishedWork.stateNode;\n        finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), current.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n        try {\n            var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps, finishedWork.elementType === finishedWork.type);\n            var snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current, resolvedPrevProps, prevState);\n            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;\n            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {\n                console.error(\"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.\", getComponentNameFromFiber(finishedWork));\n            }));\n            current.__reactInternalSnapshotBeforeUpdate = snapshot;\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n        instance.props = resolveClassComponentProps(current.type, current.memoizedProps);\n        instance.state = current.memoizedState;\n        shouldProfile(current) ? (startEffectTimer(), runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance);\n    }\n    function commitAttachRef(finishedWork) {\n        var ref = finishedWork.ref;\n        if (null !== ref) {\n            var instance = finishedWork.stateNode;\n            switch(finishedWork.tag){\n                case 26:\n                case 27:\n                case 5:\n                    instance = getPublicInstance(instance);\n            }\n            if (\"function\" === typeof ref) if (shouldProfile(finishedWork)) try {\n                startEffectTimer(), finishedWork.refCleanup = ref(instance);\n            } finally{\n                recordEffectDuration();\n            }\n            else finishedWork.refCleanup = ref(instance);\n            else \"string\" === typeof ref ? console.error(\"String refs are no longer supported.\") : ref.hasOwnProperty(\"current\") || console.error(\"Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().\", getComponentNameFromFiber(finishedWork)), ref.current = instance;\n        }\n    }\n    function safelyAttachRef(current, nearestMountedAncestor) {\n        try {\n            runWithFiberInDEV(current, commitAttachRef, current);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        }\n    }\n    function safelyDetachRef(current, nearestMountedAncestor) {\n        var ref = current.ref, refCleanup = current.refCleanup;\n        if (null !== ref) if (\"function\" === typeof refCleanup) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, refCleanup);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, refCleanup);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        } finally{\n            current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);\n        }\n        else if (\"function\" === typeof ref) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, ref, null);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, ref, null);\n        } catch (error$3) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error$3);\n        }\n        else ref.current = null;\n    }\n    function commitProfiler(finishedWork, current, commitStartTime, effectDuration) {\n        var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;\n        _finishedWork$memoize = _finishedWork$memoize.onRender;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize && _finishedWork$memoize(id, current, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime);\n        \"function\" === typeof onCommit && onCommit(finishedWork.memoizedProps.id, current, effectDuration, commitStartTime);\n    }\n    function commitProfilerPostCommitImpl(finishedWork, current, commitStartTime, passiveEffectDuration) {\n        var _finishedWork$memoize2 = finishedWork.memoizedProps;\n        finishedWork = _finishedWork$memoize2.id;\n        _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(finishedWork, current, passiveEffectDuration, commitStartTime);\n    }\n    function commitHostMount(finishedWork) {\n        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;\n        try {\n            runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHostUpdate(finishedWork, newProps, oldProps) {\n        try {\n            runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function isHostParent(fiber) {\n        return 5 === fiber.tag || 3 === fiber.tag || (supportsResources ? 26 === fiber.tag : !1) || (supportsSingletons ? 27 === fiber.tag : !1) || 4 === fiber.tag;\n    }\n    function getHostSibling(fiber) {\n        a: for(;;){\n            for(; null === fiber.sibling;){\n                if (null === fiber.return || isHostParent(fiber.return)) return null;\n                fiber = fiber.return;\n            }\n            fiber.sibling.return = fiber.return;\n            for(fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && (supportsSingletons ? 27 !== fiber.tag : 1) && 18 !== fiber.tag;){\n                if (fiber.flags & 2) continue a;\n                if (null === fiber.child || 4 === fiber.tag) continue a;\n                else fiber.child.return = fiber, fiber = fiber.child;\n            }\n            if (!(fiber.flags & 2)) return fiber.stateNode;\n        }\n    }\n    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? insertInContainerBefore(parent, node, before) : appendChildToContainer(parent, node);\n        else if (!(4 === tag || supportsSingletons && 27 === tag) && (node = node.child, null !== node)) for(insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;\n    }\n    function insertOrAppendPlacementNode(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? insertBefore(parent, node, before) : appendChild(parent, node);\n        else if (!(4 === tag || supportsSingletons && 27 === tag) && (node = node.child, null !== node)) for(insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNode(node, before, parent), node = node.sibling;\n    }\n    function commitPlacement(finishedWork) {\n        if (supportsMutation && (!supportsSingletons || 27 !== finishedWork.tag)) {\n            a: {\n                for(var parent = finishedWork.return; null !== parent;){\n                    if (isHostParent(parent)) {\n                        var parentFiber = parent;\n                        break a;\n                    }\n                    parent = parent.return;\n                }\n                throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            switch(parentFiber.tag){\n                case 27:\n                    if (supportsSingletons) {\n                        parent = parentFiber.stateNode;\n                        parentFiber = getHostSibling(finishedWork);\n                        insertOrAppendPlacementNode(finishedWork, parentFiber, parent);\n                        break;\n                    }\n                case 5:\n                    parent = parentFiber.stateNode;\n                    parentFiber.flags & 32 && (resetTextContent(parent), parentFiber.flags &= -33);\n                    parentFiber = getHostSibling(finishedWork);\n                    insertOrAppendPlacementNode(finishedWork, parentFiber, parent);\n                    break;\n                case 3:\n                case 4:\n                    parent = parentFiber.stateNode.containerInfo;\n                    parentFiber = getHostSibling(finishedWork);\n                    insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, parent);\n                    break;\n                default:\n                    throw Error(\"Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n        }\n    }\n    function commitHostPortalContainerChildren(portal, finishedWork, pendingChildren) {\n        portal = portal.containerInfo;\n        try {\n            runWithFiberInDEV(finishedWork, replaceContainerChildren, portal, pendingChildren);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitBeforeMutationEffects(root, firstChild) {\n        prepareForCommit(root.containerInfo);\n        for(nextEffect = firstChild; null !== nextEffect;)if (root = nextEffect, firstChild = root.child, 0 !== (root.subtreeFlags & 1028) && null !== firstChild) firstChild.return = root, nextEffect = firstChild;\n        else for(; null !== nextEffect;){\n            firstChild = root = nextEffect;\n            var current = firstChild.alternate, flags = firstChild.flags;\n            switch(firstChild.tag){\n                case 0:\n                    break;\n                case 11:\n                case 15:\n                    break;\n                case 1:\n                    0 !== (flags & 1024) && null !== current && commitClassSnapshot(firstChild, current);\n                    break;\n                case 3:\n                    0 !== (flags & 1024) && supportsMutation && clearContainer(firstChild.stateNode.containerInfo);\n                    break;\n                case 5:\n                case 26:\n                case 27:\n                case 6:\n                case 4:\n                case 17:\n                    break;\n                default:\n                    if (0 !== (flags & 1024)) throw Error(\"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            firstChild = root.sibling;\n            if (null !== firstChild) {\n                firstChild.return = root.return;\n                nextEffect = firstChild;\n                break;\n            }\n            nextEffect = root.return;\n        }\n        root = shouldFireAfterActiveInstanceBlur;\n        shouldFireAfterActiveInstanceBlur = !1;\n        return root;\n    }\n    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);\n                break;\n            case 1:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);\n                else {\n                    var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);\n                    current = current.memoizedState;\n                    finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n                    shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);\n                }\n                flags & 64 && commitClassCallbacks(finishedWork);\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 3:\n                current = pushNestedEffectDurations();\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {\n                    prevProps = null;\n                    if (null !== finishedWork.child) switch(finishedWork.child.tag){\n                        case 27:\n                        case 5:\n                            prevProps = getPublicInstance(finishedWork.child.stateNode);\n                            break;\n                        case 1:\n                            prevProps = finishedWork.child.stateNode;\n                    }\n                    try {\n                        runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                finishedRoot.effectDuration += popNestedEffectDurations(current);\n                break;\n            case 26:\n                if (supportsResources) {\n                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                    break;\n                }\n            case 27:\n            case 5:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                null === current && flags & 4 && commitHostMount(finishedWork);\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, finishedRoot.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                break;\n            case 13:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 22:\n                prevProps = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;\n                if (!prevProps) {\n                    current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;\n                    var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                    offscreenSubtreeIsHidden = prevProps;\n                    (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                    offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                }\n                flags & 512 && (\"manual\" === finishedWork.memoizedProps.mode ? safelyAttachRef(finishedWork, finishedWork.return) : safelyDetachRef(finishedWork, finishedWork.return));\n                break;\n            default:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n        }\n    }\n    function detachFiberAfterEffects(fiber) {\n        var alternate = fiber.alternate;\n        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));\n        fiber.child = null;\n        fiber.deletions = null;\n        fiber.sibling = null;\n        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));\n        fiber.stateNode = null;\n        fiber._debugOwner = null;\n        fiber.return = null;\n        fiber.dependencies = null;\n        fiber.memoizedProps = null;\n        fiber.memoizedState = null;\n        fiber.pendingProps = null;\n        fiber.stateNode = null;\n        fiber.updateQueue = null;\n    }\n    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n        for(parent = parent.child; null !== parent;)commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;\n    }\n    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n        if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberUnmount) try {\n            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n        switch(deletedFiber.tag){\n            case 26:\n                if (supportsResources) {\n                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                    deletedFiber.memoizedState ? releaseResource(deletedFiber.memoizedState) : deletedFiber.stateNode && unmountHoistable(deletedFiber.stateNode);\n                    break;\n                }\n            case 27:\n                if (supportsSingletons) {\n                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                    var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;\n                    hostParent = deletedFiber.stateNode;\n                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                    releaseSingletonInstance(deletedFiber.stateNode);\n                    hostParent = prevHostParent;\n                    hostParentIsContainer = prevHostParentIsContainer;\n                    break;\n                }\n            case 5:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n            case 6:\n                if (supportsMutation) {\n                    if (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = null, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer, null !== hostParent) if (hostParentIsContainer) try {\n                        runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);\n                    } catch (error) {\n                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                    }\n                    else try {\n                        runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);\n                    } catch (error) {\n                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                    }\n                } else recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 18:\n                supportsMutation && null !== hostParent && (hostParentIsContainer ? clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));\n                break;\n            case 4:\n                supportsMutation ? (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = deletedFiber.stateNode.containerInfo, hostParentIsContainer = !0, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer) : (supportsPersistence && commitHostPortalContainerChildren(deletedFiber.stateNode, deletedFiber, createContainerChildSet()), recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber));\n                break;\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                offscreenSubtreeWasHidden || commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);\n                offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 1:\n                offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, \"function\" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 21:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 22:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                offscreenSubtreeWasHidden = prevHostParent;\n                break;\n            default:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n    }\n    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n        if (supportsHydration && null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {\n            runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function getRetryCache(finishedWork) {\n        switch(finishedWork.tag){\n            case 13:\n            case 19:\n                var retryCache = finishedWork.stateNode;\n                null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());\n                return retryCache;\n            case 22:\n                return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;\n            default:\n                throw Error(\"Unexpected Suspense handler tag (\" + finishedWork.tag + \"). This is a bug in React.\");\n        }\n    }\n    function attachSuspenseRetryListeners(finishedWork, wakeables) {\n        var retryCache = getRetryCache(finishedWork);\n        wakeables.forEach(function(wakeable) {\n            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n            if (!retryCache.has(wakeable)) {\n                retryCache.add(wakeable);\n                if (isDevToolsPresent) if (null !== inProgressLanes && null !== inProgressRoot) restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                else throw Error(\"Expected finished root and lanes to be set. This is a bug in React.\");\n                wakeable.then(retry, retry);\n            }\n        });\n    }\n    function commitMutationEffects(root, finishedWork, committedLanes) {\n        inProgressLanes = committedLanes;\n        inProgressRoot = root;\n        commitMutationEffectsOnFiber(finishedWork, root);\n        inProgressRoot = inProgressLanes = null;\n    }\n    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n            var root = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i];\n            if (supportsMutation) {\n                var parent = returnFiber;\n                a: for(; null !== parent;){\n                    switch(parent.tag){\n                        case 27:\n                        case 5:\n                            hostParent = parent.stateNode;\n                            hostParentIsContainer = !1;\n                            break a;\n                        case 3:\n                            hostParent = parent.stateNode.containerInfo;\n                            hostParentIsContainer = !0;\n                            break a;\n                        case 4:\n                            hostParent = parent.stateNode.containerInfo;\n                            hostParentIsContainer = !0;\n                            break a;\n                    }\n                    parent = parent.return;\n                }\n                if (null === hostParent) throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n                hostParent = null;\n                hostParentIsContainer = !1;\n            } else commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n            root = deletedFiber;\n            returnFiber = root.alternate;\n            null !== returnFiber && (returnFiber.return = null);\n            root.return = null;\n        }\n        if (parentFiber.subtreeFlags & 13878) for(parentFiber = parentFiber.child; null !== parentFiber;)commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;\n    }\n    function commitMutationEffectsOnFiber(finishedWork, root) {\n        var current = finishedWork.alternate, flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));\n                break;\n            case 1:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));\n                break;\n            case 26:\n                if (supportsResources) {\n                    var hoistableRoot = currentHoistableRoot;\n                    recursivelyTraverseMutationEffects(root, finishedWork);\n                    commitReconciliationEffects(finishedWork);\n                    flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                    flags & 4 && (flags = null !== current ? current.memoizedState : null, root = finishedWork.memoizedState, null === current ? null === root ? null === finishedWork.stateNode ? finishedWork.stateNode = hydrateHoistable(hoistableRoot, finishedWork.type, finishedWork.memoizedProps, finishedWork) : mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : finishedWork.stateNode = acquireResource(hoistableRoot, root, finishedWork.memoizedProps) : flags !== root ? (null === flags ? null !== current.stateNode && unmountHoistable(current.stateNode) : releaseResource(flags), null === root ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, root, finishedWork.memoizedProps)) : null === root && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps));\n                    break;\n                }\n            case 27:\n                if (supportsSingletons && flags & 4 && null === finishedWork.alternate) {\n                    hoistableRoot = finishedWork.stateNode;\n                    var props = finishedWork.memoizedProps;\n                    try {\n                        clearSingleton(hoistableRoot), runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, props, hoistableRoot, finishedWork);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n            case 5:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                if (supportsMutation) {\n                    if (finishedWork.flags & 32) {\n                        root = finishedWork.stateNode;\n                        try {\n                            runWithFiberInDEV(finishedWork, resetTextContent, root);\n                        } catch (error) {\n                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                        }\n                    }\n                    flags & 4 && null != finishedWork.stateNode && (root = finishedWork.memoizedProps, commitHostUpdate(finishedWork, root, null !== current ? current.memoizedProps : root));\n                    flags & 1024 && (needsFormReset = !0, \"form\" !== finishedWork.type && console.error(\"Unexpected host component type. Expected a form. This is a bug in React.\"));\n                }\n                break;\n            case 6:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4 && supportsMutation) {\n                    if (null === finishedWork.stateNode) throw Error(\"This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.\");\n                    flags = finishedWork.memoizedProps;\n                    current = null !== current ? current.memoizedProps : flags;\n                    root = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitTextUpdate, root, current, flags);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                break;\n            case 3:\n                hoistableRoot = pushNestedEffectDurations();\n                supportsResources ? (prepareToCommitHoistables(), props = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(root.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), currentHoistableRoot = props) : recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4) {\n                    if (supportsMutation && supportsHydration && null !== current && current.memoizedState.isDehydrated) try {\n                        runWithFiberInDEV(finishedWork, commitHydratedContainer, root.containerInfo);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                    if (supportsPersistence) {\n                        flags = root.containerInfo;\n                        current = root.pendingChildren;\n                        try {\n                            runWithFiberInDEV(finishedWork, replaceContainerChildren, flags, current);\n                        } catch (error) {\n                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                        }\n                    }\n                }\n                needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork));\n                root.effectDuration += popNestedEffectDurations(hoistableRoot);\n                break;\n            case 4:\n                supportsResources ? (current = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), currentHoistableRoot = current) : (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork));\n                flags & 4 && supportsPersistence && commitHostPortalContainerChildren(finishedWork.stateNode, finishedWork, finishedWork.stateNode.pendingChildren);\n                break;\n            case 12:\n                flags = pushNestedEffectDurations();\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);\n                break;\n            case 13:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now$1());\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 22:\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                hoistableRoot = null !== finishedWork.memoizedState;\n                var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                commitReconciliationEffects(finishedWork);\n                root = finishedWork.stateNode;\n                root._current = finishedWork;\n                root._visibility &= -3;\n                root._visibility |= root._pendingVisibility & 2;\n                if (flags & 8192 && (root._visibility = hoistableRoot ? root._visibility & -2 : root._visibility | 1, hoistableRoot && (root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden, null === current || wasHidden || root || recursivelyTraverseDisappearLayoutEffects(finishedWork)), supportsMutation && (null === finishedWork.memoizedProps || \"manual\" !== finishedWork.memoizedProps.mode))) {\n                    a: if (current = null, supportsMutation) for(root = finishedWork;;){\n                        if (5 === root.tag || supportsResources && 26 === root.tag || supportsSingletons && 27 === root.tag) {\n                            if (null === current) {\n                                wasHidden = current = root;\n                                try {\n                                    props = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, props) : runWithFiberInDEV(wasHidden, unhideInstance, wasHidden.stateNode, wasHidden.memoizedProps);\n                                } catch (error) {\n                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                                }\n                            }\n                        } else if (6 === root.tag) {\n                            if (null === current) {\n                                wasHidden = root;\n                                try {\n                                    var instance = wasHidden.stateNode;\n                                    hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, instance) : runWithFiberInDEV(wasHidden, unhideTextInstance, instance, wasHidden.memoizedProps);\n                                } catch (error) {\n                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                                }\n                            }\n                        } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {\n                            root.child.return = root;\n                            root = root.child;\n                            continue;\n                        }\n                        if (root === finishedWork) break a;\n                        for(; null === root.sibling;){\n                            if (null === root.return || root.return === finishedWork) break a;\n                            current === root && (current = null);\n                            root = root.return;\n                        }\n                        current === root && (current = null);\n                        root.sibling.return = root.return;\n                        root = root.sibling;\n                    }\n                }\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));\n                break;\n            case 19:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 21:\n                break;\n            default:\n                recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);\n        }\n    }\n    function commitReconciliationEffects(finishedWork) {\n        var flags = finishedWork.flags;\n        if (flags & 2) {\n            try {\n                runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n            finishedWork.flags &= -3;\n        }\n        flags & 4096 && (finishedWork.flags &= -4097);\n    }\n    function recursivelyResetForms(parentFiber) {\n        if (parentFiber.subtreeFlags & 1024) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var fiber = parentFiber;\n            recursivelyResetForms(fiber);\n            5 === fiber.tag && fiber.flags & 1024 && resetFormInstance(fiber.stateNode);\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function commitLayoutEffects(finishedWork, root, committedLanes) {\n        inProgressLanes = committedLanes;\n        inProgressRoot = root;\n        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);\n        inProgressRoot = inProgressLanes = null;\n    }\n    function recursivelyTraverseLayoutEffects(root, parentFiber) {\n        if (parentFiber.subtreeFlags & 8772) for(parentFiber = parentFiber.child; null !== parentFiber;)commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disappearLayoutEffects(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 1:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                var instance = finishedWork.stateNode;\n                \"function\" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 22:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        }\n    }\n    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function reappearLayoutEffects(finishedRoot, current, finishedWork, includeWorkInProgressEffects) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                commitHookLayoutEffects(finishedWork, Layout);\n                break;\n            case 1:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                current = finishedWork.stateNode;\n                \"function\" === typeof current.componentDidMount && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current);\n                current = finishedWork.updateQueue;\n                if (null !== current) {\n                    finishedRoot = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current, finishedRoot);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (includeWorkInProgressEffects && flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                    includeWorkInProgressEffects = finishedWork.stateNode;\n                    includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, includeWorkInProgressEffects.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                break;\n            case 13:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 22:\n                null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            default:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n        }\n    }\n    function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);\n        for(parentFiber = parentFiber.child; null !== parentFiber;)reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;\n    }\n    function commitOffscreenPassiveMountEffects(current, finishedWork) {\n        var previousCache = null;\n        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);\n        current = null;\n        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);\n        current !== previousCache && (null != current && retainCache(current), null != previousCache && releaseCache(previousCache));\n    }\n    function commitCachePassiveMountEffect(current, finishedWork) {\n        current = null;\n        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);\n        finishedWork = finishedWork.memoizedState.cache;\n        finishedWork !== current && (retainCache(finishedWork), null != current && releaseCache(current));\n    }\n    function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;\n    }\n    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);\n                break;\n            case 3:\n                var prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));\n                finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);\n                break;\n            case 12:\n                if (flags & 2048) {\n                    prevEffectDuration = pushNestedEffectDurations();\n                    recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                break;\n            case 23:\n                break;\n            case 22:\n                prevEffectDuration = finishedWork.stateNode;\n                null !== finishedWork.memoizedState ? prevEffectDuration._visibility & 4 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : prevEffectDuration._visibility & 4 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (prevEffectDuration._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256)));\n                flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                break;\n            case 24:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n        }\n    }\n    function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);\n        for(parentFiber = parentFiber.child; null !== parentFiber;)reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;\n    }\n    function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                commitHookPassiveMountEffects(finishedWork, Passive);\n                break;\n            case 23:\n                break;\n            case 22:\n                var _instance2 = finishedWork.stateNode;\n                null !== finishedWork.memoizedState ? _instance2._visibility & 4 ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (_instance2._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));\n                includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                break;\n            case 24:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n        }\n    }\n    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case 22:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                    flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                    break;\n                case 24:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                    flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                    break;\n                default:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n            }\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function recursivelyAccumulateSuspenseyCommit(parentFiber) {\n        if (parentFiber.subtreeFlags & suspenseyCommitFlag) for(parentFiber = parentFiber.child; null !== parentFiber;)accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function accumulateSuspenseyCommitOnFiber(fiber) {\n        switch(fiber.tag){\n            case 26:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n                fiber.flags & suspenseyCommitFlag && (null !== fiber.memoizedState ? suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps) : suspendInstance(fiber.type, fiber.memoizedProps));\n                break;\n            case 5:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n                fiber.flags & suspenseyCommitFlag && suspendInstance(fiber.type, fiber.memoizedProps);\n                break;\n            case 3:\n            case 4:\n                if (supportsResources) {\n                    var previousHoistableRoot = currentHoistableRoot;\n                    currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);\n                    recursivelyAccumulateSuspenseyCommit(fiber);\n                    currentHoistableRoot = previousHoistableRoot;\n                } else recursivelyAccumulateSuspenseyCommit(fiber);\n                break;\n            case 22:\n                null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));\n                break;\n            default:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n        }\n    }\n    function detachAlternateSiblings(parentFiber) {\n        var previousFiber = parentFiber.alternate;\n        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {\n            previousFiber.child = null;\n            do previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;\n            while (null !== parentFiber);\n        }\n    }\n    function recursivelyTraversePassiveUnmountEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i];\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function commitPassiveUnmountOnFiber(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);\n                break;\n            case 3:\n                var prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);\n                break;\n            case 12:\n                prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);\n                break;\n            case 22:\n                prevEffectDuration = finishedWork.stateNode;\n                null !== finishedWork.memoizedState && prevEffectDuration._visibility & 4 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n        }\n    }\n    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i];\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disconnectPassiveEffect(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                break;\n            case 22:\n                var instance = finishedWork.stateNode;\n                instance._visibility & 4 && (instance._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(finishedWork));\n                break;\n            default:\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n        }\n    }\n    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n        for(; null !== nextEffect;){\n            var fiber = nextEffect, current = fiber;\n            switch(current.tag){\n                case 0:\n                case 11:\n                case 15:\n                    commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);\n                    break;\n                case 23:\n                case 22:\n                    null !== current.memoizedState && null !== current.memoizedState.cachePool && (current = current.memoizedState.cachePool.pool, null != current && retainCache(current));\n                    break;\n                case 24:\n                    releaseCache(current.memoizedState.cache);\n            }\n            current = fiber.child;\n            if (null !== current) current.return = fiber, nextEffect = current;\n            else a: for(fiber = deletedSubtreeRoot; null !== nextEffect;){\n                current = nextEffect;\n                var sibling = current.sibling, returnFiber = current.return;\n                detachFiberAfterEffects(current);\n                if (current === fiber) {\n                    nextEffect = null;\n                    break a;\n                }\n                if (null !== sibling) {\n                    sibling.return = returnFiber;\n                    nextEffect = sibling;\n                    break a;\n                }\n                nextEffect = returnFiber;\n            }\n        }\n    }\n    function findFiberRootForHostRoot(hostRoot) {\n        var maybeFiber = getInstanceFromNode(hostRoot);\n        if (null != maybeFiber) {\n            if (\"string\" !== typeof maybeFiber.memoizedProps[\"data-testname\"]) throw Error(\"Invalid host root specified. Should be either a React container or a node with a testname attribute.\");\n            return maybeFiber;\n        }\n        hostRoot = findFiberRoot(hostRoot);\n        if (null === hostRoot) throw Error(\"Could not find React container within specified host subtree.\");\n        return hostRoot.stateNode.current;\n    }\n    function matchSelector(fiber$jscomp$0, selector) {\n        var tag = fiber$jscomp$0.tag;\n        switch(selector.$$typeof){\n            case COMPONENT_TYPE:\n                if (fiber$jscomp$0.type === selector.value) return !0;\n                break;\n            case HAS_PSEUDO_CLASS_TYPE:\n                a: {\n                    selector = selector.value;\n                    fiber$jscomp$0 = [\n                        fiber$jscomp$0,\n                        0\n                    ];\n                    for(tag = 0; tag < fiber$jscomp$0.length;){\n                        var fiber = fiber$jscomp$0[tag++], tag$jscomp$0 = fiber.tag, selectorIndex = fiber$jscomp$0[tag++], selector$jscomp$0 = selector[selectorIndex];\n                        if (5 !== tag$jscomp$0 && 26 !== tag$jscomp$0 && 27 !== tag$jscomp$0 || !isHiddenSubtree(fiber)) {\n                            for(; null != selector$jscomp$0 && matchSelector(fiber, selector$jscomp$0);)selectorIndex++, selector$jscomp$0 = selector[selectorIndex];\n                            if (selectorIndex === selector.length) {\n                                selector = !0;\n                                break a;\n                            } else for(fiber = fiber.child; null !== fiber;)fiber$jscomp$0.push(fiber, selectorIndex), fiber = fiber.sibling;\n                        }\n                    }\n                    selector = !1;\n                }\n                return selector;\n            case ROLE_TYPE:\n                if ((5 === tag || 26 === tag || 27 === tag) && matchAccessibilityRole(fiber$jscomp$0.stateNode, selector.value)) return !0;\n                break;\n            case TEXT_TYPE:\n                if (5 === tag || 6 === tag || 26 === tag || 27 === tag) {\n                    if (fiber$jscomp$0 = getTextContent(fiber$jscomp$0), null !== fiber$jscomp$0 && 0 <= fiber$jscomp$0.indexOf(selector.value)) return !0;\n                }\n                break;\n            case TEST_NAME_TYPE:\n                if (5 === tag || 26 === tag || 27 === tag) {\n                    if (fiber$jscomp$0 = fiber$jscomp$0.memoizedProps[\"data-testname\"], \"string\" === typeof fiber$jscomp$0 && fiber$jscomp$0.toLowerCase() === selector.value.toLowerCase()) return !0;\n                }\n                break;\n            default:\n                throw Error(\"Invalid selector type specified.\");\n        }\n        return !1;\n    }\n    function selectorToString(selector) {\n        switch(selector.$$typeof){\n            case COMPONENT_TYPE:\n                return \"<\" + (getComponentNameFromType(selector.value) || \"Unknown\") + \">\";\n            case HAS_PSEUDO_CLASS_TYPE:\n                return \":has(\" + (selectorToString(selector) || \"\") + \")\";\n            case ROLE_TYPE:\n                return '[role=\"' + selector.value + '\"]';\n            case TEXT_TYPE:\n                return '\"' + selector.value + '\"';\n            case TEST_NAME_TYPE:\n                return '[data-testname=\"' + selector.value + '\"]';\n            default:\n                throw Error(\"Invalid selector type specified.\");\n        }\n    }\n    function findPaths(root, selectors) {\n        var matchingFibers = [];\n        root = [\n            root,\n            0\n        ];\n        for(var index = 0; index < root.length;){\n            var fiber = root[index++], tag = fiber.tag, selectorIndex = root[index++], selector = selectors[selectorIndex];\n            if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {\n                for(; null != selector && matchSelector(fiber, selector);)selectorIndex++, selector = selectors[selectorIndex];\n                if (selectorIndex === selectors.length) matchingFibers.push(fiber);\n                else for(fiber = fiber.child; null !== fiber;)root.push(fiber, selectorIndex), fiber = fiber.sibling;\n            }\n        }\n        return matchingFibers;\n    }\n    function findAllNodes(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        hostRoot = findFiberRootForHostRoot(hostRoot);\n        hostRoot = findPaths(hostRoot, selectors);\n        selectors = [];\n        hostRoot = Array.from(hostRoot);\n        for(var index = 0; index < hostRoot.length;){\n            var node = hostRoot[index++], tag = node.tag;\n            if (5 === tag || 26 === tag || 27 === tag) isHiddenSubtree(node) || selectors.push(node.stateNode);\n            else for(node = node.child; null !== node;)hostRoot.push(node), node = node.sibling;\n        }\n        return selectors;\n    }\n    function onCommitRoot() {\n        supportsTestSelectors && commitHooks.forEach(function(commitHook) {\n            return commitHook();\n        });\n    }\n    function isConcurrentActEnvironment() {\n        var isReactActEnvironmentGlobal = \"undefined\" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;\n        isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(\"The current testing environment is not configured to support act(...)\");\n        return isReactActEnvironmentGlobal;\n    }\n    function requestUpdateLane(fiber) {\n        if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;\n        var transition = ReactSharedInternals.T;\n        return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();\n    }\n    function requestDeferredLane() {\n        0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);\n        var suspenseHandler = suspenseHandlerStackCursor.current;\n        null !== suspenseHandler && (suspenseHandler.flags |= 32);\n        return workInProgressDeferredLane;\n    }\n    function scheduleUpdateOnFiber(root, fiber, lane) {\n        isRunningInsertionEffect && console.error(\"useInsertionEffect must not schedule updates.\");\n        isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);\n        if (root === workInProgressRoot && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n        markRootUpdated$1(root, lane);\n        if (0 !== (executionContext & RenderContext) && root === workInProgressRoot) {\n            if (isRendering) switch(fiber.tag){\n                case 0:\n                case 11:\n                case 15:\n                    root = workInProgress && getComponentNameFromFiber(workInProgress) || \"Unknown\";\n                    didWarnAboutUpdateInRenderForAnotherComponent.has(root) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root), fiber = getComponentNameFromFiber(fiber) || \"Unknown\", console.error(\"Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render\", fiber, root, root));\n                    break;\n                case 1:\n                    didWarnAboutUpdateInRender || (console.error(\"Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.\"), didWarnAboutUpdateInRender = !0);\n            }\n        } else isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(root);\n    }\n    function performWorkOnRoot(root, lanes, forceSync) {\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        var shouldTimeSlice = !forceSync && 0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) || checkIfRootIsPrerendering(root, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes, !0), renderWasConcurrent = shouldTimeSlice;\n        do {\n            if (exitStatus === RootInProgress) {\n                workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root, lanes, 0, !1);\n                break;\n            } else if (exitStatus === RootDidNotComplete) markRootSuspended(root, lanes, 0, !workInProgressRootDidSkipSuspendedSiblings);\n            else {\n                forceSync = root.current.alternate;\n                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {\n                    exitStatus = renderRootSync(root, lanes, !1);\n                    renderWasConcurrent = !1;\n                    continue;\n                }\n                if (exitStatus === RootErrored) {\n                    renderWasConcurrent = lanes;\n                    if (root.errorRecoveryDisabledLanes & renderWasConcurrent) var errorRetryLanes = 0;\n                    else errorRetryLanes = root.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;\n                    if (0 !== errorRetryLanes) {\n                        lanes = errorRetryLanes;\n                        a: {\n                            exitStatus = root;\n                            var errorRetryLanes$jscomp$0 = errorRetryLanes;\n                            errorRetryLanes = workInProgressRootConcurrentErrors;\n                            var wasRootDehydrated = supportsHydration && exitStatus.current.memoizedState.isDehydrated;\n                            wasRootDehydrated && (prepareFreshStack(exitStatus, errorRetryLanes$jscomp$0).flags |= 256);\n                            errorRetryLanes$jscomp$0 = renderRootSync(exitStatus, errorRetryLanes$jscomp$0, !1);\n                            if (errorRetryLanes$jscomp$0 !== RootErrored) {\n                                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {\n                                    exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;\n                                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;\n                                    exitStatus = RootSuspendedWithDelay;\n                                    break a;\n                                }\n                                exitStatus = workInProgressRootRecoverableErrors;\n                                workInProgressRootRecoverableErrors = errorRetryLanes;\n                                null !== exitStatus && queueRecoverableErrors(exitStatus);\n                            }\n                            exitStatus = errorRetryLanes$jscomp$0;\n                        }\n                        renderWasConcurrent = !1;\n                        if (exitStatus !== RootErrored) continue;\n                    }\n                }\n                if (exitStatus === RootFatalErrored) {\n                    prepareFreshStack(root, 0);\n                    markRootSuspended(root, lanes, 0, !0);\n                    break;\n                }\n                a: {\n                    shouldTimeSlice = root;\n                    switch(exitStatus){\n                        case RootInProgress:\n                        case RootFatalErrored:\n                            throw Error(\"Root did not complete. This is a bug in React.\");\n                        case RootSuspendedWithDelay:\n                            if ((lanes & 4194176) === lanes) {\n                                markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                                break a;\n                            }\n                            break;\n                        case RootErrored:\n                            workInProgressRootRecoverableErrors = null;\n                            break;\n                        case RootSuspended:\n                        case RootCompleted:\n                            break;\n                        default:\n                            throw Error(\"Unknown root exit status.\");\n                    }\n                    shouldTimeSlice.finishedWork = forceSync;\n                    shouldTimeSlice.finishedLanes = lanes;\n                    if (null !== ReactSharedInternals.actQueue) commitRoot(shouldTimeSlice, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, IMMEDIATE_COMMIT, -0, 0);\n                    else {\n                        if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < exitStatus)) {\n                            markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                            if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;\n                            shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, THROTTLED_COMMIT, -0, 0), exitStatus);\n                            break a;\n                        }\n                        commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, IMMEDIATE_COMMIT, -0, 0);\n                    }\n                }\n            }\n            break;\n        }while (1);\n        ensureRootIsScheduled(root);\n    }\n    function queueRecoverableErrors(errors) {\n        null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = errors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n    }\n    function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {\n        var subtreeFlags = finishedWork.subtreeFlags;\n        if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {\n            if (startSuspendingCommit(), accumulateSuspenseyCommitOnFiber(finishedWork), finishedWork = waitForCommitToBeReady(), null !== finishedWork) {\n                root.cancelPendingCommit = finishedWork(commitRoot.bind(null, root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, SUSPENDED_COMMIT, completedRenderStartTime, completedRenderEndTime));\n                markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);\n                return;\n            }\n        }\n        commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);\n    }\n    function isRenderConsistentWithExternalStores(finishedWork) {\n        for(var node = finishedWork;;){\n            var tag = node.tag;\n            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for(var i = 0; i < tag.length; i++){\n                var check = tag[i], getSnapshot = check.getSnapshot;\n                check = check.value;\n                try {\n                    if (!objectIs(getSnapshot(), check)) return !1;\n                } catch (error) {\n                    return !1;\n                }\n            }\n            tag = node.child;\n            if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;\n            else {\n                if (node === finishedWork) break;\n                for(; null === node.sibling;){\n                    if (null === node.return || node.return === finishedWork) return !0;\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        return !0;\n    }\n    function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {\n        suspendedLanes &= ~workInProgressRootPingedLanes;\n        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;\n        root.suspendedLanes |= suspendedLanes;\n        root.pingedLanes &= ~suspendedLanes;\n        didAttemptEntireTree && (root.warmLanes |= suspendedLanes);\n        didAttemptEntireTree = root.expirationTimes;\n        for(var lanes = suspendedLanes; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            didAttemptEntireTree[index] = -1;\n            lanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n    }\n    function flushSyncWork() {\n        return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;\n    }\n    function resetWorkInProgressStack() {\n        if (null !== workInProgress) {\n            if (workInProgressSuspendedReason === NotSuspended) var interruptedWork = workInProgress.return;\n            else interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;\n            for(; null !== interruptedWork;)unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;\n            workInProgress = null;\n        }\n    }\n    function prepareFreshStack(root, lanes) {\n        root.finishedWork = null;\n        root.finishedLanes = 0;\n        var timeoutHandle = root.timeoutHandle;\n        timeoutHandle !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));\n        timeoutHandle = root.cancelPendingCommit;\n        null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());\n        resetWorkInProgressStack();\n        workInProgressRoot = root;\n        workInProgress = timeoutHandle = createWorkInProgress(root.current, null);\n        workInProgressRootRenderLanes = lanes;\n        workInProgressSuspendedReason = NotSuspended;\n        workInProgressThrownValue = null;\n        workInProgressRootDidSkipSuspendedSiblings = !1;\n        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        workInProgressRootDidAttachPingListener = !1;\n        workInProgressRootExitStatus = RootInProgress;\n        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;\n        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;\n        workInProgressRootDidIncludeRecursiveRenderUpdate = !1;\n        0 !== (lanes & 8) && (lanes |= lanes & 32);\n        var allEntangledLanes = root.entangledLanes;\n        if (0 !== allEntangledLanes) for(root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;){\n            var index = 31 - clz32(allEntangledLanes), lane = 1 << index;\n            lanes |= root[index];\n            allEntangledLanes &= ~lane;\n        }\n        entangledRenderLanes = lanes;\n        finishQueueingConcurrentUpdates();\n        ReactStrictModeWarnings.discardPendingWarnings();\n        return timeoutHandle;\n    }\n    function handleThrow(root, thrownValue) {\n        currentlyRenderingFiber$1 = null;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        ReactSharedInternals.getCurrentStack = null;\n        isRendering = !1;\n        current = null;\n        thrownValue === SuspenseException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && \"object\" === typeof thrownValue && \"function\" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;\n        workInProgressThrownValue = thrownValue;\n        var erroredWork = workInProgress;\n        if (null === erroredWork) workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n        else switch(erroredWork.mode & 2 && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason){\n            case SuspendedOnError:\n                null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                break;\n            case SuspendedOnData:\n            case SuspendedOnImmediate:\n            case SuspendedOnDeprecatedThrowPromise:\n            case SuspendedAndReadyToContinue:\n                null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(erroredWork, thrownValue, workInProgressRootRenderLanes);\n        }\n    }\n    function shouldRemainOnPreviousScreen() {\n        var handler = suspenseHandlerStackCursor.current;\n        return null === handler ? !0 : (workInProgressRootRenderLanes & 4194176) === workInProgressRootRenderLanes ? null === shellBoundary ? !0 : !1 : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : !1;\n    }\n    function pushDispatcher() {\n        var prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;\n    }\n    function pushAsyncDispatcher() {\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        return prevAsyncDispatcher;\n    }\n    function renderDidSuspendDelayIfPossible() {\n        workInProgressRootExitStatus = RootSuspendedWithDelay;\n        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194176) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = !0);\n        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n    }\n    function renderRootSync(root, lanes, shouldYieldForPrerendering) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            prepareFreshStack(root, lanes);\n        }\n        markRenderStarted(lanes);\n        lanes = !1;\n        memoizedUpdaters = workInProgressRootExitStatus;\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {\n                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;\n                switch(workInProgressSuspendedReason){\n                    case SuspendedOnHydration:\n                        resetWorkInProgressStack();\n                        memoizedUpdaters = RootDidNotComplete;\n                        break a;\n                    case SuspendedOnImmediate:\n                    case SuspendedOnData:\n                    case SuspendedOnDeprecatedThrowPromise:\n                        null === suspenseHandlerStackCursor.current && (lanes = !0);\n                        var reason = workInProgressSuspendedReason;\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                        if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {\n                            memoizedUpdaters = RootInProgress;\n                            break a;\n                        }\n                        break;\n                    default:\n                        reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                }\n            }\n            workLoopSync();\n            memoizedUpdaters = workInProgressRootExitStatus;\n            break;\n        } catch (thrownValue$4) {\n            handleThrow(root, thrownValue$4);\n        }\n        while (1);\n        lanes && root.shellSuspendCounter++;\n        resetContextDependencies();\n        executionContext = prevExecutionContext;\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        markRenderStopped();\n        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());\n        return memoizedUpdaters;\n    }\n    function workLoopSync() {\n        for(; null !== workInProgress;)performUnitOfWork(workInProgress);\n    }\n    function renderRootConcurrent(root, lanes) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n            prepareFreshStack(root, lanes);\n        } else workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        markRenderStarted(lanes);\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) b: switch(lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason){\n                case SuspendedOnError:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnError);\n                    break;\n                case SuspendedOnData:\n                    if (isThenableResolved(memoizedUpdaters)) {\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        replaySuspendedUnitOfWork(lanes);\n                        break;\n                    }\n                    lanes = function() {\n                        workInProgressSuspendedReason === SuspendedOnData && workInProgressRoot === root && (workInProgressSuspendedReason = SuspendedAndReadyToContinue);\n                        ensureRootIsScheduled(root);\n                    };\n                    memoizedUpdaters.then(lanes, lanes);\n                    break a;\n                case SuspendedOnImmediate:\n                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                    break a;\n                case SuspendedOnInstance:\n                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;\n                    break a;\n                case SuspendedAndReadyToContinue:\n                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));\n                    break;\n                case SuspendedOnInstanceAndReadyToContinue:\n                    var resource = null;\n                    switch(workInProgress.tag){\n                        case 26:\n                            resource = workInProgress.memoizedState;\n                        case 5:\n                        case 27:\n                            var hostFiber = workInProgress, type = hostFiber.type, props = hostFiber.pendingProps;\n                            if (resource ? preloadResource(resource) : preloadInstance(type, props)) {\n                                workInProgressSuspendedReason = NotSuspended;\n                                workInProgressThrownValue = null;\n                                var sibling = hostFiber.sibling;\n                                if (null !== sibling) workInProgress = sibling;\n                                else {\n                                    var returnFiber = hostFiber.return;\n                                    null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;\n                                }\n                                break b;\n                            }\n                            break;\n                        default:\n                            console.error(\"Unexpected type of fiber triggered a suspensey commit. This is a bug in React.\");\n                    }\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);\n                    break;\n                case SuspendedOnDeprecatedThrowPromise:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);\n                    break;\n                case SuspendedOnHydration:\n                    resetWorkInProgressStack();\n                    workInProgressRootExitStatus = RootDidNotComplete;\n                    break a;\n                default:\n                    throw Error(\"Unexpected SuspendedReason. This is a bug in React.\");\n            }\n            null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrent();\n            break;\n        } catch (thrownValue$5) {\n            handleThrow(root, thrownValue$5);\n        }\n        while (1);\n        resetContextDependencies();\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        executionContext = prevExecutionContext;\n        if (null !== workInProgress) return null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;\n        markRenderStopped();\n        workInProgressRoot = null;\n        workInProgressRootRenderLanes = 0;\n        finishQueueingConcurrentUpdates();\n        return workInProgressRootExitStatus;\n    }\n    function workLoopConcurrent() {\n        for(; null !== workInProgress && !shouldYield();)performUnitOfWork(workInProgress);\n    }\n    function performUnitOfWork(unitOfWork) {\n        var current = unitOfWork.alternate;\n        (unitOfWork.mode & 2) !== NoMode ? (startProfilerTimer(unitOfWork), current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === current ? completeUnitOfWork(unitOfWork) : workInProgress = current;\n    }\n    function replaySuspendedUnitOfWork(unitOfWork) {\n        var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;\n    }\n    function replayBeginWork(unitOfWork) {\n        var current = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & 2) !== NoMode;\n        isProfilingMode && startProfilerTimer(unitOfWork);\n        switch(unitOfWork.tag){\n            case 15:\n            case 0:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, void 0, workInProgressRootRenderLanes);\n                break;\n            case 11:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);\n                break;\n            case 5:\n                resetHooksOnUnwind(unitOfWork);\n            default:\n                unwindInterruptedWork(current, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current = beginWork(current, unitOfWork, entangledRenderLanes);\n        }\n        isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);\n        return current;\n    }\n    function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {\n        resetContextDependencies();\n        resetHooksOnUnwind(unitOfWork);\n        thenableState$1 = null;\n        thenableIndexCounter$1 = 0;\n        var returnFiber = unitOfWork.return;\n        try {\n            if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {\n                workInProgressRootExitStatus = RootFatalErrored;\n                logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n                workInProgress = null;\n                return;\n            }\n        } catch (error) {\n            if (null !== returnFiber) throw workInProgress = returnFiber, error;\n            workInProgressRootExitStatus = RootFatalErrored;\n            logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n            workInProgress = null;\n            return;\n        }\n        if (unitOfWork.flags & 32768) {\n            if (isHydrating || suspendedReason === SuspendedOnError) root = !0;\n            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = !1;\n            else if (workInProgressRootDidSkipSuspendedSiblings = root = !0, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);\n            unwindUnitOfWork(unitOfWork, root);\n        } else completeUnitOfWork(unitOfWork);\n    }\n    function completeUnitOfWork(unitOfWork) {\n        var completedWork = unitOfWork;\n        do {\n            if (0 !== (completedWork.flags & 32768)) {\n                unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);\n                return;\n            }\n            var current = completedWork.alternate;\n            unitOfWork = completedWork.return;\n            startProfilerTimer(completedWork);\n            current = runWithFiberInDEV(completedWork, completeWork, current, completedWork, entangledRenderLanes);\n            (completedWork.mode & 2) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);\n            if (null !== current) {\n                workInProgress = current;\n                return;\n            }\n            completedWork = completedWork.sibling;\n            if (null !== completedWork) {\n                workInProgress = completedWork;\n                return;\n            }\n            workInProgress = completedWork = unitOfWork;\n        }while (null !== completedWork);\n        workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);\n    }\n    function unwindUnitOfWork(unitOfWork, skipSiblings) {\n        do {\n            var next = unwindWork(unitOfWork.alternate, unitOfWork);\n            if (null !== next) {\n                next.flags &= 32767;\n                workInProgress = next;\n                return;\n            }\n            if ((unitOfWork.mode & 2) !== NoMode) {\n                stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);\n                next = unitOfWork.actualDuration;\n                for(var child = unitOfWork.child; null !== child;)next += child.actualDuration, child = child.sibling;\n                unitOfWork.actualDuration = next;\n            }\n            next = unitOfWork.return;\n            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);\n            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {\n                workInProgress = unitOfWork;\n                return;\n            }\n            workInProgress = unitOfWork = next;\n        }while (null !== unitOfWork);\n        workInProgressRootExitStatus = RootDidNotComplete;\n        workInProgress = null;\n    }\n    function commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {\n        var prevTransition = ReactSharedInternals.T, previousUpdateLanePriority = getCurrentUpdatePriority();\n        try {\n            setCurrentUpdatePriority(2), ReactSharedInternals.T = null, commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, previousUpdateLanePriority, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);\n        } finally{\n            ReactSharedInternals.T = prevTransition, setCurrentUpdatePriority(previousUpdateLanePriority);\n        }\n    }\n    function commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane, updatedLanes, suspendedRetryLanes) {\n        do flushPassiveEffects();\n        while (null !== rootWithPendingPassiveEffects);\n        ReactStrictModeWarnings.flushLegacyContextWarning();\n        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        var finishedWork = root.finishedWork;\n        didIncludeRenderPhaseUpdate = root.finishedLanes;\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(didIncludeRenderPhaseUpdate);\n        if (null === finishedWork) return markCommitStopped(), null;\n        0 === didIncludeRenderPhaseUpdate && console.error(\"root.finishedLanes should not be empty during a commit. This is a bug in React.\");\n        root.finishedWork = null;\n        root.finishedLanes = 0;\n        if (finishedWork === root.current) throw Error(\"Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.\");\n        root.callbackNode = null;\n        root.callbackPriority = 0;\n        root.cancelPendingCommit = null;\n        var remainingLanes = finishedWork.lanes | finishedWork.childLanes;\n        remainingLanes |= concurrentlyUpdatedLanes;\n        markRootFinished(root, didIncludeRenderPhaseUpdate, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes);\n        root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);\n        0 === (finishedWork.subtreeFlags & 10256) && 0 === (finishedWork.flags & 10256) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, pendingPassiveEffectsRemainingLanes = remainingLanes, pendingPassiveTransitions = transitions, scheduleCallback(NormalPriority$1, function() {\n            flushPassiveEffects(!0);\n            return null;\n        }));\n        commitStartTime = now();\n        transitions = 0 !== (finishedWork.flags & 15990);\n        0 !== (finishedWork.subtreeFlags & 15990) || transitions ? (transitions = ReactSharedInternals.T, ReactSharedInternals.T = null, spawnedLane = getCurrentUpdatePriority(), setCurrentUpdatePriority(2), updatedLanes = executionContext, executionContext |= CommitContext, commitBeforeMutationEffects(root, finishedWork), commitMutationEffects(root, finishedWork, didIncludeRenderPhaseUpdate), resetAfterCommit(root.containerInfo), root.current = finishedWork, null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(didIncludeRenderPhaseUpdate), commitLayoutEffects(finishedWork, root, didIncludeRenderPhaseUpdate), null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped(), requestPaint(), executionContext = updatedLanes, setCurrentUpdatePriority(spawnedLane), ReactSharedInternals.T = transitions) : root.current = finishedWork;\n        (transitions = rootDoesHavePassiveEffects) ? (rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = root, pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate) : (releaseRootPooledCache(root, remainingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);\n        remainingLanes = root.pendingLanes;\n        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);\n        transitions || commitDoubleInvokeEffectsInDEV(root);\n        onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);\n        isDevToolsPresent && root.memoizedUpdaters.clear();\n        onCommitRoot();\n        ensureRootIsScheduled(root);\n        if (null !== recoverableErrors) for(renderPriorityLevel = root.onRecoverableError, finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++)remainingLanes = recoverableErrors[finishedWork], transitions = makeErrorInfo(remainingLanes.stack), runWithFiberInDEV(remainingLanes.source, renderPriorityLevel, remainingLanes.value, transitions);\n        0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();\n        remainingLanes = root.pendingLanes;\n        0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = !0, root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root)) : nestedUpdateCount = 0;\n        flushSyncWorkAcrossRoots_impl(0, !1);\n        markCommitStopped();\n        return null;\n    }\n    function makeErrorInfo(componentStack) {\n        componentStack = {\n            componentStack: componentStack\n        };\n        Object.defineProperty(componentStack, \"digest\", {\n            get: function() {\n                console.error('You are accessing \"digest\" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');\n            }\n        });\n        return componentStack;\n    }\n    function releaseRootPooledCache(root, remainingLanes) {\n        0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));\n    }\n    function flushPassiveEffects() {\n        if (null !== rootWithPendingPassiveEffects) {\n            var root = rootWithPendingPassiveEffects, remainingLanes = pendingPassiveEffectsRemainingLanes;\n            pendingPassiveEffectsRemainingLanes = 0;\n            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes), priority = 32 > renderPriority ? 32 : renderPriority;\n            renderPriority = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(priority);\n                ReactSharedInternals.T = null;\n                if (null === rootWithPendingPassiveEffects) var JSCompiler_inline_result = !1;\n                else {\n                    priority = pendingPassiveTransitions;\n                    pendingPassiveTransitions = null;\n                    var root$jscomp$0 = rootWithPendingPassiveEffects, lanes = pendingPassiveEffectsLanes;\n                    rootWithPendingPassiveEffects = null;\n                    pendingPassiveEffectsLanes = 0;\n                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Cannot flush passive effects while already rendering.\");\n                    isFlushingPassiveEffects = !0;\n                    didScheduleUpdateDuringPassiveEffects = !1;\n                    null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n                    var prevExecutionContext = executionContext;\n                    executionContext |= CommitContext;\n                    commitPassiveUnmountOnFiber(root$jscomp$0.current);\n                    commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, priority);\n                    null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();\n                    commitDoubleInvokeEffectsInDEV(root$jscomp$0);\n                    executionContext = prevExecutionContext;\n                    flushSyncWorkAcrossRoots_impl(0, !1);\n                    didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;\n                    didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;\n                    if (injectedHook && \"function\" === typeof injectedHook.onPostCommitFiberRoot) try {\n                        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);\n                    } catch (err) {\n                        hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n                    }\n                    var stateNode = root$jscomp$0.current.stateNode;\n                    stateNode.effectDuration = 0;\n                    stateNode.passiveEffectDuration = 0;\n                    JSCompiler_inline_result = !0;\n                }\n                return JSCompiler_inline_result;\n            } finally{\n                setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);\n            }\n        }\n        return !1;\n    }\n    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);\n        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);\n        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));\n    }\n    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {\n        isRunningInsertionEffect = !1;\n        if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n        else {\n            for(; null !== nearestMountedAncestor;){\n                if (3 === nearestMountedAncestor.tag) {\n                    captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);\n                    return;\n                }\n                if (1 === nearestMountedAncestor.tag) {\n                    var instance = nearestMountedAncestor.stateNode;\n                    if (\"function\" === typeof nearestMountedAncestor.type.getDerivedStateFromError || \"function\" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {\n                        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n                        error = createClassErrorUpdate(2);\n                        instance = enqueueUpdate(nearestMountedAncestor, error, 2);\n                        null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));\n                        return;\n                    }\n                }\n                nearestMountedAncestor = nearestMountedAncestor.return;\n            }\n            console.error(\"Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\\n\\nError message:\\n\\n%s\", error);\n        }\n    }\n    function attachPingListener(root, wakeable, lanes) {\n        var pingCache = root.pingCache;\n        if (null === pingCache) {\n            pingCache = root.pingCache = new PossiblyWeakMap();\n            var threadIDs = new Set();\n            pingCache.set(wakeable, threadIDs);\n        } else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));\n        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = !0, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(pingCache, pingCache));\n    }\n    function pingSuspendedRoot(root, wakeable, pingedLanes) {\n        var pingCache = root.pingCache;\n        null !== pingCache && pingCache.delete(wakeable);\n        root.pingedLanes |= root.suspendedLanes & pingedLanes;\n        root.warmLanes &= ~pingedLanes;\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(\"A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\\n\\nWhen testing, code that resolves suspended data should be wrapped into act(...):\\n\\nact(() => {\\n  /* finish loading suspended data */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\");\n        workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));\n        ensureRootIsScheduled(root);\n    }\n    function retryTimedOutBoundary(boundaryFiber, retryLane) {\n        0 === retryLane && (retryLane = claimNextRetryLane());\n        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));\n    }\n    function retryDehydratedSuspenseBoundary(boundaryFiber) {\n        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;\n        null !== suspenseState && (retryLane = suspenseState.retryLane);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function resolveRetryWakeable(boundaryFiber, wakeable) {\n        var retryLane = 0;\n        switch(boundaryFiber.tag){\n            case 13:\n                var retryCache = boundaryFiber.stateNode;\n                var suspenseState = boundaryFiber.memoizedState;\n                null !== suspenseState && (retryLane = suspenseState.retryLane);\n                break;\n            case 19:\n                retryCache = boundaryFiber.stateNode;\n                break;\n            case 22:\n                retryCache = boundaryFiber.stateNode._retryCache;\n                break;\n            default:\n                throw Error(\"Pinged unknown suspense boundary type. This is probably a bug in React.\");\n        }\n        null !== retryCache && retryCache.delete(wakeable);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {\n        if (0 !== (parentFiber.subtreeFlags & 33562624)) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var root = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;\n            isStrictModeFiber = isInStrictMode || isStrictModeFiber;\n            22 !== fiber.tag ? fiber.flags & 33554432 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber, (fiber.mode & 64) === NoMode) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isStrictModeFiber) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : fiber.subtreeFlags & 33554432 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root, fiber, isStrictModeFiber));\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function doubleInvokeEffectsOnFiber(root, fiber) {\n        var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !0;\n        setIsStrictModeForDevtools(!0);\n        try {\n            disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root, fiber.alternate, fiber, !1), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root, fiber, 0, null, !1);\n        } finally{\n            setIsStrictModeForDevtools(!1);\n        }\n    }\n    function commitDoubleInvokeEffectsInDEV(root) {\n        var doubleInvokeEffects = !0;\n        root.current.mode & 24 || (doubleInvokeEffects = !1);\n        recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);\n    }\n    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n        if ((executionContext & RenderContext) === NoContext) {\n            var tag = fiber.tag;\n            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {\n                tag = getComponentNameFromFiber(fiber) || \"ReactComponent\";\n                if (null !== didWarnStateUpdateForNotYetMountedComponent) {\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;\n                    didWarnStateUpdateForNotYetMountedComponent.add(tag);\n                } else didWarnStateUpdateForNotYetMountedComponent = new Set([\n                    tag\n                ]);\n                runWithFiberInDEV(fiber, function() {\n                    console.error(\"Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.\");\n                });\n            }\n        }\n    }\n    function restorePendingUpdaters(root, lanes) {\n        isDevToolsPresent && root.memoizedUpdaters.forEach(function(schedulingFiber) {\n            addFiberToLanesMap(root, schedulingFiber, lanes);\n        });\n    }\n    function scheduleCallback(priorityLevel, callback) {\n        var actQueue = ReactSharedInternals.actQueue;\n        return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode) : scheduleCallback$3(priorityLevel, callback);\n    }\n    function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {\n            console.error(\"An update to %s inside a test was not wrapped in act(...).\\n\\nWhen testing, code that causes React state updates should be wrapped into act(...):\\n\\nact(() => {\\n  /* fire events that update state */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\", getComponentNameFromFiber(fiber));\n        });\n    }\n    function resolveFunctionForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? type : family.current;\n    }\n    function resolveForwardRefForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? null !== type && void 0 !== type && \"function\" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render: family\n        }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;\n    }\n    function isCompatibleFamilyForHotReloading(fiber, element) {\n        if (null === resolveFamily) return !1;\n        var prevType = fiber.elementType;\n        element = element.type;\n        var needsCompareFamilies = !1, $$typeofNextType = \"object\" === typeof element && null !== element ? element.$$typeof : null;\n        switch(fiber.tag){\n            case 1:\n                \"function\" === typeof element && (needsCompareFamilies = !0);\n                break;\n            case 0:\n                \"function\" === typeof element ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 11:\n                $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 14:\n            case 15:\n                $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            default:\n                return !1;\n        }\n        return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? !0 : !1;\n    }\n    function markFailedErrorBoundaryForHotReloading(fiber) {\n        null !== resolveFamily && \"function\" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = new WeakSet()), failedBoundaries.add(fiber));\n    }\n    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n        var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;\n        switch(tag){\n            case 0:\n            case 15:\n            case 1:\n                candidateType = type;\n                break;\n            case 11:\n                candidateType = type.render;\n        }\n        if (null === resolveFamily) throw Error(\"Expected resolveFamily to be set during hot reload.\");\n        var needsRender = !1;\n        type = !1;\n        null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = !0 : updatedFamilies.has(candidateType) && (1 === tag ? type = !0 : needsRender = !0)));\n        null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = !0);\n        type && (fiber._debugNeedsRemount = !0);\n        if (type || needsRender) alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);\n        null === child || type || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n        null !== sibling && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n    }\n    function FiberNode(tag, pendingProps, key, mode) {\n        this.tag = tag;\n        this.key = key;\n        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;\n        this.index = 0;\n        this.refCleanup = this.ref = null;\n        this.pendingProps = pendingProps;\n        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;\n        this.mode = mode;\n        this.subtreeFlags = this.flags = 0;\n        this.deletions = null;\n        this.childLanes = this.lanes = 0;\n        this.alternate = null;\n        this.actualDuration = -0;\n        this.actualStartTime = -1.1;\n        this.treeBaseDuration = this.selfBaseDuration = -0;\n        this._debugOwner = this._debugInfo = null;\n        this._debugNeedsRemount = !1;\n        this._debugHookTypes = null;\n        hasBadMapPolyfill || \"function\" !== typeof Object.preventExtensions || Object.preventExtensions(this);\n    }\n    function shouldConstruct(Component) {\n        Component = Component.prototype;\n        return !(!Component || !Component.isReactComponent);\n    }\n    function createWorkInProgress(current, pendingProps) {\n        var workInProgress = current.alternate;\n        null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress._debugOwner = current._debugOwner, workInProgress._debugHookTypes = current._debugHookTypes, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.actualDuration = -0, workInProgress.actualStartTime = -1.1);\n        workInProgress.flags = current.flags & 31457280;\n        workInProgress.childLanes = current.childLanes;\n        workInProgress.lanes = current.lanes;\n        workInProgress.child = current.child;\n        workInProgress.memoizedProps = current.memoizedProps;\n        workInProgress.memoizedState = current.memoizedState;\n        workInProgress.updateQueue = current.updateQueue;\n        pendingProps = current.dependencies;\n        workInProgress.dependencies = null === pendingProps ? null : {\n            lanes: pendingProps.lanes,\n            firstContext: pendingProps.firstContext,\n            _debugThenableState: pendingProps._debugThenableState\n        };\n        workInProgress.sibling = current.sibling;\n        workInProgress.index = current.index;\n        workInProgress.ref = current.ref;\n        workInProgress.refCleanup = current.refCleanup;\n        workInProgress.selfBaseDuration = current.selfBaseDuration;\n        workInProgress.treeBaseDuration = current.treeBaseDuration;\n        workInProgress._debugInfo = current._debugInfo;\n        workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n        switch(workInProgress.tag){\n            case 0:\n            case 15:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 1:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 11:\n                workInProgress.type = resolveForwardRefForHotReloading(current.type);\n        }\n        return workInProgress;\n    }\n    function resetWorkInProgress(workInProgress, renderLanes) {\n        workInProgress.flags &= 31457282;\n        var current = workInProgress.alternate;\n        null === current ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null, workInProgress.selfBaseDuration = 0, workInProgress.treeBaseDuration = 0) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = null === renderLanes ? null : {\n            lanes: renderLanes.lanes,\n            firstContext: renderLanes.firstContext,\n            _debugThenableState: renderLanes._debugThenableState\n        }, workInProgress.selfBaseDuration = current.selfBaseDuration, workInProgress.treeBaseDuration = current.treeBaseDuration);\n        return workInProgress;\n    }\n    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n        var fiberTag = 0, resolvedType = type;\n        if (\"function\" === typeof type) shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);\n        else if (\"string\" === typeof type) supportsResources && supportsSingletons ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : isHostSingletonType(type) ? 27 : 5) : supportsResources ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : 5) : fiberTag = supportsSingletons ? isHostSingletonType(type) ? 27 : 5 : 5;\n        else a: switch(type){\n            case REACT_FRAGMENT_TYPE:\n                return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n            case REACT_STRICT_MODE_TYPE:\n                fiberTag = 8;\n                mode |= 24;\n                break;\n            case REACT_PROFILER_TYPE:\n                return type = pendingProps, owner = mode, \"string\" !== typeof type.id && console.error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | 2), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = {\n                    effectDuration: 0,\n                    passiveEffectDuration: 0\n                }, key;\n            case REACT_SUSPENSE_TYPE:\n                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;\n            case REACT_SUSPENSE_LIST_TYPE:\n                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;\n            case REACT_OFFSCREEN_TYPE:\n                return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n            default:\n                if (\"object\" === typeof type && null !== type) switch(type.$$typeof){\n                    case REACT_PROVIDER_TYPE:\n                    case REACT_CONTEXT_TYPE:\n                        fiberTag = 10;\n                        break a;\n                    case REACT_CONSUMER_TYPE:\n                        fiberTag = 9;\n                        break a;\n                    case REACT_FORWARD_REF_TYPE:\n                        fiberTag = 11;\n                        resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                        break a;\n                    case REACT_MEMO_TYPE:\n                        fiberTag = 14;\n                        break a;\n                    case REACT_LAZY_TYPE:\n                        fiberTag = 16;\n                        resolvedType = null;\n                        break a;\n                }\n                resolvedType = \"\";\n                if (void 0 === type || \"object\" === typeof type && null !== type && 0 === Object.keys(type).length) resolvedType += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n                null === type ? pendingProps = \"null\" : isArrayImpl(type) ? pendingProps = \"array\" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\", resolvedType = \" Did you accidentally export a JSX literal instead of a component?\") : pendingProps = typeof type;\n                fiberTag = owner ? \"number\" === typeof owner.tag ? getComponentNameFromFiber(owner) : \"string\" === typeof owner.name ? owner.name : null : null;\n                fiberTag && (resolvedType += \"\\n\\nCheck the render method of `\" + fiberTag + \"`.\");\n                fiberTag = 29;\n                pendingProps = Error(\"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" + (pendingProps + \".\" + resolvedType));\n                resolvedType = null;\n        }\n        key = createFiber(fiberTag, pendingProps, key, mode);\n        key.elementType = type;\n        key.type = resolvedType;\n        key.lanes = lanes;\n        key._debugOwner = owner;\n        return key;\n    }\n    function createFiberFromElement(element, mode, lanes) {\n        mode = createFiberFromTypeAndProps(element.type, element.key, element.props, element._owner, mode, lanes);\n        mode._debugOwner = element._owner;\n        return mode;\n    }\n    function createFiberFromFragment(elements, mode, lanes, key) {\n        elements = createFiber(7, elements, key, mode);\n        elements.lanes = lanes;\n        return elements;\n    }\n    function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n        pendingProps = createFiber(22, pendingProps, key, mode);\n        pendingProps.elementType = REACT_OFFSCREEN_TYPE;\n        pendingProps.lanes = lanes;\n        var primaryChildInstance = {\n            _visibility: 1,\n            _pendingVisibility: 1,\n            _pendingMarkers: null,\n            _retryCache: null,\n            _transitions: null,\n            _current: null,\n            detach: function() {\n                var instance = primaryChildInstance, fiber = instance._current;\n                if (null === fiber) throw Error(\"Calling Offscreen.detach before instance handle has been set.\");\n                if (0 === (instance._pendingVisibility & 2)) {\n                    var root = enqueueConcurrentRenderForLane(fiber, 2);\n                    null !== root && (instance._pendingVisibility |= 2, scheduleUpdateOnFiber(root, fiber, 2));\n                }\n            },\n            attach: function() {\n                var instance = primaryChildInstance, fiber = instance._current;\n                if (null === fiber) throw Error(\"Calling Offscreen.detach before instance handle has been set.\");\n                if (0 !== (instance._pendingVisibility & 2)) {\n                    var root = enqueueConcurrentRenderForLane(fiber, 2);\n                    null !== root && (instance._pendingVisibility &= -3, scheduleUpdateOnFiber(root, fiber, 2));\n                }\n            }\n        };\n        pendingProps.stateNode = primaryChildInstance;\n        return pendingProps;\n    }\n    function createFiberFromText(content, mode, lanes) {\n        content = createFiber(6, content, null, mode);\n        content.lanes = lanes;\n        return content;\n    }\n    function createFiberFromPortal(portal, mode, lanes) {\n        mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);\n        mode.lanes = lanes;\n        mode.stateNode = {\n            containerInfo: portal.containerInfo,\n            pendingChildren: null,\n            implementation: portal.implementation\n        };\n        return mode;\n    }\n    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {\n        this.tag = 1;\n        this.containerInfo = containerInfo;\n        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;\n        this.timeoutHandle = noTimeout;\n        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;\n        this.callbackPriority = 0;\n        this.expirationTimes = createLaneMap(-1);\n        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;\n        this.entanglements = createLaneMap(0);\n        this.hiddenUpdates = createLaneMap(null);\n        this.identifierPrefix = identifierPrefix;\n        this.onUncaughtError = onUncaughtError;\n        this.onCaughtError = onCaughtError;\n        this.onRecoverableError = onRecoverableError;\n        this.pooledCache = null;\n        this.pooledCacheLanes = 0;\n        this.formState = formState;\n        this.incompleteTransitions = new Map();\n        this.passiveEffectDuration = this.effectDuration = -0;\n        this.memoizedUpdaters = new Set();\n        containerInfo = this.pendingUpdatersLaneMap = [];\n        for(tag = 0; 31 > tag; tag++)containerInfo.push(new Set());\n        this._debugRootType = hydrate ? \"hydrateRoot()\" : \"createRoot()\";\n    }\n    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n        containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);\n        tag = 1;\n        !0 === isStrictMode && (tag |= 24);\n        isDevToolsPresent && (tag |= 2);\n        isStrictMode = createFiber(3, null, null, tag);\n        containerInfo.current = isStrictMode;\n        isStrictMode.stateNode = containerInfo;\n        tag = createCache();\n        retainCache(tag);\n        containerInfo.pooledCache = tag;\n        retainCache(tag);\n        isStrictMode.memoizedState = {\n            element: initialChildren,\n            isDehydrated: hydrate,\n            cache: tag\n        };\n        initializeUpdateQueue(isStrictMode);\n        return containerInfo;\n    }\n    function testStringCoercion(value) {\n        return \"\" + value;\n    }\n    function getContextForSubtree(parentComponent) {\n        if (!parentComponent) return emptyContextObject;\n        parentComponent = emptyContextObject;\n        return parentComponent;\n    }\n    function updateContainerSync(element, container, parentComponent, callback) {\n        0 === container.tag && flushPassiveEffects();\n        updateContainerImpl(container.current, 2, element, container, parentComponent, callback);\n        return 2;\n    }\n    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {\n        if (injectedHook && \"function\" === typeof injectedHook.onScheduleFiberRoot) try {\n            injectedHook.onScheduleFiberRoot(rendererID, container, element);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);\n        parentComponent = getContextForSubtree(parentComponent);\n        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;\n        isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = !0, console.error(\"Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\\n\\nCheck the render method of %s.\", getComponentNameFromFiber(current) || \"Unknown\"));\n        container = createUpdate(lane);\n        container.payload = {\n            element: element\n        };\n        callback = void 0 === callback ? null : callback;\n        null !== callback && (\"function\" !== typeof callback && console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback), container.callback = callback);\n        element = enqueueUpdate(rootFiber, container, lane);\n        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));\n    }\n    function markRetryLaneImpl(fiber, retryLane) {\n        fiber = fiber.memoizedState;\n        if (null !== fiber && null !== fiber.dehydrated) {\n            var a = fiber.retryLane;\n            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;\n        }\n    }\n    function markRetryLaneIfNotHydrated(fiber, retryLane) {\n        markRetryLaneImpl(fiber, retryLane);\n        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);\n    }\n    function getCurrentFiberForDevTools() {\n        return current;\n    }\n    function getLaneLabelMap() {\n        for(var map = new Map(), lane = 1, index = 0; 31 > index; index++){\n            var label = getLabelForLane(lane);\n            map.set(lane, label);\n            lane *= 2;\n        }\n        return map;\n    }\n    var exports = {};\n    \"use strict\";\n    var React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"), Scheduler = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/react-reconciler/node_modules/scheduler/index.js\"), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for(\"react.element\"), REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"), REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"), REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n    Symbol.for(\"react.scope\");\n    Symbol.for(\"react.debug_trace_mode\");\n    var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n    Symbol.for(\"react.legacy_hidden\");\n    Symbol.for(\"react.tracing_marker\");\n    var REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix, suffix, reentry = !1;\n    var componentFrameCache = new (\"function\" === typeof WeakMap ? WeakMap : Map)();\n    var current = null, isRendering = !1, isArrayImpl = Array.isArray, rendererVersion = $$$config.rendererVersion, rendererPackageName = $$$config.rendererPackageName, extraDevToolsConfig = $$$config.extraDevToolsConfig, getPublicInstance = $$$config.getPublicInstance, getRootHostContext = $$$config.getRootHostContext, getChildHostContext = $$$config.getChildHostContext, prepareForCommit = $$$config.prepareForCommit, resetAfterCommit = $$$config.resetAfterCommit, createInstance = $$$config.createInstance, appendInitialChild = $$$config.appendInitialChild, finalizeInitialChildren = $$$config.finalizeInitialChildren, shouldSetTextContent = $$$config.shouldSetTextContent, createTextInstance = $$$config.createTextInstance, scheduleTimeout = $$$config.scheduleTimeout, cancelTimeout = $$$config.cancelTimeout, noTimeout = $$$config.noTimeout, isPrimaryRenderer = $$$config.isPrimaryRenderer;\n    $$$config.warnsIfNotActing;\n    var supportsMutation = $$$config.supportsMutation, supportsPersistence = $$$config.supportsPersistence, supportsHydration = $$$config.supportsHydration, getInstanceFromNode = $$$config.getInstanceFromNode;\n    $$$config.beforeActiveInstanceBlur;\n    $$$config.afterActiveInstanceBlur;\n    var preparePortalMount = $$$config.preparePortalMount;\n    $$$config.prepareScopeUpdate;\n    $$$config.getInstanceFromScope;\n    var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority, getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority, resolveUpdatePriority = $$$config.resolveUpdatePriority;\n    $$$config.resolveEventType;\n    $$$config.resolveEventTimeStamp;\n    var shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition, detachDeletedInstance = $$$config.detachDeletedInstance;\n    $$$config.requestPostPaintCallback;\n    var maySuspendCommit = $$$config.maySuspendCommit, preloadInstance = $$$config.preloadInstance, startSuspendingCommit = $$$config.startSuspendingCommit, suspendInstance = $$$config.suspendInstance, waitForCommitToBeReady = $$$config.waitForCommitToBeReady, NotPendingTransition = $$$config.NotPendingTransition, HostTransitionContext = $$$config.HostTransitionContext, resetFormInstance = $$$config.resetFormInstance, bindToConsole = $$$config.bindToConsole, supportsMicrotasks = $$$config.supportsMicrotasks, scheduleMicrotask = $$$config.scheduleMicrotask, supportsTestSelectors = $$$config.supportsTestSelectors, findFiberRoot = $$$config.findFiberRoot, getBoundingRect = $$$config.getBoundingRect, getTextContent = $$$config.getTextContent, isHiddenSubtree = $$$config.isHiddenSubtree, matchAccessibilityRole = $$$config.matchAccessibilityRole, setFocusIfFocusable = $$$config.setFocusIfFocusable, setupIntersectionObserver = $$$config.setupIntersectionObserver, appendChild = $$$config.appendChild, appendChildToContainer = $$$config.appendChildToContainer, commitTextUpdate = $$$config.commitTextUpdate, commitMount = $$$config.commitMount, commitUpdate = $$$config.commitUpdate, insertBefore = $$$config.insertBefore, insertInContainerBefore = $$$config.insertInContainerBefore, removeChild = $$$config.removeChild, removeChildFromContainer = $$$config.removeChildFromContainer, resetTextContent = $$$config.resetTextContent, hideInstance = $$$config.hideInstance, hideTextInstance = $$$config.hideTextInstance, unhideInstance = $$$config.unhideInstance, unhideTextInstance = $$$config.unhideTextInstance, clearContainer = $$$config.clearContainer, cloneInstance = $$$config.cloneInstance, createContainerChildSet = $$$config.createContainerChildSet, appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet, finalizeContainerChildren = $$$config.finalizeContainerChildren, replaceContainerChildren = $$$config.replaceContainerChildren, cloneHiddenInstance = $$$config.cloneHiddenInstance, cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance, isSuspenseInstancePending = $$$config.isSuspenseInstancePending, isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback, getSuspenseInstanceFallbackErrorDetails = $$$config.getSuspenseInstanceFallbackErrorDetails, registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry, canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker, isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching, getNextHydratableSibling = $$$config.getNextHydratableSibling, getFirstHydratableChild = $$$config.getFirstHydratableChild, getFirstHydratableChildWithinContainer = $$$config.getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinSuspenseInstance = $$$config.getFirstHydratableChildWithinSuspenseInstance, canHydrateInstance = $$$config.canHydrateInstance, canHydrateTextInstance = $$$config.canHydrateTextInstance, canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance, hydrateInstance = $$$config.hydrateInstance, hydrateTextInstance = $$$config.hydrateTextInstance, hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance, getNextHydratableInstanceAfterSuspenseInstance = $$$config.getNextHydratableInstanceAfterSuspenseInstance, commitHydratedContainer = $$$config.commitHydratedContainer, commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance, clearSuspenseBoundary = $$$config.clearSuspenseBoundary, clearSuspenseBoundaryFromContainer = $$$config.clearSuspenseBoundaryFromContainer, shouldDeleteUnhydratedTailInstances = $$$config.shouldDeleteUnhydratedTailInstances, diffHydratedPropsForDevWarnings = $$$config.diffHydratedPropsForDevWarnings, diffHydratedTextForDevWarnings = $$$config.diffHydratedTextForDevWarnings, describeHydratableInstanceForDevWarnings = $$$config.describeHydratableInstanceForDevWarnings, validateHydratableInstance = $$$config.validateHydratableInstance, validateHydratableTextInstance = $$$config.validateHydratableTextInstance, supportsResources = $$$config.supportsResources, isHostHoistableType = $$$config.isHostHoistableType, getHoistableRoot = $$$config.getHoistableRoot, getResource = $$$config.getResource, acquireResource = $$$config.acquireResource, releaseResource = $$$config.releaseResource, hydrateHoistable = $$$config.hydrateHoistable, mountHoistable = $$$config.mountHoistable, unmountHoistable = $$$config.unmountHoistable, createHoistableInstance = $$$config.createHoistableInstance, prepareToCommitHoistables = $$$config.prepareToCommitHoistables, mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit, preloadResource = $$$config.preloadResource, suspendResource = $$$config.suspendResource, supportsSingletons = $$$config.supportsSingletons, resolveSingletonInstance = $$$config.resolveSingletonInstance, clearSingleton = $$$config.clearSingleton, acquireSingletonInstance = $$$config.acquireSingletonInstance, releaseSingletonInstance = $$$config.releaseSingletonInstance, isHostSingletonType = $$$config.isHostSingletonType, valueStack = [];\n    var fiberStack = [];\n    var index$jscomp$0 = -1, emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log$1 = Math.log, LN2 = Math.LN2, nextTransitionLane = 128, nextRetryLane = 4194304, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, IdlePriority = Scheduler.unstable_IdlePriority, log = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = !1, isDevToolsPresent = \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, objectIs = \"function\" === typeof Object.is ? Object.is : is, CapturedStacks = new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = \"\", contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), needsEscaping = /[\"'&<>\\n\\t]|^\\s|\\s$/, hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = !1, HydrationMismatchException = Error(\"Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), NoMode = 0, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, now = Scheduler.unstable_now, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, currentUpdateIsNested = !1, nestedUpdateScheduled = !1, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = !1, didScheduleMicrotask_act = !1, mightHavePendingSyncWork = !1, isFlushingWork = !1, currentEventTransitionLane = 0, fakeActCallbackNode$1 = {}, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = !1;\n    var didWarnUpdateInsideUpdate = !1;\n    var currentlyProcessingQueue = null;\n    var didReadFromEntangledAsyncAction = !1, hasOwnProperty = Object.prototype.hasOwnProperty, ReactStrictModeWarnings = {\n        recordUnsafeLifecycleWarnings: function() {},\n        flushPendingUnsafeLifecycleWarnings: function() {},\n        recordLegacyContextWarning: function() {},\n        flushLegacyContextWarning: function() {},\n        discardPendingWarnings: function() {}\n    }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = new Set();\n    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n        didWarnAboutUnsafeLifecycles.has(fiber.type) || (\"function\" === typeof instance.componentWillMount && !0 !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), \"function\" === typeof instance.componentWillReceiveProps && !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), \"function\" === typeof instance.componentWillUpdate && !0 !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));\n    };\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n        var componentWillMountUniqueNames = new Set();\n        0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {\n            componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillMountWarnings = []);\n        var UNSAFE_componentWillMountUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillMountWarnings = []);\n        var componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillReceivePropsWarnings = []);\n        var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);\n        var componentWillUpdateUniqueNames = new Set();\n        0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n            componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillUpdateWarnings = []);\n        var UNSAFE_componentWillUpdateUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillUpdateWarnings = []);\n        if (0 < UNSAFE_componentWillMountUniqueNames.size) {\n            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n            console.error(\"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\\nPlease update the following components: %s\", sortedNames);\n        }\n        0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames), console.error(\"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error(\"Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(\"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(componentWillReceivePropsUniqueNames), console.warn(\"componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(\"componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n    };\n    var pendingLegacyContextWarning = new Map(), didWarnAboutLegacyContext = new Set();\n    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n        var strictRoot = null;\n        for(var node = fiber; null !== node;)node.mode & 8 && (strictRoot = node), node = node.return;\n        null === strictRoot ? console.error(\"Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.\") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && \"function\" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));\n    };\n    ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n        pendingLegacyContextWarning.forEach(function(fiberArray) {\n            if (0 !== fiberArray.length) {\n                var firstFiber = fiberArray[0], uniqueNames = new Set();\n                fiberArray.forEach(function(fiber) {\n                    uniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                    didWarnAboutLegacyContext.add(fiber.type);\n                });\n                var sortedNames = setToSortedString(uniqueNames);\n                runWithFiberInDEV(firstFiber, function() {\n                    console.error(\"Legacy context API has been detected within a strict-mode tree.\\n\\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\\n\\nPlease update the following components: %s\\n\\nLearn more about this warning here: https://react.dev/link/legacy-context\", sortedNames);\n                });\n            }\n        });\n    };\n    ReactStrictModeWarnings.discardPendingWarnings = function() {\n        pendingComponentWillMountWarnings = [];\n        pendingUNSAFE_ComponentWillMountWarnings = [];\n        pendingComponentWillReceivePropsWarnings = [];\n        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n        pendingComponentWillUpdateWarnings = [];\n        pendingUNSAFE_ComponentWillUpdateWarnings = [];\n        pendingLegacyContextWarning = new Map();\n    };\n    var SuspenseException = Error(\"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`\"), SuspenseyCommitException = Error(\"Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), noopSuspenseyCommitThenable = {\n        then: function() {\n            console.error('Internal React error: A listener was unexpectedly attached to a \"noop\" thenable. This is a bug in React. Please file an issue.');\n        }\n    }, suspendedThenable = null, needsToResetSuspendedThenableDEV = !1, callComponent = {\n        \"react-stack-bottom-frame\": function(Component, props, secondArg) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return Component(props, secondArg);\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callComponentInDEV = callComponent[\"react-stack-bottom-frame\"].bind(callComponent), callRender = {\n        \"react-stack-bottom-frame\": function(instance) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return instance.render();\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callRenderInDEV = callRender[\"react-stack-bottom-frame\"].bind(callRender), callComponentDidMount = {\n        \"react-stack-bottom-frame\": function(finishedWork, instance) {\n            try {\n                instance.componentDidMount();\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidMountInDEV = callComponentDidMount[\"react-stack-bottom-frame\"].bind(callComponentDidMount), callComponentDidUpdate = {\n        \"react-stack-bottom-frame\": function(finishedWork, instance, prevProps, prevState, snapshot) {\n            try {\n                instance.componentDidUpdate(prevProps, prevState, snapshot);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidUpdateInDEV = callComponentDidUpdate[\"react-stack-bottom-frame\"].bind(callComponentDidUpdate), callComponentDidCatch = {\n        \"react-stack-bottom-frame\": function(instance, errorInfo) {\n            var stack = errorInfo.stack;\n            instance.componentDidCatch(errorInfo.value, {\n                componentStack: null !== stack ? stack : \"\"\n            });\n        }\n    }, callComponentDidCatchInDEV = callComponentDidCatch[\"react-stack-bottom-frame\"].bind(callComponentDidCatch), callComponentWillUnmount = {\n        \"react-stack-bottom-frame\": function(current, nearestMountedAncestor, instance) {\n            try {\n                instance.componentWillUnmount();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callComponentWillUnmountInDEV = callComponentWillUnmount[\"react-stack-bottom-frame\"].bind(callComponentWillUnmount), callCreate = {\n        \"react-stack-bottom-frame\": function(effect) {\n            var create = effect.create;\n            effect = effect.inst;\n            create = create();\n            return effect.destroy = create;\n        }\n    }, callCreateInDEV = callCreate[\"react-stack-bottom-frame\"].bind(callCreate), callDestroy = {\n        \"react-stack-bottom-frame\": function(current, nearestMountedAncestor, destroy) {\n            try {\n                destroy();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callDestroyInDEV = callDestroy[\"react-stack-bottom-frame\"].bind(callDestroy), callLazyInit = {\n        \"react-stack-bottom-frame\": function(lazy) {\n            var init = lazy._init;\n            return init(lazy._payload);\n        }\n    }, callLazyInitInDEV = callLazyInit[\"react-stack-bottom-frame\"].bind(callLazyInit), thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;\n    var didWarnAboutGenerators = didWarnAboutMaps = !1;\n    var ownerHasKeyUseWarning = {};\n    var ownerHasFunctionTypeWarning = {};\n    var ownerHasSymbolTypeWarning = {};\n    warnForMissingKey = function(returnFiber, workInProgress, child) {\n        if (null !== child && \"object\" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {\n            if (\"object\" !== typeof child._store) throw Error(\"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\");\n            child._store.validated = 1;\n            var componentName = getComponentNameFromFiber(returnFiber), componentKey = componentName || \"null\";\n            if (!ownerHasKeyUseWarning[componentKey]) {\n                ownerHasKeyUseWarning[componentKey] = !0;\n                child = child._owner;\n                returnFiber = returnFiber._debugOwner;\n                var currentComponentErrorInfo = \"\";\n                returnFiber && \"number\" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = \"\\n\\nCheck the render method of `\" + componentKey + \"`.\");\n                currentComponentErrorInfo || componentName && (currentComponentErrorInfo = \"\\n\\nCheck the top-level render call using <\" + componentName + \">.\");\n                var childOwnerAppendix = \"\";\n                null != child && returnFiber !== child && (componentName = null, \"number\" === typeof child.tag ? componentName = getComponentNameFromFiber(child) : \"string\" === typeof child.name && (componentName = child.name), componentName && (childOwnerAppendix = \" It was passed a child from \" + componentName + \".\"));\n                runWithFiberInDEV(workInProgress, function() {\n                    console.error('Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);\n                });\n            }\n        }\n    };\n    var reconcileChildFibers = createChildReconciler(!0), mountChildFibers = createChildReconciler(!1), currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;\n    var didWarnAboutMismatchedHooksForComponent = new Set();\n    var didWarnAboutUseWrappedInTryCatch = new Set();\n    var didWarnAboutAsyncClientComponent = new Set();\n    var didWarnAboutUseFormState = new Set();\n    var renderLanes = 0, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, shouldDoubleInvokeUserFnsInHooksDEV = !1, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = !1;\n    var createFunctionComponentUpdateQueue = function() {\n        return {\n            lastEffect: null,\n            events: null,\n            stores: null,\n            memoCache: null\n        };\n    };\n    var ContextOnlyDispatcher = {\n        readContext: readContext,\n        use: use,\n        useCallback: throwInvalidHookError,\n        useContext: throwInvalidHookError,\n        useEffect: throwInvalidHookError,\n        useImperativeHandle: throwInvalidHookError,\n        useLayoutEffect: throwInvalidHookError,\n        useInsertionEffect: throwInvalidHookError,\n        useMemo: throwInvalidHookError,\n        useReducer: throwInvalidHookError,\n        useRef: throwInvalidHookError,\n        useState: throwInvalidHookError,\n        useDebugValue: throwInvalidHookError,\n        useDeferredValue: throwInvalidHookError,\n        useTransition: throwInvalidHookError,\n        useSyncExternalStore: throwInvalidHookError,\n        useId: throwInvalidHookError\n    };\n    ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;\n    ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;\n    ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;\n    ContextOnlyDispatcher.useFormState = throwInvalidHookError;\n    ContextOnlyDispatcher.useActionState = throwInvalidHookError;\n    ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;\n    var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n    HooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            mountHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        }\n    };\n    HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnMountInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        mountHookTypesDev();\n        warnOnUseFormStateInDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        mountHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return mountRefresh();\n        }\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    HooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnUpdateInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return updateActionState(action);\n    };\n    HooksDispatcherOnUpdateInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    HooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return updateOptimistic(passthrough, reducer);\n    };\n    HooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnRerenderInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return rerenderActionState(action);\n    };\n    HooksDispatcherOnRerenderInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    HooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return rerenderOptimistic(passthrough, reducer);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateOptimistic(passthrough, reducer);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderOptimistic(passthrough, reducer);\n    };\n    var fakeInternalInstance = {};\n    var didWarnAboutStateAssignmentForComponent = new Set();\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    Object.freeze(fakeInternalInstance);\n    var classComponentUpdater = {\n        isMounted: function(component) {\n            var owner = current;\n            if (null !== owner && isRendering && 1 === owner.tag) {\n                var instance = owner.stateNode;\n                instance._warnedAboutRefsInRender || console.error(\"%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.\", getComponentNameFromFiber(owner) || \"A component\");\n                instance._warnedAboutRefsInRender = !0;\n            }\n            return (component = component._reactInternals) ? getNearestMountedFiber(component) === component : !1;\n        },\n        enqueueSetState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n            markStateUpdateScheduled(inst, lane);\n        },\n        enqueueReplaceState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ReplaceState;\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n            markStateUpdateScheduled(inst, lane);\n        },\n        enqueueForceUpdate: function(inst, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ForceUpdate;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            callback = enqueueUpdate(inst, update, lane);\n            null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));\n            null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);\n        }\n    }, reportGlobalError = \"function\" === typeof reportError ? reportError : function(error) {\n        if (false) { var event; } else if (\"object\" === typeof process && \"function\" === typeof process.emit) {\n            process.emit(\"uncaughtException\", error);\n            return;\n        }\n        console.error(error);\n    }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(\"This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue.\"), didReceiveUpdate = !1;\n    var didWarnAboutBadClass = {};\n    var didWarnAboutContextTypeOnFunctionComponent = {};\n    var didWarnAboutContextTypes = {};\n    var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n    var didWarnAboutReassigningProps = !1;\n    var didWarnAboutRevealOrder = {};\n    var didWarnAboutTailOptions = {};\n    var SUSPENDED_MARKER = {\n        dehydrated: null,\n        treeContext: null,\n        retryLane: 0\n    }, hasWarnedAboutUsingNoValuePropOnContextProvider = !1, valueCursor = createCursor(null);\n    var rendererCursorDEV = createCursor(null);\n    var renderer2CursorDEV = createCursor(null);\n    var rendererSigil = {};\n    var currentlyRenderingFiber = null, lastContextDependency = null, isDisallowedContextReadInDEV = !1, AbortControllerLocal = \"undefined\" !== typeof AbortController ? AbortController : function() {\n        var listeners = [], signal = this.signal = {\n            aborted: !1,\n            addEventListener: function(type, listener) {\n                listeners.push(listener);\n            }\n        };\n        this.abort = function() {\n            signal.aborted = !0;\n            listeners.forEach(function(listener) {\n                return listener();\n            });\n        };\n    }, scheduleCallback$1 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        Consumer: null,\n        Provider: null,\n        _currentValue: null,\n        _currentValue2: null,\n        _threadCount: 0,\n        _currentRenderer: null,\n        _currentRenderer2: null\n    }, prevOnStartTransitionFinish = ReactSharedInternals.S;\n    ReactSharedInternals.S = function(transition, returnValue) {\n        \"object\" === typeof returnValue && null !== returnValue && \"function\" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);\n        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);\n    };\n    var resumedCache = createCursor(null), didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n    var offscreenSubtreeIsHidden = !1, offscreenSubtreeWasHidden = !1, needsFormReset = !1, PossiblyWeakSet = \"function\" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, shouldFireAfterActiveInstanceBlur = !1, hostParent = null, hostParentIsContainer = !1, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {\n        getCacheForType: function(resourceType) {\n            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);\n            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));\n            return cacheForType;\n        },\n        getOwner: function() {\n            return current;\n        }\n    }, COMPONENT_TYPE = 0, HAS_PSEUDO_CLASS_TYPE = 1, ROLE_TYPE = 2, TEST_NAME_TYPE = 3, TEXT_TYPE = 4;\n    if (\"function\" === typeof Symbol && Symbol.for) {\n        var symbolFor = Symbol.for;\n        COMPONENT_TYPE = symbolFor(\"selector.component\");\n        HAS_PSEUDO_CLASS_TYPE = symbolFor(\"selector.has_pseudo_class\");\n        ROLE_TYPE = symbolFor(\"selector.role\");\n        TEST_NAME_TYPE = symbolFor(\"selector.test_id\");\n        TEXT_TYPE = symbolFor(\"selector.text\");\n    }\n    var commitHooks = [], PossiblyWeakMap = \"function\" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootCompleted = 5, RootDidNotComplete = 6, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = !1, workInProgressRootIsPrerendering = !1, workInProgressRootDidAttachPingListener = !1, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = !1, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = 0, pendingPassiveEffectsRemainingLanes = 0, pendingPassiveTransitions = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = !1, didScheduleUpdateDuringPassiveEffects = !1, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = !1, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = !1;\n    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n    var fakeActCallbackNode = {}, resolveFamily = null, failedBoundaries = null;\n    var hasBadMapPolyfill = !1;\n    try {\n        var nonExtensibleObject = Object.preventExtensions({});\n        new Map([\n            [\n                nonExtensibleObject,\n                null\n            ]\n        ]);\n        new Set([\n            nonExtensibleObject\n        ]);\n    } catch (e) {\n        hasBadMapPolyfill = !0;\n    }\n    var didWarnAboutNestedUpdates = !1;\n    var didWarnAboutFindNodeInStrictMode = {};\n    var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;\n    overrideHookState = function(fiber, id, path, value) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateDeletePath = function(fiber, id, path) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n        id = findHook(fiber, id);\n        null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));\n    };\n    overrideProps = function(fiber, path, value) {\n        fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsDeletePath = function(fiber, path) {\n        fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsRenamePath = function(fiber, oldPath, newPath) {\n        fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        oldPath = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);\n    };\n    scheduleUpdate = function(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    };\n    setErrorHandler = function(newShouldErrorImpl) {\n        shouldErrorImpl = newShouldErrorImpl;\n    };\n    setSuspenseHandler = function(newShouldSuspendImpl) {\n        shouldSuspendImpl = newShouldSuspendImpl;\n    };\n    exports.attemptContinuousHydration = function(fiber) {\n        if (13 === fiber.tag) {\n            var root = enqueueConcurrentRenderForLane(fiber, 67108864);\n            null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);\n            markRetryLaneIfNotHydrated(fiber, 67108864);\n        }\n    };\n    exports.attemptHydrationAtCurrentPriority = function(fiber) {\n        if (13 === fiber.tag) {\n            var lane = requestUpdateLane(fiber), root = enqueueConcurrentRenderForLane(fiber, lane);\n            null !== root && scheduleUpdateOnFiber(root, fiber, lane);\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n    };\n    exports.attemptSynchronousHydration = function(fiber) {\n        switch(fiber.tag){\n            case 3:\n                fiber = fiber.stateNode;\n                if (fiber.current.memoizedState.isDehydrated) {\n                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);\n                    if (0 !== lanes) {\n                        fiber.pendingLanes |= 2;\n                        for(fiber.entangledLanes |= 2; lanes;){\n                            var lane = 1 << 31 - clz32(lanes);\n                            fiber.entanglements[1] |= lane;\n                            lanes &= ~lane;\n                        }\n                        ensureRootIsScheduled(fiber);\n                        (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, !1));\n                    }\n                }\n                break;\n            case 13:\n                lanes = enqueueConcurrentRenderForLane(fiber, 2), null !== lanes && scheduleUpdateOnFiber(lanes, fiber, 2), flushSyncWork(), markRetryLaneIfNotHydrated(fiber, 2);\n        }\n    };\n    exports.batchedUpdates = function(fn, a) {\n        return fn(a);\n    };\n    exports.createComponentSelector = function(component) {\n        return {\n            $$typeof: COMPONENT_TYPE,\n            value: component\n        };\n    };\n    exports.createContainer = function(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks) {\n        return createFiberRoot(containerInfo, tag, !1, null, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);\n    };\n    exports.createHasPseudoClassSelector = function(selectors) {\n        return {\n            $$typeof: HAS_PSEUDO_CLASS_TYPE,\n            value: selectors\n        };\n    };\n    exports.createHydrationContainer = function(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n        initialChildren = createFiberRoot(containerInfo, tag, !0, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);\n        initialChildren.context = getContextForSubtree(null);\n        containerInfo = initialChildren.current;\n        tag = requestUpdateLane(containerInfo);\n        hydrationCallbacks = createUpdate(tag);\n        hydrationCallbacks.callback = void 0 !== callback && null !== callback ? callback : null;\n        enqueueUpdate(containerInfo, hydrationCallbacks, tag);\n        initialChildren.current.lanes = tag;\n        markRootUpdated$1(initialChildren, tag);\n        ensureRootIsScheduled(initialChildren);\n        return initialChildren;\n    };\n    exports.createPortal = function(children, containerInfo, implementation) {\n        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\n        try {\n            testStringCoercion(key);\n            var JSCompiler_inline_result = !1;\n        } catch (e$6) {\n            JSCompiler_inline_result = !0;\n        }\n        JSCompiler_inline_result && (console.error(\"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\", \"function\" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || \"Object\"), testStringCoercion(key));\n        return {\n            $$typeof: REACT_PORTAL_TYPE,\n            key: null == key ? null : \"\" + key,\n            children: children,\n            containerInfo: containerInfo,\n            implementation: implementation\n        };\n    };\n    exports.createRoleSelector = function(role) {\n        return {\n            $$typeof: ROLE_TYPE,\n            value: role\n        };\n    };\n    exports.createTestNameSelector = function(id) {\n        return {\n            $$typeof: TEST_NAME_TYPE,\n            value: id\n        };\n    };\n    exports.createTextSelector = function(text) {\n        return {\n            $$typeof: TEXT_TYPE,\n            value: text\n        };\n    };\n    exports.defaultOnCaughtError = function(error, errorInfo) {\n        var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component.\" : \"The above error occurred in one of your React components.\", recreateMessage = \"React will try to recreate this component tree from scratch using the error boundary you provided, \" + ((errorBoundaryName || \"Anonymous\") + \".\"), prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : \"\";\n        ReactSharedInternals.getCurrentStack = function() {\n            return componentStack;\n        };\n        try {\n            \"object\" === typeof error && null !== error && \"string\" === typeof error.environmentName ? bindToConsole(\"error\", [\n                \"%o\\n\\n%s\\n\\n%s\\n\",\n                error,\n                componentNameMessage,\n                recreateMessage\n            ], error.environmentName)() : console.error(\"%o\\n\\n%s\\n\\n%s\\n\", error, componentNameMessage, recreateMessage);\n        } finally{\n            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n        }\n    };\n    exports.defaultOnRecoverableError = function(error) {\n        reportGlobalError(error);\n    };\n    exports.defaultOnUncaughtError = function(error, errorInfo) {\n        reportGlobalError(error);\n        error = componentName ? \"An error occurred in the <\" + componentName + \"> component.\" : \"An error occurred in one of your React components.\";\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : \"\";\n        ReactSharedInternals.getCurrentStack = function() {\n            return componentStack;\n        };\n        try {\n            console.warn(\"%s\\n\\n%s\\n\", error, \"Consider adding an error boundary to your tree to customize error handling behavior.\\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries.\");\n        } finally{\n            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n        }\n    };\n    exports.deferredUpdates = function(fn) {\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            return setCurrentUpdatePriority(32), ReactSharedInternals.T = null, fn();\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition;\n        }\n    };\n    exports.discreteUpdates = function(fn, a, b, c, d) {\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            return setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn(a, b, c, d);\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS);\n        }\n    };\n    exports.findAllNodes = findAllNodes;\n    exports.findBoundingRects = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        selectors = findAllNodes(hostRoot, selectors);\n        hostRoot = [];\n        for(var i = 0; i < selectors.length; i++)hostRoot.push(getBoundingRect(selectors[i]));\n        for(selectors = hostRoot.length - 1; 0 < selectors; selectors--){\n            i = hostRoot[selectors];\n            for(var targetLeft = i.x, targetRight = targetLeft + i.width, targetTop = i.y, targetBottom = targetTop + i.height, j = selectors - 1; 0 <= j; j--)if (selectors !== j) {\n                var otherRect = hostRoot[j], otherLeft = otherRect.x, otherRight = otherLeft + otherRect.width, otherTop = otherRect.y, otherBottom = otherTop + otherRect.height;\n                if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n                    hostRoot.splice(selectors, 1);\n                    break;\n                } else if (!(targetLeft !== otherLeft || i.width !== otherRect.width || otherBottom < targetTop || otherTop > targetBottom)) {\n                    otherTop > targetTop && (otherRect.height += otherTop - targetTop, otherRect.y = targetTop);\n                    otherBottom < targetBottom && (otherRect.height = targetBottom - otherTop);\n                    hostRoot.splice(selectors, 1);\n                    break;\n                } else if (!(targetTop !== otherTop || i.height !== otherRect.height || otherRight < targetLeft || otherLeft > targetRight)) {\n                    otherLeft > targetLeft && (otherRect.width += otherLeft - targetLeft, otherRect.x = targetLeft);\n                    otherRight < targetRight && (otherRect.width = targetRight - otherLeft);\n                    hostRoot.splice(selectors, 1);\n                    break;\n                }\n            }\n        }\n        return hostRoot;\n    };\n    exports.findHostInstance = function(component) {\n        var fiber = component._reactInternals;\n        if (void 0 === fiber) {\n            if (\"function\" === typeof component.render) throw Error(\"Unable to find node on an unmounted component.\");\n            component = Object.keys(component).join(\",\");\n            throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + component);\n        }\n        component = findCurrentHostFiber(fiber);\n        return null === component ? null : getPublicInstance(component.stateNode);\n    };\n    exports.findHostInstanceWithNoPortals = function(fiber) {\n        fiber = findCurrentFiberUsingSlowPath(fiber);\n        fiber = null !== fiber ? findCurrentHostFiberWithNoPortalsImpl(fiber) : null;\n        return null === fiber ? null : getPublicInstance(fiber.stateNode);\n    };\n    exports.findHostInstanceWithWarning = function(component, methodName) {\n        var fiber = component._reactInternals;\n        if (void 0 === fiber) {\n            if (\"function\" === typeof component.render) throw Error(\"Unable to find node on an unmounted component.\");\n            component = Object.keys(component).join(\",\");\n            throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + component);\n        }\n        component = findCurrentHostFiber(fiber);\n        if (null === component) return null;\n        if (component.mode & 8) {\n            var componentName = getComponentNameFromFiber(fiber) || \"Component\";\n            didWarnAboutFindNodeInStrictMode[componentName] || (didWarnAboutFindNodeInStrictMode[componentName] = !0, runWithFiberInDEV(component, function() {\n                fiber.mode & 8 ? console.error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node\", methodName, methodName, componentName) : console.error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node\", methodName, methodName, componentName);\n            }));\n        }\n        return getPublicInstance(component.stateNode);\n    };\n    exports.flushPassiveEffects = flushPassiveEffects;\n    exports.flushSyncFromReconciler = function(fn) {\n        var prevExecutionContext = executionContext;\n        executionContext |= 1;\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            if (setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn) return fn();\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext = prevExecutionContext, (executionContext & (RenderContext | CommitContext)) === NoContext && flushSyncWorkAcrossRoots_impl(0, !1);\n        }\n    };\n    exports.flushSyncWork = flushSyncWork;\n    exports.focusWithin = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        hostRoot = findFiberRootForHostRoot(hostRoot);\n        selectors = findPaths(hostRoot, selectors);\n        selectors = Array.from(selectors);\n        for(hostRoot = 0; hostRoot < selectors.length;){\n            var fiber = selectors[hostRoot++], tag = fiber.tag;\n            if (!isHiddenSubtree(fiber)) {\n                if ((5 === tag || 26 === tag || 27 === tag) && setFocusIfFocusable(fiber.stateNode)) return !0;\n                for(fiber = fiber.child; null !== fiber;)selectors.push(fiber), fiber = fiber.sibling;\n            }\n        }\n        return !1;\n    };\n    exports.getFindAllNodesFailureDescription = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        var maxSelectorIndex = 0, matchedNames = [];\n        hostRoot = [\n            findFiberRootForHostRoot(hostRoot),\n            0\n        ];\n        for(var index = 0; index < hostRoot.length;){\n            var fiber = hostRoot[index++], tag = fiber.tag, selectorIndex = hostRoot[index++], selector = selectors[selectorIndex];\n            if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {\n                if (matchSelector(fiber, selector) && (matchedNames.push(selectorToString(selector)), selectorIndex++, selectorIndex > maxSelectorIndex && (maxSelectorIndex = selectorIndex)), selectorIndex < selectors.length) for(fiber = fiber.child; null !== fiber;)hostRoot.push(fiber, selectorIndex), fiber = fiber.sibling;\n            }\n        }\n        if (maxSelectorIndex < selectors.length) {\n            for(hostRoot = []; maxSelectorIndex < selectors.length; maxSelectorIndex++)hostRoot.push(selectorToString(selectors[maxSelectorIndex]));\n            return \"findAllNodes was able to match part of the selector:\\n  \" + (matchedNames.join(\" > \") + \"\\n\\nNo matching component was found for:\\n  \") + hostRoot.join(\" > \");\n        }\n        return null;\n    };\n    exports.getPublicRootInstance = function(container) {\n        container = container.current;\n        if (!container.child) return null;\n        switch(container.child.tag){\n            case 27:\n            case 5:\n                return getPublicInstance(container.child.stateNode);\n            default:\n                return container.child.stateNode;\n        }\n    };\n    exports.injectIntoDevTools = function() {\n        var internals = {\n            bundleType: 1,\n            version: rendererVersion,\n            rendererPackageName: rendererPackageName,\n            currentDispatcherRef: ReactSharedInternals,\n            findFiberByHostInstance: getInstanceFromNode,\n            reconcilerVersion: \"19.0.0\"\n        };\n        null !== extraDevToolsConfig && (internals.rendererConfig = extraDevToolsConfig);\n        internals.overrideHookState = overrideHookState;\n        internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n        internals.overrideHookStateRenamePath = overrideHookStateRenamePath;\n        internals.overrideProps = overrideProps;\n        internals.overridePropsDeletePath = overridePropsDeletePath;\n        internals.overridePropsRenamePath = overridePropsRenamePath;\n        internals.scheduleUpdate = scheduleUpdate;\n        internals.setErrorHandler = setErrorHandler;\n        internals.setSuspenseHandler = setSuspenseHandler;\n        internals.scheduleRefresh = scheduleRefresh;\n        internals.scheduleRoot = scheduleRoot;\n        internals.setRefreshHandler = setRefreshHandler;\n        internals.getCurrentFiber = getCurrentFiberForDevTools;\n        internals.getLaneLabelMap = getLaneLabelMap;\n        internals.injectProfilingHooks = injectProfilingHooks;\n        return injectInternals(internals);\n    };\n    exports.isAlreadyRendering = function() {\n        return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n    };\n    exports.observeVisibleRects = function(hostRoot, selectors, callback, options) {\n        function commitHook() {\n            var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n            instanceRoots.forEach(function(target) {\n                0 > nextInstanceRoots.indexOf(target) && unobserve(target);\n            });\n            nextInstanceRoots.forEach(function(target) {\n                0 > instanceRoots.indexOf(target) && observe(target);\n            });\n        }\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        var instanceRoots = findAllNodes(hostRoot, selectors);\n        callback = setupIntersectionObserver(instanceRoots, callback, options);\n        var disconnect = callback.disconnect, observe = callback.observe, unobserve = callback.unobserve;\n        commitHooks.push(commitHook);\n        return {\n            disconnect: function() {\n                var index = commitHooks.indexOf(commitHook);\n                0 <= index && commitHooks.splice(index, 1);\n                disconnect();\n            }\n        };\n    };\n    exports.shouldError = function(fiber) {\n        return shouldErrorImpl(fiber);\n    };\n    exports.shouldSuspend = function(fiber) {\n        return shouldSuspendImpl(fiber);\n    };\n    exports.startHostTransition = function(formFiber, pendingState, action, formData) {\n        if (5 !== formFiber.tag) throw Error(\"Expected the form instance to be a HostComponent. This is a bug in React.\");\n        var queue = ensureFormComponentIsStateful(formFiber).queue;\n        startTransition(formFiber, queue, pendingState, NotPendingTransition, null === action ? noop : function() {\n            null === ReactSharedInternals.T && console.error(\"requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.\");\n            var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;\n            dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane(formFiber));\n            return action(formData);\n        });\n    };\n    exports.updateContainer = function(element, container, parentComponent, callback) {\n        var current = container.current, lane = requestUpdateLane(current);\n        updateContainerImpl(current, lane, element, container, parentComponent, callback);\n        return lane;\n    };\n    exports.updateContainerSync = updateContainerSync;\n    return exports;\n}, module.exports[\"default\"] = module.exports, Object.defineProperty(module.exports, \"__esModule\", {\n    value: !0\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVZO0FBQ2IsS0EyTm9ELElBMU5qRCxRQUFRQyxPQUFPLEdBQUcsU0FBVUMsU0FBUztJQUNwQyxTQUFTQyxTQUFTQyxLQUFLLEVBQUVDLEVBQUU7UUFDekIsSUFBS0QsUUFBUUEsTUFBTUUsYUFBYSxFQUFFLFNBQVNGLFNBQVMsSUFBSUMsSUFDdEQsUUFBU0QsTUFBTUcsSUFBSSxFQUFHRjtRQUN4QixPQUFPRDtJQUNUO0lBQ0EsU0FBU0ksZ0JBQWdCQyxHQUFHLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxLQUFLO1FBQzlDLElBQUlELFNBQVNELEtBQUtHLE1BQU0sRUFBRSxPQUFPRDtRQUNqQyxJQUFJRSxNQUFNSixJQUFJLENBQUNDLE1BQU0sRUFDbkJJLFVBQVVDLFlBQVlQLE9BQU9BLElBQUlRLEtBQUssS0FBS0MsT0FBTyxDQUFDLEdBQUdUO1FBQ3hETSxPQUFPLENBQUNELElBQUksR0FBR04sZ0JBQWdCQyxHQUFHLENBQUNLLElBQUksRUFBRUosTUFBTUMsUUFBUSxHQUFHQztRQUMxRCxPQUFPRztJQUNUO0lBQ0EsU0FBU0ksZUFBZVYsR0FBRyxFQUFFVyxPQUFPLEVBQUVDLE9BQU87UUFDM0MsSUFBSUQsUUFBUVAsTUFBTSxLQUFLUSxRQUFRUixNQUFNLEVBQ25DUyxRQUFRQyxJQUFJLENBQUM7YUFDVjtZQUNILElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxRQUFRUixNQUFNLEdBQUcsR0FBR1csSUFDdEMsSUFBSUosT0FBTyxDQUFDSSxFQUFFLEtBQUtILE9BQU8sQ0FBQ0csRUFBRSxFQUFFO2dCQUM3QkYsUUFBUUMsSUFBSSxDQUNWO2dCQUVGO1lBQ0Y7WUFDRixPQUFPRSxtQkFBbUJoQixLQUFLVyxTQUFTQyxTQUFTO1FBQ25EO0lBQ0Y7SUFDQSxT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QXFCdXRCLENBQUMsSUFDN0J0MEIsUUFBUWdDLEtBQUssQ0FDWDtZQUVKLElBQUl3d0Qsa0JBQ0ZsNkIsOEJBQThCQyxXQUFXdDVCLElBQUksQ0FBQ3FiLEtBQUs7WUFDckQ4ZCx5QkFDRUcsV0FDQWk2QixpQkFDQSxDQUFDLEdBQ0RuNkIsa0JBQWtCRTtZQUVwQixPQUFPakksT0FBT2lpQztRQUNoQjtJQUVSO0lBQ0E1ekQsUUFBUTh6RCxlQUFlLEdBQUcsU0FDeEJ6eEQsT0FBTyxFQUNQMnBDLFNBQVMsRUFDVHNhLGVBQWUsRUFDZjk3QyxRQUFRO1FBRVIsSUFBSXZILFVBQVUrb0MsVUFBVS9vQyxPQUFPLEVBQzdCK0osT0FBTzBzQixrQkFBa0J6MkI7UUFDM0JzakQsb0JBQ0V0akQsU0FDQStKLE1BQ0EzSyxTQUNBMnBDLFdBQ0FzYSxpQkFDQTk3QztRQUVGLE9BQU93QztJQUNUO0lBQ0FoTixRQUFRd0MsbUJBQW1CLEdBQUdBO0lBQzlCLE9BQU94QztBQUNULEdBQ0NELHlCQUFzQixHQUFHQSxPQUFPQyxPQUFPLEVBQ3hDZ0gsT0FBT3lCLGNBQWMsQ0FBQzFJLE9BQU9DLE9BQU8sRUFBRSxjQUFjO0lBQUVXLE9BQU8sQ0FBQztBQUFFLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcRWdvZm94eHhcXERvY3VtZW50c1xccG9ydGZvbGlvLXdlYnNpdGVcXG5vZGVfbW9kdWxlc1xccmVhY3QtcmVjb25jaWxlclxcY2pzXFxyZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gICgobW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoJCQkY29uZmlnKSB7XG4gICAgZnVuY3Rpb24gZmluZEhvb2soZmliZXIsIGlkKSB7XG4gICAgICBmb3IgKGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTsgbnVsbCAhPT0gZmliZXIgJiYgMCA8IGlkOyApXG4gICAgICAgIChmaWJlciA9IGZpYmVyLm5leHQpLCBpZC0tO1xuICAgICAgcmV0dXJuIGZpYmVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5V2l0aFNldEltcGwob2JqLCBwYXRoLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkgcmV0dXJuIHZhbHVlO1xuICAgICAgdmFyIGtleSA9IHBhdGhbaW5kZXhdLFxuICAgICAgICB1cGRhdGVkID0gaXNBcnJheUltcGwob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuICAgICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXRJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEsIHZhbHVlKTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5V2l0aFJlbmFtZShvYmosIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICAgIGlmIChvbGRQYXRoLmxlbmd0aCAhPT0gbmV3UGF0aC5sZW5ndGgpXG4gICAgICAgIGNvbnNvbGUud2FybihcImNvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyBvZiB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdQYXRoLmxlbmd0aCAtIDE7IGkrKylcbiAgICAgICAgICBpZiAob2xkUGF0aFtpXSAhPT0gbmV3UGF0aFtpXSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcImNvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyB0byBiZSB0aGUgc2FtZSBleGNlcHQgZm9yIHRoZSBkZWVwZXN0IGtleVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcHlXaXRoUmVuYW1lSW1wbChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5V2l0aFJlbmFtZUltcGwob2JqLCBvbGRQYXRoLCBuZXdQYXRoLCBpbmRleCkge1xuICAgICAgdmFyIG9sZEtleSA9IG9sZFBhdGhbaW5kZXhdLFxuICAgICAgICB1cGRhdGVkID0gaXNBcnJheUltcGwob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuICAgICAgaW5kZXggKyAxID09PSBvbGRQYXRoLmxlbmd0aFxuICAgICAgICA/ICgodXBkYXRlZFtuZXdQYXRoW2luZGV4XV0gPSB1cGRhdGVkW29sZEtleV0pLFxuICAgICAgICAgIGlzQXJyYXlJbXBsKHVwZGF0ZWQpXG4gICAgICAgICAgICA/IHVwZGF0ZWQuc3BsaWNlKG9sZEtleSwgMSlcbiAgICAgICAgICAgIDogZGVsZXRlIHVwZGF0ZWRbb2xkS2V5XSlcbiAgICAgICAgOiAodXBkYXRlZFtvbGRLZXldID0gY29weVdpdGhSZW5hbWVJbXBsKFxuICAgICAgICAgICAgb2JqW29sZEtleV0sXG4gICAgICAgICAgICBvbGRQYXRoLFxuICAgICAgICAgICAgbmV3UGF0aCxcbiAgICAgICAgICAgIGluZGV4ICsgMVxuICAgICAgICAgICkpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoRGVsZXRlSW1wbChvYmosIHBhdGgsIGluZGV4KSB7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpbmRleF0sXG4gICAgICAgIHVwZGF0ZWQgPSBpc0FycmF5SW1wbChvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG4gICAgICBpZiAoaW5kZXggKyAxID09PSBwYXRoLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBpc0FycmF5SW1wbCh1cGRhdGVkKSA/IHVwZGF0ZWQuc3BsaWNlKGtleSwgMSkgOiBkZWxldGUgdXBkYXRlZFtrZXldLFxuICAgICAgICAgIHVwZGF0ZWRcbiAgICAgICAgKTtcbiAgICAgIHVwZGF0ZWRba2V5XSA9IGNvcHlXaXRoRGVsZXRlSW1wbChvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRTdXNwZW5kSW1wbCgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkRXJyb3JJbXBsKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgICAgIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVJvb3Qocm9vdCwgZWxlbWVudCkge1xuICAgICAgcm9vdC5jb250ZXh0ID09PSBlbXB0eUNvbnRleHRPYmplY3QgJiZcbiAgICAgICAgKHVwZGF0ZUNvbnRhaW5lclN5bmMoZWxlbWVudCwgcm9vdCwgbnVsbCwgbnVsbCksIGZsdXNoU3luY1dvcmsoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVmcmVzaChyb290LCB1cGRhdGUpIHtcbiAgICAgIGlmIChudWxsICE9PSByZXNvbHZlRmFtaWx5KSB7XG4gICAgICAgIHZhciBzdGFsZUZhbWlsaWVzID0gdXBkYXRlLnN0YWxlRmFtaWxpZXM7XG4gICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS51cGRhdGVkRmFtaWxpZXM7XG4gICAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShcbiAgICAgICAgICByb290LmN1cnJlbnQsXG4gICAgICAgICAgdXBkYXRlLFxuICAgICAgICAgIHN0YWxlRmFtaWxpZXNcbiAgICAgICAgKTtcbiAgICAgICAgZmx1c2hTeW5jV29yaygpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRSZWZyZXNoSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICByZXNvbHZlRmFtaWx5ID0gaGFuZGxlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybkludmFsaWRIb29rQWNjZXNzKCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuIFlvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3J1bGVzLW9mLWhvb2tzXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgIGZ1bmN0aW9uIHdhcm5Gb3JNaXNzaW5nS2V5KCkge31cbiAgICBmdW5jdGlvbiBzZXRUb1NvcnRlZFN0cmluZyhzZXQpIHtcbiAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oXCIsIFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gbWF5YmVJdGVyYWJsZSB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBtYXliZUl0ZXJhYmxlID1cbiAgICAgICAgKE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICAgIG1heWJlSXRlcmFibGVbXCJAQGl0ZXJhdG9yXCJdO1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1heWJlSXRlcmFibGUgPyBtYXliZUl0ZXJhYmxlIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHtcbiAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmV0dXJuIFwiQ2FjaGVcIjtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIHJldHVybiBcIkRlaHlkcmF0ZWRGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZmliZXIgPSB0eXBlLnJlbmRlciksXG4gICAgICAgICAgICAoZmliZXIgPSBmaWJlci5kaXNwbGF5TmFtZSB8fCBmaWJlci5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSB8fFxuICAgICAgICAgICAgICAoXCJcIiAhPT0gZmliZXIgPyBcIkZvcndhcmRSZWYoXCIgKyBmaWJlciArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIFwiUm9vdFwiO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIFwiVGV4dFwiO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA/IFwiU3RyaWN0TW9kZVwiIDogXCJNb2RlXCI7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0dXJuIFwiT2Zmc2NyZWVuXCI7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICByZXR1cm4gXCJTY29wZVwiO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgcmV0dXJuIFwiVHJhY2luZ01hcmtlclwiO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgdHlwZSA9IGZpYmVyLl9kZWJ1Z0luZm87XG4gICAgICAgICAgaWYgKG51bGwgIT0gdHlwZSlcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0eXBlLmxlbmd0aCAtIDE7IDAgPD0gaTsgaS0tKVxuICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGVbaV0ubmFtZSkgcmV0dXJuIHR5cGVbaV0ubmFtZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gZmliZXIucmV0dXJuKVxuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIucmV0dXJuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiTGF6eVwiKTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZXR1cm4gKGZpYmVyID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmaWJlci50eXBlLCAhMSkpLCBmaWJlcjtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGZpYmVyID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmaWJlci50eXBlLnJlbmRlciwgITEpKSwgZmliZXJcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIChmaWJlciA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSwgITApKSwgZmliZXI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBcIlwiO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB2YXIgZGVidWdJbmZvID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnSW5mbztcbiAgICAgICAgICBpZiAoZGVidWdJbmZvKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlYnVnSW5mby5sZW5ndGggLSAxOyAwIDw9IGk7IGktLSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBkZWJ1Z0luZm9baV07XG4gICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgZW50cnkubmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBpbmZvLFxuICAgICAgICAgICAgICAgICAgZW52ID0gZW50cnkuZW52O1xuICAgICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcbiAgICAgICAgICAgICAgICAgIGVudHJ5Lm5hbWUgKyAoZW52ID8gXCIgW1wiICsgZW52ICsgXCJdXCIgOiBcIlwiKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaW5mbyA9IEpTQ29tcGlsZXJfdGVtcF9jb25zdCArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgICAgICB9IHdoaWxlICh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIiArIHgubWVzc2FnZSArIFwiXFxuXCIgKyB4LnN0YWNrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCkge1xuICAgICAgcmV0dXJuIG51bGwgPT09IGN1cnJlbnQgPyBcIlwiIDogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGN1cnJlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBydW5XaXRoRmliZXJJbkRFVihmaWJlciwgY2FsbGJhY2ssIGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9XG4gICAgICAgIG51bGwgPT09IGZpYmVyID8gbnVsbCA6IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgICBpc1JlbmRlcmluZyA9ICExO1xuICAgICAgY3VycmVudCA9IGZpYmVyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudCA9IHByZXZpb3VzRmliZXI7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJydW5XaXRoRmliZXJJbkRFViBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIGluIHByb2R1Y3Rpb24uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpIHtcbiAgICAgIHZhciBub2RlID0gZmliZXIsXG4gICAgICAgIG5lYXJlc3RNb3VudGVkID0gZmliZXI7XG4gICAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSBmb3IgKDsgbm9kZS5yZXR1cm47ICkgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZpYmVyID0gbm9kZTtcbiAgICAgICAgZG9cbiAgICAgICAgICAobm9kZSA9IGZpYmVyKSxcbiAgICAgICAgICAgIDAgIT09IChub2RlLmZsYWdzICYgNDA5OCkgJiYgKG5lYXJlc3RNb3VudGVkID0gbm9kZS5yZXR1cm4pLFxuICAgICAgICAgICAgKGZpYmVyID0gbm9kZS5yZXR1cm4pO1xuICAgICAgICB3aGlsZSAoZmliZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDMgPT09IG5vZGUudGFnID8gbmVhcmVzdE1vdW50ZWQgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgICAgIGlmIChnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSAhPT0gZmliZXIpXG4gICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpIHtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICBpZiAoIWFsdGVybmF0ZSkge1xuICAgICAgICBhbHRlcm5hdGUgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKTtcbiAgICAgICAgaWYgKG51bGwgPT09IGFsdGVybmF0ZSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgICAgIHJldHVybiBhbHRlcm5hdGUgIT09IGZpYmVyID8gbnVsbCA6IGZpYmVyO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgYSA9IGZpYmVyLCBiID0gYWx0ZXJuYXRlOyA7ICkge1xuICAgICAgICB2YXIgcGFyZW50QSA9IGEucmV0dXJuO1xuICAgICAgICBpZiAobnVsbCA9PT0gcGFyZW50QSkgYnJlYWs7XG4gICAgICAgIHZhciBwYXJlbnRCID0gcGFyZW50QS5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChudWxsID09PSBwYXJlbnRCKSB7XG4gICAgICAgICAgYiA9IHBhcmVudEEucmV0dXJuO1xuICAgICAgICAgIGlmIChudWxsICE9PSBiKSB7XG4gICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgICAgIGZvciAocGFyZW50QiA9IHBhcmVudEEuY2hpbGQ7IHBhcmVudEI7ICkge1xuICAgICAgICAgICAgaWYgKHBhcmVudEIgPT09IGEpIHJldHVybiBhc3NlcnRJc01vdW50ZWQocGFyZW50QSksIGZpYmVyO1xuICAgICAgICAgICAgaWYgKHBhcmVudEIgPT09IGIpIHJldHVybiBhc3NlcnRJc01vdW50ZWQocGFyZW50QSksIGFsdGVybmF0ZTtcbiAgICAgICAgICAgIHBhcmVudEIgPSBwYXJlbnRCLnNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSAoYSA9IHBhcmVudEEpLCAoYiA9IHBhcmVudEIpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBkaWRGaW5kQ2hpbGQgPSAhMSwgX2NoaWxkID0gcGFyZW50QS5jaGlsZDsgX2NoaWxkOyApIHtcbiAgICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgICAgZGlkRmluZENoaWxkID0gITA7XG4gICAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgICAgICBmb3IgKF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7IF9jaGlsZDsgKSB7XG4gICAgICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICAgICAgZGlkRmluZENoaWxkID0gITA7XG4gICAgICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRpZEZpbmRDaGlsZClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuYWx0ZXJuYXRlICE9PSBiKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnMnIGFsdGVybmF0ZXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKDMgIT09IGEudGFnKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgICByZXR1cm4gYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSA/IGZpYmVyIDogYWx0ZXJuYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gcGFyZW50ID8gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKHBhcmVudCkgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwobm9kZSkge1xuICAgICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICAgICAgaWYgKDUgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcgfHwgNiA9PT0gdGFnKSByZXR1cm4gbm9kZTtcbiAgICAgIGZvciAobm9kZSA9IG5vZGUuY2hpbGQ7IG51bGwgIT09IG5vZGU7ICkge1xuICAgICAgICB0YWcgPSBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwobm9kZSk7XG4gICAgICAgIGlmIChudWxsICE9PSB0YWcpIHJldHVybiB0YWc7XG4gICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChub2RlKSB7XG4gICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZyB8fCA2ID09PSB0YWcpIHJldHVybiBub2RlO1xuICAgICAgZm9yIChub2RlID0gbm9kZS5jaGlsZDsgbnVsbCAhPT0gbm9kZTsgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICA0ICE9PSBub2RlLnRhZyAmJlxuICAgICAgICAgICgodGFnID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChub2RlKSksIG51bGwgIT09IHRhZylcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHsgY3VycmVudDogZGVmYXVsdFZhbHVlIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcChjdXJzb3IsIGZpYmVyKSB7XG4gICAgICAwID4gaW5kZXgkanNjb21wJDBcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBwb3AuXCIpXG4gICAgICAgIDogKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4JGpzY29tcCQwXSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLlwiKSxcbiAgICAgICAgICAoY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4JGpzY29tcCQwXSksXG4gICAgICAgICAgKHZhbHVlU3RhY2tbaW5kZXgkanNjb21wJDBdID0gbnVsbCksXG4gICAgICAgICAgKGZpYmVyU3RhY2tbaW5kZXgkanNjb21wJDBdID0gbnVsbCksXG4gICAgICAgICAgaW5kZXgkanNjb21wJDAtLSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2goY3Vyc29yLCB2YWx1ZSwgZmliZXIpIHtcbiAgICAgIGluZGV4JGpzY29tcCQwKys7XG4gICAgICB2YWx1ZVN0YWNrW2luZGV4JGpzY29tcCQwXSA9IGN1cnNvci5jdXJyZW50O1xuICAgICAgZmliZXJTdGFja1tpbmRleCRqc2NvbXAkMF0gPSBmaWJlcjtcbiAgICAgIGN1cnNvci5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsejMyRmFsbGJhY2soeCkge1xuICAgICAgeCA+Pj49IDA7XG4gICAgICByZXR1cm4gMCA9PT0geCA/IDMyIDogKDMxIC0gKChsb2ckMSh4KSAvIExOMikgfCAwKSkgfCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMYWJlbEZvckxhbmUobGFuZSkge1xuICAgICAgaWYgKGxhbmUgJiAxKSByZXR1cm4gXCJTeW5jSHlkcmF0aW9uTGFuZVwiO1xuICAgICAgaWYgKGxhbmUgJiAyKSByZXR1cm4gXCJTeW5jXCI7XG4gICAgICBpZiAobGFuZSAmIDQpIHJldHVybiBcIklucHV0Q29udGludW91c0h5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiA4KSByZXR1cm4gXCJJbnB1dENvbnRpbnVvdXNcIjtcbiAgICAgIGlmIChsYW5lICYgMTYpIHJldHVybiBcIkRlZmF1bHRIeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgMzIpIHJldHVybiBcIkRlZmF1bHRcIjtcbiAgICAgIGlmIChsYW5lICYgNjQpIHJldHVybiBcIlRyYW5zaXRpb25IeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgNDE5NDE3NikgcmV0dXJuIFwiVHJhbnNpdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiA2MjkxNDU2MCkgcmV0dXJuIFwiUmV0cnlcIjtcbiAgICAgIGlmIChsYW5lICYgNjcxMDg4NjQpIHJldHVybiBcIlNlbGVjdGl2ZUh5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiAxMzQyMTc3MjgpIHJldHVybiBcIklkbGVIeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgMjY4NDM1NDU2KSByZXR1cm4gXCJJZGxlXCI7XG4gICAgICBpZiAobGFuZSAmIDUzNjg3MDkxMikgcmV0dXJuIFwiT2Zmc2NyZWVuXCI7XG4gICAgICBpZiAobGFuZSAmIDEwNzM3NDE4MjQpIHJldHVybiBcIkRlZmVycmVkXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gICAgICB2YXIgcGVuZGluZ1N5bmNMYW5lcyA9IGxhbmVzICYgNDI7XG4gICAgICBpZiAoMCAhPT0gcGVuZGluZ1N5bmNMYW5lcykgcmV0dXJuIHBlbmRpbmdTeW5jTGFuZXM7XG4gICAgICBzd2l0Y2ggKGxhbmVzICYgLWxhbmVzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByZXR1cm4gMTY7XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgIHJldHVybiA2NDtcbiAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgIGNhc2UgMjU2OlxuICAgICAgICBjYXNlIDUxMjpcbiAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICBjYXNlIDIwNDg6XG4gICAgICAgIGNhc2UgNDA5NjpcbiAgICAgICAgY2FzZSA4MTkyOlxuICAgICAgICBjYXNlIDE2Mzg0OlxuICAgICAgICBjYXNlIDMyNzY4OlxuICAgICAgICBjYXNlIDY1NTM2OlxuICAgICAgICBjYXNlIDEzMTA3MjpcbiAgICAgICAgY2FzZSAyNjIxNDQ6XG4gICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICBjYXNlIDEwNDg1NzY6XG4gICAgICAgIGNhc2UgMjA5NzE1MjpcbiAgICAgICAgICByZXR1cm4gbGFuZXMgJiA0MTk0MTc2O1xuICAgICAgICBjYXNlIDQxOTQzMDQ6XG4gICAgICAgIGNhc2UgODM4ODYwODpcbiAgICAgICAgY2FzZSAxNjc3NzIxNjpcbiAgICAgICAgY2FzZSAzMzU1NDQzMjpcbiAgICAgICAgICByZXR1cm4gbGFuZXMgJiA2MjkxNDU2MDtcbiAgICAgICAgY2FzZSA2NzEwODg2NDpcbiAgICAgICAgICByZXR1cm4gNjcxMDg4NjQ7XG4gICAgICAgIGNhc2UgMTM0MjE3NzI4OlxuICAgICAgICAgIHJldHVybiAxMzQyMTc3Mjg7XG4gICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICAgIHJldHVybiAyNjg0MzU0NTY7XG4gICAgICAgIGNhc2UgNTM2ODcwOTEyOlxuICAgICAgICAgIHJldHVybiA1MzY4NzA5MTI7XG4gICAgICAgIGNhc2UgMTA3Mzc0MTgyNDpcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TmV4dExhbmVzKHJvb3QsIHdpcExhbmVzKSB7XG4gICAgICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICBpZiAoMCA9PT0gcGVuZGluZ0xhbmVzKSByZXR1cm4gMDtcbiAgICAgIHZhciBuZXh0TGFuZXMgPSAwLFxuICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXMsXG4gICAgICAgIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcyxcbiAgICAgICAgd2FybUxhbmVzID0gcm9vdC53YXJtTGFuZXM7XG4gICAgICByb290ID0gMCAhPT0gcm9vdC5maW5pc2hlZExhbmVzO1xuICAgICAgdmFyIG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiAxMzQyMTc3Mjc7XG4gICAgICAwICE9PSBub25JZGxlUGVuZGluZ0xhbmVzXG4gICAgICAgID8gKChwZW5kaW5nTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzKSxcbiAgICAgICAgICAwICE9PSBwZW5kaW5nTGFuZXNcbiAgICAgICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBlbmRpbmdMYW5lcykpXG4gICAgICAgICAgICA6ICgocGluZ2VkTGFuZXMgJj0gbm9uSWRsZVBlbmRpbmdMYW5lcyksXG4gICAgICAgICAgICAgIDAgIT09IHBpbmdlZExhbmVzXG4gICAgICAgICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpKVxuICAgICAgICAgICAgICAgIDogcm9vdCB8fFxuICAgICAgICAgICAgICAgICAgKCh3YXJtTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgfndhcm1MYW5lcyksXG4gICAgICAgICAgICAgICAgICAwICE9PSB3YXJtTGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHdhcm1MYW5lcykpKSkpXG4gICAgICAgIDogKChub25JZGxlUGVuZGluZ0xhbmVzID0gcGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzKSxcbiAgICAgICAgICAwICE9PSBub25JZGxlUGVuZGluZ0xhbmVzXG4gICAgICAgICAgICA/IChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhub25JZGxlUGVuZGluZ0xhbmVzKSlcbiAgICAgICAgICAgIDogMCAhPT0gcGluZ2VkTGFuZXNcbiAgICAgICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpKVxuICAgICAgICAgICAgICA6IHJvb3QgfHxcbiAgICAgICAgICAgICAgICAoKHdhcm1MYW5lcyA9IHBlbmRpbmdMYW5lcyAmIH53YXJtTGFuZXMpLFxuICAgICAgICAgICAgICAgIDAgIT09IHdhcm1MYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHdhcm1MYW5lcykpKSk7XG4gICAgICByZXR1cm4gMCA9PT0gbmV4dExhbmVzXG4gICAgICAgID8gMFxuICAgICAgICA6IDAgIT09IHdpcExhbmVzICYmXG4gICAgICAgICAgICB3aXBMYW5lcyAhPT0gbmV4dExhbmVzICYmXG4gICAgICAgICAgICAwID09PSAod2lwTGFuZXMgJiBzdXNwZW5kZWRMYW5lcykgJiZcbiAgICAgICAgICAgICgoc3VzcGVuZGVkTGFuZXMgPSBuZXh0TGFuZXMgJiAtbmV4dExhbmVzKSxcbiAgICAgICAgICAgICh3YXJtTGFuZXMgPSB3aXBMYW5lcyAmIC13aXBMYW5lcyksXG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA+PSB3YXJtTGFuZXMgfHxcbiAgICAgICAgICAgICAgKDMyID09PSBzdXNwZW5kZWRMYW5lcyAmJiAwICE9PSAod2FybUxhbmVzICYgNDE5NDE3NikpKVxuICAgICAgICAgID8gd2lwTGFuZXNcbiAgICAgICAgICA6IG5leHRMYW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCByZW5kZXJMYW5lcykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgMCA9PT1cbiAgICAgICAgKHJvb3QucGVuZGluZ0xhbmVzICZcbiAgICAgICAgICB+KHJvb3Quc3VzcGVuZGVkTGFuZXMgJiB+cm9vdC5waW5nZWRMYW5lcykgJlxuICAgICAgICAgIHJlbmRlckxhbmVzKVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKSB7XG4gICAgICBzd2l0Y2ggKGxhbmUpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiBjdXJyZW50VGltZSArIDI1MDtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgIGNhc2UgMjU2OlxuICAgICAgICBjYXNlIDUxMjpcbiAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICBjYXNlIDIwNDg6XG4gICAgICAgIGNhc2UgNDA5NjpcbiAgICAgICAgY2FzZSA4MTkyOlxuICAgICAgICBjYXNlIDE2Mzg0OlxuICAgICAgICBjYXNlIDMyNzY4OlxuICAgICAgICBjYXNlIDY1NTM2OlxuICAgICAgICBjYXNlIDEzMTA3MjpcbiAgICAgICAgY2FzZSAyNjIxNDQ6XG4gICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICBjYXNlIDEwNDg1NzY6XG4gICAgICAgIGNhc2UgMjA5NzE1MjpcbiAgICAgICAgICByZXR1cm4gY3VycmVudFRpbWUgKyA1ZTM7XG4gICAgICAgIGNhc2UgNDE5NDMwNDpcbiAgICAgICAgY2FzZSA4Mzg4NjA4OlxuICAgICAgICBjYXNlIDE2Nzc3MjE2OlxuICAgICAgICBjYXNlIDMzNTU0NDMyOlxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgY2FzZSA2NzEwODg2NDpcbiAgICAgICAgY2FzZSAxMzQyMTc3Mjg6XG4gICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICBjYXNlIDUzNjg3MDkxMjpcbiAgICAgICAgY2FzZSAxMDczNzQxODI0OlxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIC0xXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKSB7XG4gICAgICB2YXIgbGFuZSA9IG5leHRUcmFuc2l0aW9uTGFuZTtcbiAgICAgIG5leHRUcmFuc2l0aW9uTGFuZSA8PD0gMTtcbiAgICAgIDAgPT09IChuZXh0VHJhbnNpdGlvbkxhbmUgJiA0MTk0MTc2KSAmJiAobmV4dFRyYW5zaXRpb25MYW5lID0gMTI4KTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGFpbU5leHRSZXRyeUxhbmUoKSB7XG4gICAgICB2YXIgbGFuZSA9IG5leHRSZXRyeUxhbmU7XG4gICAgICBuZXh0UmV0cnlMYW5lIDw8PSAxO1xuICAgICAgMCA9PT0gKG5leHRSZXRyeUxhbmUgJiA2MjkxNDU2MCkgJiYgKG5leHRSZXRyeUxhbmUgPSA0MTk0MzA0KTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVMYW5lTWFwKGluaXRpYWwpIHtcbiAgICAgIGZvciAodmFyIGxhbmVNYXAgPSBbXSwgaSA9IDA7IDMxID4gaTsgaSsrKSBsYW5lTWFwLnB1c2goaW5pdGlhbCk7XG4gICAgICByZXR1cm4gbGFuZU1hcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkJDEocm9vdCwgdXBkYXRlTGFuZSkge1xuICAgICAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gdXBkYXRlTGFuZTtcbiAgICAgIDI2ODQzNTQ1NiAhPT0gdXBkYXRlTGFuZSAmJlxuICAgICAgICAoKHJvb3Quc3VzcGVuZGVkTGFuZXMgPSAwKSxcbiAgICAgICAgKHJvb3QucGluZ2VkTGFuZXMgPSAwKSxcbiAgICAgICAgKHJvb3Qud2FybUxhbmVzID0gMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUm9vdEZpbmlzaGVkKFxuICAgICAgcm9vdCxcbiAgICAgIGZpbmlzaGVkTGFuZXMsXG4gICAgICByZW1haW5pbmdMYW5lcyxcbiAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lc1xuICAgICkge1xuICAgICAgdmFyIHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgIHJvb3QucGVuZGluZ0xhbmVzID0gcmVtYWluaW5nTGFuZXM7XG4gICAgICByb290LnN1c3BlbmRlZExhbmVzID0gMDtcbiAgICAgIHJvb3QucGluZ2VkTGFuZXMgPSAwO1xuICAgICAgcm9vdC53YXJtTGFuZXMgPSAwO1xuICAgICAgcm9vdC5leHBpcmVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gICAgICByb290LmVudGFuZ2xlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICAgICAgcm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgICAgIHJvb3Quc2hlbGxTdXNwZW5kQ291bnRlciA9IDA7XG4gICAgICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cyxcbiAgICAgICAgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXMsXG4gICAgICAgIGhpZGRlblVwZGF0ZXMgPSByb290LmhpZGRlblVwZGF0ZXM7XG4gICAgICBmb3IgKFxuICAgICAgICByZW1haW5pbmdMYW5lcyA9IHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgJiB+cmVtYWluaW5nTGFuZXM7XG4gICAgICAgIDAgPCByZW1haW5pbmdMYW5lcztcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIocmVtYWluaW5nTGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSA9IDA7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSAtMTtcbiAgICAgICAgdmFyIGhpZGRlblVwZGF0ZXNGb3JMYW5lID0gaGlkZGVuVXBkYXRlc1tpbmRleF07XG4gICAgICAgIGlmIChudWxsICE9PSBoaWRkZW5VcGRhdGVzRm9yTGFuZSlcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgaGlkZGVuVXBkYXRlc1tpbmRleF0gPSBudWxsLCBpbmRleCA9IDA7XG4gICAgICAgICAgICBpbmRleCA8IGhpZGRlblVwZGF0ZXNGb3JMYW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSBoaWRkZW5VcGRhdGVzRm9yTGFuZVtpbmRleF07XG4gICAgICAgICAgICBudWxsICE9PSB1cGRhdGUgJiYgKHVwZGF0ZS5sYW5lICY9IC01MzY4NzA5MTMpO1xuICAgICAgICAgIH1cbiAgICAgICAgcmVtYWluaW5nTGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgICAwICE9PSBzcGF3bmVkTGFuZSAmJiBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgMCk7XG4gICAgICAwICE9PSBzdXNwZW5kZWRSZXRyeUxhbmVzICYmXG4gICAgICAgIDAgPT09IHVwZGF0ZWRMYW5lcyAmJlxuICAgICAgICAwICE9PSByb290LnRhZyAmJlxuICAgICAgICAocm9vdC5zdXNwZW5kZWRMYW5lcyB8PVxuICAgICAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMgJiB+KHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgJiB+ZmluaXNoZWRMYW5lcykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgZW50YW5nbGVkTGFuZXMpIHtcbiAgICAgIHJvb3QucGVuZGluZ0xhbmVzIHw9IHNwYXduZWRMYW5lO1xuICAgICAgcm9vdC5zdXNwZW5kZWRMYW5lcyAmPSB+c3Bhd25lZExhbmU7XG4gICAgICB2YXIgc3Bhd25lZExhbmVJbmRleCA9IDMxIC0gY2x6MzIoc3Bhd25lZExhbmUpO1xuICAgICAgcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBzcGF3bmVkTGFuZTtcbiAgICAgIHJvb3QuZW50YW5nbGVtZW50c1tzcGF3bmVkTGFuZUluZGV4XSA9XG4gICAgICAgIHJvb3QuZW50YW5nbGVtZW50c1tzcGF3bmVkTGFuZUluZGV4XSB8XG4gICAgICAgIDEwNzM3NDE4MjQgfFxuICAgICAgICAoZW50YW5nbGVkTGFuZXMgJiA0MTk0MjE4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgZW50YW5nbGVkTGFuZXMpIHtcbiAgICAgIHZhciByb290RW50YW5nbGVkTGFuZXMgPSAocm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBlbnRhbmdsZWRMYW5lcyk7XG4gICAgICBmb3IgKHJvb3QgPSByb290LmVudGFuZ2xlbWVudHM7IHJvb3RFbnRhbmdsZWRMYW5lczsgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIocm9vdEVudGFuZ2xlZExhbmVzKSxcbiAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgICAgKGxhbmUgJiBlbnRhbmdsZWRMYW5lcykgfCAocm9vdFtpbmRleF0gJiBlbnRhbmdsZWRMYW5lcykgJiZcbiAgICAgICAgICAocm9vdFtpbmRleF0gfD0gZW50YW5nbGVkTGFuZXMpO1xuICAgICAgICByb290RW50YW5nbGVkTGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBmaWJlciwgbGFuZXMpIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudClcbiAgICAgICAgZm9yIChyb290ID0gcm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwOyAwIDwgbGFuZXM7ICkge1xuICAgICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICAgICAgcm9vdFtpbmRleF0uYWRkKGZpYmVyKTtcbiAgICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudClcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IHJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCxcbiAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICAgICAgMCA8IGxhbmVzO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpO1xuICAgICAgICAgIHJvb3QgPSAxIDw8IGluZGV4O1xuICAgICAgICAgIGluZGV4ID0gcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcFtpbmRleF07XG4gICAgICAgICAgMCA8IGluZGV4LnNpemUgJiZcbiAgICAgICAgICAgIChpbmRleC5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgICAobnVsbCAhPT0gYWx0ZXJuYXRlICYmIG1lbW9pemVkVXBkYXRlcnMuaGFzKGFsdGVybmF0ZSkpIHx8XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5hZGQoZmliZXIpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmRleC5jbGVhcigpKTtcbiAgICAgICAgICBsYW5lcyAmPSB+cm9vdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsYW5lc1RvRXZlbnRQcmlvcml0eShsYW5lcykge1xuICAgICAgbGFuZXMgJj0gLWxhbmVzO1xuICAgICAgcmV0dXJuIDIgPCBsYW5lc1xuICAgICAgICA/IDggPCBsYW5lc1xuICAgICAgICAgID8gMCAhPT0gKGxhbmVzICYgMTM0MjE3NzI3KVxuICAgICAgICAgICAgPyAzMlxuICAgICAgICAgICAgOiAyNjg0MzU0NTZcbiAgICAgICAgICA6IDhcbiAgICAgICAgOiAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXykgcmV0dXJuICExO1xuICAgICAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gICAgICBpZiAoaG9vay5pc0Rpc2FibGVkKSByZXR1cm4gITA7XG4gICAgICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcilcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayB3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvcmVhY3QtZGV2dG9vbHNcIlxuICAgICAgICAgICksXG4gICAgICAgICAgITBcbiAgICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIChyZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKSksIChpbmplY3RlZEhvb2sgPSBob29rKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcy5cIiwgZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob29rLmNoZWNrRENFID8gITAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Db21taXRSb290JDEocm9vdCwgZXZlbnRQcmlvcml0eSkge1xuICAgICAgaWYgKGluamVjdGVkSG9vayAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGRpZEVycm9yID0gMTI4ID09PSAocm9vdC5jdXJyZW50LmZsYWdzICYgMTI4KTtcbiAgICAgICAgICBzd2l0Y2ggKGV2ZW50UHJpb3JpdHkpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdmFyIHNjaGVkdWxlclByaW9yaXR5ID0gSW1tZWRpYXRlUHJpb3JpdHk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gTm9ybWFsUHJpb3JpdHkkMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI2ODQzNTQ1NjpcbiAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QoXG4gICAgICAgICAgICByZW5kZXJlcklELFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5LFxuICAgICAgICAgICAgZGlkRXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlc1wiLFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKG5ld0lzU3RyaWN0TW9kZSkge1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbG9nICYmXG4gICAgICAgIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlKG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgICBpZiAoaW5qZWN0ZWRIb29rICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKHJlbmRlcmVySUQsIG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAoKGhhc0xvZ2dlZEVycm9yID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzXCIsXG4gICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5qZWN0UHJvZmlsaW5nSG9va3MocHJvZmlsaW5nSG9va3MpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MgPSBwcm9maWxpbmdIb29rcztcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya0NvbW1pdFN0b3BwZWQoKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0b3BwZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RvcHBlZCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcikge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCkge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcykge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdGFydGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmVuZGVyU3RvcHBlZCgpIHtcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RvcHBlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSkge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAgIHJldHVybiAoeCA9PT0geSAmJiAoMCAhPT0geCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZSkge1xuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBDYXB0dXJlZFN0YWNrcy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAodm9pZCAwICE9PSBleGlzdGluZykgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICBzb3VyY2UgPSB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIHN0YWNrOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKVxuICAgICAgICB9O1xuICAgICAgICBDYXB0dXJlZFN0YWNrcy5zZXQodmFsdWUsIHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBzdGFjazogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgdG90YWxDaGlsZHJlbikge1xuICAgICAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gICAgICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXgrK10gPSB0cmVlRm9ya0NvdW50O1xuICAgICAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtQcm92aWRlcjtcbiAgICAgIHRyZWVGb3JrUHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHRyZWVGb3JrQ291bnQgPSB0b3RhbENoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICAgICAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gICAgICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0SWQ7XG4gICAgICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gICAgICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXI7XG4gICAgICB0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICAgICAgdmFyIGJhc2VMZW5ndGggPSAzMiAtIGNsejMyKGJhc2VJZFdpdGhMZWFkaW5nQml0KSAtIDE7XG4gICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmPSB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgdmFyIGxlbmd0aCA9IDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoO1xuICAgICAgaWYgKDMwIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSAoYmFzZUxlbmd0aCAlIDUpO1xuICAgICAgICBsZW5ndGggPSAoXG4gICAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgJlxuICAgICAgICAgICgoMSA8PCBudW1iZXJPZk92ZXJmbG93Qml0cykgLSAxKVxuICAgICAgICApLnRvU3RyaW5nKDMyKTtcbiAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgPj49IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICBiYXNlTGVuZ3RoIC09IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICB0cmVlQ29udGV4dElkID1cbiAgICAgICAgICAoMSA8PCAoMzIgLSBjbHozMih0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGgpKSB8XG4gICAgICAgICAgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHxcbiAgICAgICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdDtcbiAgICAgICAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IGxlbmd0aCArIHdvcmtJblByb2dyZXNzO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0cmVlQ29udGV4dElkID1cbiAgICAgICAgICAoMSA8PCBsZW5ndGgpIHwgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHwgYmFzZUlkV2l0aExlYWRpbmdCaXQpLFxuICAgICAgICAgICh0cmVlQ29udGV4dE92ZXJmbG93ID0gd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLnJldHVybiAmJlxuICAgICAgICAocHVzaFRyZWVGb3JrKHdvcmtJblByb2dyZXNzLCAxKSwgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgMSwgMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgZm9yICg7IHdvcmtJblByb2dyZXNzID09PSB0cmVlRm9ya1Byb3ZpZGVyOyApXG4gICAgICAgICh0cmVlRm9ya1Byb3ZpZGVyID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGwpLFxuICAgICAgICAgICh0cmVlRm9ya0NvdW50ID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGwpO1xuICAgICAgZm9yICg7IHdvcmtJblByb2dyZXNzID09PSB0cmVlQ29udGV4dFByb3ZpZGVyOyApXG4gICAgICAgICh0cmVlQ29udGV4dFByb3ZpZGVyID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF0pLFxuICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsKSxcbiAgICAgICAgICAodHJlZUNvbnRleHRPdmVyZmxvdyA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbCksXG4gICAgICAgICAgKHRyZWVDb250ZXh0SWQgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XSksXG4gICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuSWZOb3RIeWRyYXRpbmcoKSB7XG4gICAgICBpc0h5ZHJhdGluZyB8fFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gYmUgaHlkcmF0aW5nLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAgICAgbnVsbCA9PT0gYyAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsIG5leHRSb290SW5zdGFuY2UpIHtcbiAgICAgIHB1c2gocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTtcbiAgICAgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbnVsbCwgZmliZXIpO1xuICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcbiAgICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpIHtcbiAgICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgcG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEhvc3RDb250ZXh0KCkge1xuICAgICAgcmV0dXJuIHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hIb3N0Q29udGV4dChmaWJlcikge1xuICAgICAgbnVsbCAhPT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICBwdXNoKGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlKTtcbiAgICAgIGNvbnRleHQgIT09IG5leHRDb250ZXh0ICYmXG4gICAgICAgIChwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpLFxuICAgICAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dENvbnRleHQsIGZpYmVyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgICBjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ID09PSBmaWJlciAmJlxuICAgICAgICAocG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpLCBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKSk7XG4gICAgICBob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLmN1cnJlbnQgPT09IGZpYmVyICYmXG4gICAgICAgIChwb3AoaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciwgZmliZXIpLFxuICAgICAgICBpc1ByaW1hcnlSZW5kZXJlclxuICAgICAgICAgID8gKEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlID0gTm90UGVuZGluZ1RyYW5zaXRpb24pXG4gICAgICAgICAgOiAoSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUyID0gTm90UGVuZGluZ1RyYW5zaXRpb24pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZE5vdGFibGVOb2RlKG5vZGUsIGluZGVudCkge1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gbm9kZS5zZXJ2ZXJQcm9wcyAmJlxuICAgICAgICAwID09PSBub2RlLnNlcnZlclRhaWwubGVuZ3RoICYmXG4gICAgICAgIDEgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIDMgPCBub2RlLmRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgbm9kZS5kaXN0YW5jZUZyb21MZWFmID4gMTUgLSBpbmRlbnRcbiAgICAgICAgPyBmaW5kTm90YWJsZU5vZGUobm9kZS5jaGlsZHJlblswXSwgaW5kZW50KVxuICAgICAgICA6IG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluZGVudGF0aW9uKGluZGVudCkge1xuICAgICAgcmV0dXJuIFwiICBcIiArIFwiICBcIi5yZXBlYXQoaW5kZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkZWQoaW5kZW50KSB7XG4gICAgICByZXR1cm4gXCIrIFwiICsgXCIgIFwiLnJlcGVhdChpbmRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVkKGluZGVudCkge1xuICAgICAgcmV0dXJuIFwiLSBcIiArIFwiICBcIi5yZXBlYXQoaW5kZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVGaWJlclR5cGUoZmliZXIpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gZmliZXIudHlwZTtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByZXR1cm4gXCJMYXp5XCI7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJldHVybiAoZmliZXIgPSBmaWJlci50eXBlKSwgZmliZXIuZGlzcGxheU5hbWUgfHwgZmliZXIubmFtZSB8fCBudWxsO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZmliZXIgPSBmaWJlci50eXBlLnJlbmRlciksIGZpYmVyLmRpc3BsYXlOYW1lIHx8IGZpYmVyLm5hbWUgfHwgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gKGZpYmVyID0gZmliZXIudHlwZSksIGZpYmVyLmRpc3BsYXlOYW1lIHx8IGZpYmVyLm5hbWUgfHwgbnVsbDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVUZXh0Tm9kZShjb250ZW50LCBtYXhMZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZWVkc0VzY2FwaW5nLnRlc3QoY29udGVudClcbiAgICAgICAgPyAoKGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShjb250ZW50KSksXG4gICAgICAgICAgY29udGVudC5sZW5ndGggPiBtYXhMZW5ndGggLSAyXG4gICAgICAgICAgICA/IDggPiBtYXhMZW5ndGhcbiAgICAgICAgICAgICAgPyAne1wiLi4uXCJ9J1xuICAgICAgICAgICAgICA6IFwie1wiICsgY29udGVudC5zbGljZSgwLCBtYXhMZW5ndGggLSA3KSArICcuLi5cIn0nXG4gICAgICAgICAgICA6IFwie1wiICsgY29udGVudCArIFwifVwiKVxuICAgICAgICA6IGNvbnRlbnQubGVuZ3RoID4gbWF4TGVuZ3RoXG4gICAgICAgICAgPyA1ID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICA/ICd7XCIuLi5cIn0nXG4gICAgICAgICAgICA6IGNvbnRlbnQuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gMykgKyBcIi4uLlwiXG4gICAgICAgICAgOiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVRleHREaWZmKGNsaWVudFRleHQsIHNlcnZlclByb3BzLCBpbmRlbnQpIHtcbiAgICAgIHZhciBtYXhMZW5ndGggPSAxMjAgLSAyICogaW5kZW50O1xuICAgICAgaWYgKG51bGwgPT09IHNlcnZlclByb3BzKVxuICAgICAgICByZXR1cm4gYWRkZWQoaW5kZW50KSArIGRlc2NyaWJlVGV4dE5vZGUoY2xpZW50VGV4dCwgbWF4TGVuZ3RoKSArIFwiXFxuXCI7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNlcnZlclByb3BzKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGZpcnN0RGlmZiA9IDA7XG4gICAgICAgICAgZmlyc3REaWZmIDwgc2VydmVyUHJvcHMubGVuZ3RoICYmXG4gICAgICAgICAgZmlyc3REaWZmIDwgY2xpZW50VGV4dC5sZW5ndGggJiZcbiAgICAgICAgICBzZXJ2ZXJQcm9wcy5jaGFyQ29kZUF0KGZpcnN0RGlmZikgPT09XG4gICAgICAgICAgICBjbGllbnRUZXh0LmNoYXJDb2RlQXQoZmlyc3REaWZmKTtcbiAgICAgICAgICBmaXJzdERpZmYrK1xuICAgICAgICApO1xuICAgICAgICBmaXJzdERpZmYgPiBtYXhMZW5ndGggLSA4ICYmXG4gICAgICAgICAgMTAgPCBmaXJzdERpZmYgJiZcbiAgICAgICAgICAoKGNsaWVudFRleHQgPSBcIi4uLlwiICsgY2xpZW50VGV4dC5zbGljZShmaXJzdERpZmYgLSA4KSksXG4gICAgICAgICAgKHNlcnZlclByb3BzID0gXCIuLi5cIiArIHNlcnZlclByb3BzLnNsaWNlKGZpcnN0RGlmZiAtIDgpKSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYWRkZWQoaW5kZW50KSArXG4gICAgICAgICAgZGVzY3JpYmVUZXh0Tm9kZShjbGllbnRUZXh0LCBtYXhMZW5ndGgpICtcbiAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICByZW1vdmVkKGluZGVudCkgK1xuICAgICAgICAgIGRlc2NyaWJlVGV4dE5vZGUoc2VydmVyUHJvcHMsIG1heExlbmd0aCkgK1xuICAgICAgICAgIFwiXFxuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGluZGVudGF0aW9uKGluZGVudCkgKyBkZXNjcmliZVRleHROb2RlKGNsaWVudFRleHQsIG1heExlbmd0aCkgKyBcIlxcblwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvYmplY3ROYW1lKG9iamVjdCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgLmNhbGwob2JqZWN0KVxuICAgICAgICAucmVwbGFjZSgvXlxcW29iamVjdCAoLiopXFxdJC8sIGZ1bmN0aW9uIChtLCBwMCkge1xuICAgICAgICAgIHJldHVybiBwMDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVmFsdWUodmFsdWUsIG1heExlbmd0aCkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAodmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpLFxuICAgICAgICAgICAgdmFsdWUubGVuZ3RoID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICAgID8gNSA+IG1heExlbmd0aFxuICAgICAgICAgICAgICAgID8gJ1wiLi4uXCInXG4gICAgICAgICAgICAgICAgOiB2YWx1ZS5zbGljZSgwLCBtYXhMZW5ndGggLSA0KSArICcuLi5cIidcbiAgICAgICAgICAgICAgOiB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBpZiAobnVsbCA9PT0gdmFsdWUpIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwodmFsdWUpKSByZXR1cm4gXCJbLi4uXVwiO1xuICAgICAgICAgIGlmICh2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIChtYXhMZW5ndGggPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodmFsdWUudHlwZSkpXG4gICAgICAgICAgICAgID8gXCI8XCIgKyBtYXhMZW5ndGggKyBcIj5cIlxuICAgICAgICAgICAgICA6IFwiPC4uLj5cIjtcbiAgICAgICAgICB2YXIgbmFtZSA9IG9iamVjdE5hbWUodmFsdWUpO1xuICAgICAgICAgIGlmIChcIk9iamVjdFwiID09PSBuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJcIjtcbiAgICAgICAgICAgIG1heExlbmd0aCAtPSAyO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdmFsdWUpXG4gICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIganNvblByb3BOYW1lID0gSlNPTi5zdHJpbmdpZnkocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIGpzb25Qcm9wTmFtZSAhPT0gJ1wiJyArIHByb3BOYW1lICsgJ1wiJyAmJlxuICAgICAgICAgICAgICAgICAgKHByb3BOYW1lID0ganNvblByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGggLT0gcHJvcE5hbWUubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICBqc29uUHJvcE5hbWUgPSBkZXNjcmliZVZhbHVlKFxuICAgICAgICAgICAgICAgICAgdmFsdWVbcHJvcE5hbWVdLFxuICAgICAgICAgICAgICAgICAgMTUgPiBtYXhMZW5ndGggPyBtYXhMZW5ndGggOiAxNVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoIC09IGpzb25Qcm9wTmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKDAgPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIG5hbWUgKz0gXCJcIiA9PT0gbmFtZSA/IFwiLi4uXCIgOiBcIiwgLi4uXCI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmFtZSArPVxuICAgICAgICAgICAgICAgICAgKFwiXCIgPT09IG5hbWUgPyBcIlwiIDogXCIsXCIpICsgcHJvcE5hbWUgKyBcIjpcIiArIGpzb25Qcm9wTmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwie1wiICsgbmFtZSArIFwifVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIChtYXhMZW5ndGggPSB2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5uYW1lKVxuICAgICAgICAgICAgPyBcImZ1bmN0aW9uIFwiICsgbWF4TGVuZ3RoXG4gICAgICAgICAgICA6IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVQcm9wVmFsdWUodmFsdWUsIG1heExlbmd0aCkge1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCIgIT09IHR5cGVvZiB2YWx1ZSB8fCBuZWVkc0VzY2FwaW5nLnRlc3QodmFsdWUpXG4gICAgICAgID8gXCJ7XCIgKyBkZXNjcmliZVZhbHVlKHZhbHVlLCBtYXhMZW5ndGggLSAyKSArIFwifVwiXG4gICAgICAgIDogdmFsdWUubGVuZ3RoID4gbWF4TGVuZ3RoIC0gMlxuICAgICAgICAgID8gNSA+IG1heExlbmd0aFxuICAgICAgICAgICAgPyAnXCIuLi5cIidcbiAgICAgICAgICAgIDogJ1wiJyArIHZhbHVlLnNsaWNlKDAsIG1heExlbmd0aCAtIDUpICsgJy4uLlwiJ1xuICAgICAgICAgIDogJ1wiJyArIHZhbHVlICsgJ1wiJztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQodHlwZSwgcHJvcHMsIHJvd1ByZWZpeCkge1xuICAgICAgdmFyIHJlbWFpbmluZ1Jvd0xlbmd0aCA9IDEyMCAtIHJvd1ByZWZpeC5sZW5ndGggLSB0eXBlLmxlbmd0aCxcbiAgICAgICAgcHJvcGVydGllcyA9IFtdLFxuICAgICAgICBwcm9wTmFtZTtcbiAgICAgIGZvciAocHJvcE5hbWUgaW4gcHJvcHMpXG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgXCJjaGlsZHJlblwiICE9PSBwcm9wTmFtZSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBkZXNjcmliZVByb3BWYWx1ZShcbiAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSxcbiAgICAgICAgICAgIDEyMCAtIHJvd1ByZWZpeC5sZW5ndGggLSBwcm9wTmFtZS5sZW5ndGggLSAxXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZW1haW5pbmdSb3dMZW5ndGggLT0gcHJvcE5hbWUubGVuZ3RoICsgcHJvcFZhbHVlLmxlbmd0aCArIDI7XG4gICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3BOYW1lICsgXCI9XCIgKyBwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gMCA9PT0gcHJvcGVydGllcy5sZW5ndGhcbiAgICAgICAgPyByb3dQcmVmaXggKyBcIjxcIiArIHR5cGUgKyBcIj5cXG5cIlxuICAgICAgICA6IDAgPCByZW1haW5pbmdSb3dMZW5ndGhcbiAgICAgICAgICA/IHJvd1ByZWZpeCArIFwiPFwiICsgdHlwZSArIFwiIFwiICsgcHJvcGVydGllcy5qb2luKFwiIFwiKSArIFwiPlxcblwiXG4gICAgICAgICAgOiByb3dQcmVmaXggK1xuICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgdHlwZSArXG4gICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgIHJvd1ByZWZpeCArXG4gICAgICAgICAgICBcIiAgXCIgK1xuICAgICAgICAgICAgcHJvcGVydGllcy5qb2luKFwiXFxuXCIgKyByb3dQcmVmaXggKyBcIiAgXCIpICtcbiAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgcm93UHJlZml4ICtcbiAgICAgICAgICAgIFwiPlxcblwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVByb3BlcnRpZXNEaWZmKGNsaWVudE9iamVjdCwgc2VydmVyT2JqZWN0LCBpbmRlbnQpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gXCJcIixcbiAgICAgICAgcmVtYWluaW5nU2VydmVyUHJvcGVydGllcyA9IGFzc2lnbih7fSwgc2VydmVyT2JqZWN0KSxcbiAgICAgICAgcHJvcE5hbWU7XG4gICAgICBmb3IgKHByb3BOYW1lIGluIGNsaWVudE9iamVjdClcbiAgICAgICAgaWYgKGNsaWVudE9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICBkZWxldGUgcmVtYWluaW5nU2VydmVyUHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICAgICAgdmFyIG1heExlbmd0aCA9IDEyMCAtIDIgKiBpbmRlbnQgLSBwcm9wTmFtZS5sZW5ndGggLSAyLFxuICAgICAgICAgICAgY2xpZW50UHJvcFZhbHVlID0gZGVzY3JpYmVWYWx1ZShjbGllbnRPYmplY3RbcHJvcE5hbWVdLCBtYXhMZW5ndGgpO1xuICAgICAgICAgIHNlcnZlck9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSlcbiAgICAgICAgICAgID8gKChtYXhMZW5ndGggPSBkZXNjcmliZVZhbHVlKHNlcnZlck9iamVjdFtwcm9wTmFtZV0sIG1heExlbmd0aCkpLFxuICAgICAgICAgICAgICAocHJvcGVydGllcyArPVxuICAgICAgICAgICAgICAgIGFkZGVkKGluZGVudCkgKyBwcm9wTmFtZSArIFwiOiBcIiArIGNsaWVudFByb3BWYWx1ZSArIFwiXFxuXCIpLFxuICAgICAgICAgICAgICAocHJvcGVydGllcyArPVxuICAgICAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50KSArIHByb3BOYW1lICsgXCI6IFwiICsgbWF4TGVuZ3RoICsgXCJcXG5cIikpXG4gICAgICAgICAgICA6IChwcm9wZXJ0aWVzICs9XG4gICAgICAgICAgICAgICAgYWRkZWQoaW5kZW50KSArIHByb3BOYW1lICsgXCI6IFwiICsgY2xpZW50UHJvcFZhbHVlICsgXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgIGZvciAodmFyIF9wcm9wTmFtZSBpbiByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzKVxuICAgICAgICByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KF9wcm9wTmFtZSkgJiZcbiAgICAgICAgICAoKGNsaWVudE9iamVjdCA9IGRlc2NyaWJlVmFsdWUoXG4gICAgICAgICAgICByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzW19wcm9wTmFtZV0sXG4gICAgICAgICAgICAxMjAgLSAyICogaW5kZW50IC0gX3Byb3BOYW1lLmxlbmd0aCAtIDJcbiAgICAgICAgICApKSxcbiAgICAgICAgICAocHJvcGVydGllcyArPVxuICAgICAgICAgICAgcmVtb3ZlZChpbmRlbnQpICsgX3Byb3BOYW1lICsgXCI6IFwiICsgY2xpZW50T2JqZWN0ICsgXCJcXG5cIikpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRWxlbWVudERpZmYodHlwZSwgY2xpZW50UHJvcHMsIHNlcnZlclByb3BzLCBpbmRlbnQpIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIixcbiAgICAgICAgc2VydmVyUHJvcE5hbWVzID0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChwcm9wTmFtZSRqc2NvbXAkMCBpbiBzZXJ2ZXJQcm9wcylcbiAgICAgICAgc2VydmVyUHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUkanNjb21wJDApICYmXG4gICAgICAgICAgc2VydmVyUHJvcE5hbWVzLnNldChcbiAgICAgICAgICAgIHByb3BOYW1lJGpzY29tcCQwLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBwcm9wTmFtZSRqc2NvbXAkMFxuICAgICAgICAgICk7XG4gICAgICBpZiAoMSA9PT0gc2VydmVyUHJvcE5hbWVzLnNpemUgJiYgc2VydmVyUHJvcE5hbWVzLmhhcyhcImNoaWxkcmVuXCIpKVxuICAgICAgICBjb250ZW50ICs9IGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgY2xpZW50UHJvcHMsXG4gICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KVxuICAgICAgICApO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9wcm9wTmFtZTIgaW4gY2xpZW50UHJvcHMpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY2xpZW50UHJvcHMuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lMikgJiZcbiAgICAgICAgICAgIFwiY2hpbGRyZW5cIiAhPT0gX3Byb3BOYW1lMlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIG1heExlbmd0aCRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgMTIwIC0gMiAqIChpbmRlbnQgKyAxKSAtIF9wcm9wTmFtZTIubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgc2VydmVyUHJvcE5hbWUgPSBzZXJ2ZXJQcm9wTmFtZXMuZ2V0KF9wcm9wTmFtZTIudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBzZXJ2ZXJQcm9wTmFtZSkge1xuICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMuZGVsZXRlKF9wcm9wTmFtZTIudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgIHZhciBwcm9wTmFtZSRqc2NvbXAkMCA9IGNsaWVudFByb3BzW19wcm9wTmFtZTJdO1xuICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZSA9IHNlcnZlclByb3BzW3NlcnZlclByb3BOYW1lXTtcbiAgICAgICAgICAgICAgdmFyIGNsaWVudFByb3BWYWx1ZSA9IGRlc2NyaWJlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICAgIHByb3BOYW1lJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgIG1heExlbmd0aCRqc2NvbXAkMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBtYXhMZW5ndGgkanNjb21wJDAgPSBkZXNjcmliZVByb3BWYWx1ZShcbiAgICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZSxcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGgkanNjb21wJDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHByb3BOYW1lJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHByb3BOYW1lJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBzZXJ2ZXJQcm9wTmFtZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBzZXJ2ZXJQcm9wTmFtZSAmJlxuICAgICAgICAgICAgICBcIk9iamVjdFwiID09PSBvYmplY3ROYW1lKHByb3BOYW1lJGpzY29tcCQwKSAmJlxuICAgICAgICAgICAgICBcIk9iamVjdFwiID09PSBvYmplY3ROYW1lKHNlcnZlclByb3BOYW1lKSAmJlxuICAgICAgICAgICAgICAoMiA8IE9iamVjdC5rZXlzKHByb3BOYW1lJGpzY29tcCQwKS5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAyIDwgT2JqZWN0LmtleXMoc2VydmVyUHJvcE5hbWUpLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIC0xIDwgY2xpZW50UHJvcFZhbHVlLmluZGV4T2YoXCIuLi5cIikgfHxcbiAgICAgICAgICAgICAgICAtMSA8IG1heExlbmd0aCRqc2NvbXAkMC5pbmRleE9mKFwiLi4uXCIpKVxuICAgICAgICAgICAgICAgID8gKGNvbnRlbnQgKz1cbiAgICAgICAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICAgICAgXCI9e3tcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlUHJvcGVydGllc0RpZmYoXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgc2VydmVyUHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZW50ICsgMlxuICAgICAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBcIn19XFxuXCIpXG4gICAgICAgICAgICAgICAgOiAoKGNvbnRlbnQgKz1cbiAgICAgICAgICAgICAgICAgICAgYWRkZWQoaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICAgICAgXCI9XCIgK1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRQcm9wVmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcblwiKSxcbiAgICAgICAgICAgICAgICAgIChjb250ZW50ICs9XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICAgICAgXCI9XCIgK1xuICAgICAgICAgICAgICAgICAgICBtYXhMZW5ndGgkanNjb21wJDAgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcblwiKSk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgY29udGVudCArPVxuICAgICAgICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgICAgZGVzY3JpYmVQcm9wVmFsdWUoY2xpZW50UHJvcHNbX3Byb3BOYW1lMl0sIG1heExlbmd0aCRqc2NvbXAkMCkgK1xuICAgICAgICAgICAgICAgIFwiXFxuXCI7XG4gICAgICAgICAgfVxuICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICBpZiAoXCJjaGlsZHJlblwiICE9PSBwcm9wTmFtZSkge1xuICAgICAgICAgICAgdmFyIG1heExlbmd0aCA9IDEyMCAtIDIgKiAoaW5kZW50ICsgMSkgLSBwcm9wTmFtZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgY29udGVudCArPVxuICAgICAgICAgICAgICByZW1vdmVkKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgcHJvcE5hbWUgK1xuICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgIGRlc2NyaWJlUHJvcFZhbHVlKHNlcnZlclByb3BzW3Byb3BOYW1lXSwgbWF4TGVuZ3RoKSArXG4gICAgICAgICAgICAgIFwiXFxuXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGVudCA9XG4gICAgICAgICAgXCJcIiA9PT0gY29udGVudFxuICAgICAgICAgICAgPyBpbmRlbnRhdGlvbihpbmRlbnQpICsgXCI8XCIgKyB0eXBlICsgXCI+XFxuXCJcbiAgICAgICAgICAgIDogaW5kZW50YXRpb24oaW5kZW50KSArXG4gICAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgICAgdHlwZSArXG4gICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICBjb250ZW50ICtcbiAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KSArXG4gICAgICAgICAgICAgIFwiPlxcblwiO1xuICAgICAgfVxuICAgICAgdHlwZSA9IHNlcnZlclByb3BzLmNoaWxkcmVuO1xuICAgICAgY2xpZW50UHJvcHMgPSBjbGllbnRQcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICkge1xuICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMgPSBcIlwiO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzXG4gICAgICAgIClcbiAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMgPSBcIlwiICsgY2xpZW50UHJvcHM7XG4gICAgICAgIGNvbnRlbnQgKz0gZGVzY3JpYmVUZXh0RGlmZihzZXJ2ZXJQcm9wTmFtZXMsIFwiXCIgKyB0eXBlLCBpbmRlbnQgKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjbGllbnRQcm9wcyB8fFxuICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgY2xpZW50UHJvcHMgfHxcbiAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzXG4gICAgICApXG4gICAgICAgIGNvbnRlbnQgPVxuICAgICAgICAgIG51bGwgPT0gdHlwZVxuICAgICAgICAgICAgPyBjb250ZW50ICsgZGVzY3JpYmVUZXh0RGlmZihcIlwiICsgY2xpZW50UHJvcHMsIG51bGwsIGluZGVudCArIDEpXG4gICAgICAgICAgICA6IGNvbnRlbnQgKyBkZXNjcmliZVRleHREaWZmKFwiXCIgKyBjbGllbnRQcm9wcywgdm9pZCAwLCBpbmRlbnQgKyAxKTtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVNpYmxpbmdGaWJlcihmaWJlciwgaW5kZW50KSB7XG4gICAgICB2YXIgdHlwZSA9IGRlc2NyaWJlRmliZXJUeXBlKGZpYmVyKTtcbiAgICAgIGlmIChudWxsID09PSB0eXBlKSB7XG4gICAgICAgIHR5cGUgPSBcIlwiO1xuICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IGZpYmVyOyApXG4gICAgICAgICAgKHR5cGUgKz0gZGVzY3JpYmVTaWJsaW5nRmliZXIoZmliZXIsIGluZGVudCkpLFxuICAgICAgICAgICAgKGZpYmVyID0gZmliZXIuc2libGluZyk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGVudGF0aW9uKGluZGVudCkgKyBcIjxcIiArIHR5cGUgKyBcIj5cXG5cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVOb2RlKG5vZGUsIGluZGVudCkge1xuICAgICAgdmFyIHNraXBUb05vZGUgPSBmaW5kTm90YWJsZU5vZGUobm9kZSwgaW5kZW50KTtcbiAgICAgIGlmIChcbiAgICAgICAgc2tpcFRvTm9kZSAhPT0gbm9kZSAmJlxuICAgICAgICAoMSAhPT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggfHwgbm9kZS5jaGlsZHJlblswXSAhPT0gc2tpcFRvTm9kZSlcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQpICsgXCIuLi5cXG5cIiArIGRlc2NyaWJlTm9kZShza2lwVG9Ob2RlLCBpbmRlbnQgKyAxKVxuICAgICAgICApO1xuICAgICAgc2tpcFRvTm9kZSA9IFwiXCI7XG4gICAgICB2YXIgZGVidWdJbmZvID0gbm9kZS5maWJlci5fZGVidWdJbmZvO1xuICAgICAgaWYgKGRlYnVnSW5mbylcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWJ1Z0luZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc2VydmVyQ29tcG9uZW50TmFtZSA9IGRlYnVnSW5mb1tpXS5uYW1lO1xuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzZXJ2ZXJDb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICAoKHNraXBUb05vZGUgKz1cbiAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KSArIFwiPFwiICsgc2VydmVyQ29tcG9uZW50TmFtZSArIFwiPlxcblwiKSxcbiAgICAgICAgICAgIGluZGVudCsrKTtcbiAgICAgICAgfVxuICAgICAgZGVidWdJbmZvID0gXCJcIjtcbiAgICAgIGkgPSBub2RlLmZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgIGlmICg2ID09PSBub2RlLmZpYmVyLnRhZylcbiAgICAgICAgKGRlYnVnSW5mbyA9IGRlc2NyaWJlVGV4dERpZmYoaSwgbm9kZS5zZXJ2ZXJQcm9wcywgaW5kZW50KSksIGluZGVudCsrO1xuICAgICAgZWxzZSBpZiAoXG4gICAgICAgICgoc2VydmVyQ29tcG9uZW50TmFtZSA9IGRlc2NyaWJlRmliZXJUeXBlKG5vZGUuZmliZXIpKSxcbiAgICAgICAgbnVsbCAhPT0gc2VydmVyQ29tcG9uZW50TmFtZSlcbiAgICAgIClcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gbm9kZS5zZXJ2ZXJQcm9wcykge1xuICAgICAgICAgIGRlYnVnSW5mbyA9IGluZGVudDtcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gMTIwIC0gMiAqIGRlYnVnSW5mbyAtIHNlcnZlckNvbXBvbmVudE5hbWUubGVuZ3RoIC0gMixcbiAgICAgICAgICAgIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgIGZvciAocHJvcE5hbWUgaW4gaSlcbiAgICAgICAgICAgIGlmIChpLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJiBcImNoaWxkcmVuXCIgIT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBkZXNjcmliZVByb3BWYWx1ZShpW3Byb3BOYW1lXSwgMTUpO1xuICAgICAgICAgICAgICBtYXhMZW5ndGggLT0gcHJvcE5hbWUubGVuZ3RoICsgcHJvcFZhbHVlLmxlbmd0aCArIDI7XG4gICAgICAgICAgICAgIGlmICgwID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCArPSBcIiAuLi5cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250ZW50ICs9IFwiIFwiICsgcHJvcE5hbWUgKyBcIj1cIiArIHByb3BWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWJ1Z0luZm8gPVxuICAgICAgICAgICAgaW5kZW50YXRpb24oZGVidWdJbmZvKSArXG4gICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lICtcbiAgICAgICAgICAgIGNvbnRlbnQgK1xuICAgICAgICAgICAgXCI+XFxuXCI7XG4gICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIG51bGwgPT09IG5vZGUuc2VydmVyUHJvcHNcbiAgICAgICAgICAgID8gKChkZWJ1Z0luZm8gPSBkZXNjcmliZUV4cGFuZGVkRWxlbWVudChcbiAgICAgICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgYWRkZWQoaW5kZW50KVxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgaW5kZW50KyspXG4gICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBub2RlLnNlcnZlclByb3BzXG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiU2hvdWxkIG5vdCBoYXZlIG1hdGNoZWQgYSBub24gSG9zdFRleHQgZmliZXIgdG8gYSBUZXh0IG5vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogKChkZWJ1Z0luZm8gPSBkZXNjcmliZUVsZW1lbnREaWZmKFxuICAgICAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICBub2RlLnNlcnZlclByb3BzLFxuICAgICAgICAgICAgICAgICAgaW5kZW50XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgaW5kZW50KyspO1xuICAgICAgdmFyIHByb3BOYW1lID0gXCJcIjtcbiAgICAgIGkgPSBub2RlLmZpYmVyLmNoaWxkO1xuICAgICAgZm9yIChcbiAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSA9IDA7XG4gICAgICAgIGkgJiYgc2VydmVyQ29tcG9uZW50TmFtZSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICApXG4gICAgICAgIChtYXhMZW5ndGggPSBub2RlLmNoaWxkcmVuW3NlcnZlckNvbXBvbmVudE5hbWVdKSxcbiAgICAgICAgICBtYXhMZW5ndGguZmliZXIgPT09IGlcbiAgICAgICAgICAgID8gKChwcm9wTmFtZSArPSBkZXNjcmliZU5vZGUobWF4TGVuZ3RoLCBpbmRlbnQpKSxcbiAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSsrKVxuICAgICAgICAgICAgOiAocHJvcE5hbWUgKz0gZGVzY3JpYmVTaWJsaW5nRmliZXIoaSwgaW5kZW50KSksXG4gICAgICAgICAgKGkgPSBpLnNpYmxpbmcpO1xuICAgICAgaSAmJlxuICAgICAgICAwIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgKHByb3BOYW1lICs9IGluZGVudGF0aW9uKGluZGVudCkgKyBcIi4uLlxcblwiKTtcbiAgICAgIGkgPSBub2RlLnNlcnZlclRhaWw7XG4gICAgICBudWxsID09PSBub2RlLnNlcnZlclByb3BzICYmIGluZGVudC0tO1xuICAgICAgZm9yIChub2RlID0gMDsgbm9kZSA8IGkubGVuZ3RoOyBub2RlKyspXG4gICAgICAgIChzZXJ2ZXJDb21wb25lbnROYW1lID0gaVtub2RlXSksXG4gICAgICAgICAgKHByb3BOYW1lID1cbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzZXJ2ZXJDb21wb25lbnROYW1lXG4gICAgICAgICAgICAgID8gcHJvcE5hbWUgK1xuICAgICAgICAgICAgICAgIChyZW1vdmVkKGluZGVudCkgK1xuICAgICAgICAgICAgICAgICAgZGVzY3JpYmVUZXh0Tm9kZShzZXJ2ZXJDb21wb25lbnROYW1lLCAxMjAgLSAyICogaW5kZW50KSArXG4gICAgICAgICAgICAgICAgICBcIlxcblwiKVxuICAgICAgICAgICAgICA6IHByb3BOYW1lICtcbiAgICAgICAgICAgICAgICBkZXNjcmliZUV4cGFuZGVkRWxlbWVudChcbiAgICAgICAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUudHlwZSxcbiAgICAgICAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUucHJvcHMsXG4gICAgICAgICAgICAgICAgICByZW1vdmVkKGluZGVudClcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgIHJldHVybiBza2lwVG9Ob2RlICsgZGVidWdJbmZvICsgcHJvcE5hbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRGlmZihyb290Tm9kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFwiXFxuXFxuXCIgKyBkZXNjcmliZU5vZGUocm9vdE5vZGUsIDApO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgZGlzdGFuY2VGcm9tTGVhZikge1xuICAgICAgaWYgKG51bGwgPT09IGZpYmVyLnJldHVybikge1xuICAgICAgICBpZiAobnVsbCA9PT0gaHlkcmF0aW9uRGlmZlJvb3RERVYpXG4gICAgICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSB7XG4gICAgICAgICAgICBmaWJlcjogZmliZXIsXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBzZXJ2ZXJQcm9wczogdm9pZCAwLFxuICAgICAgICAgICAgc2VydmVyVGFpbDogW10sXG4gICAgICAgICAgICBkaXN0YW5jZUZyb21MZWFmOiBkaXN0YW5jZUZyb21MZWFmXG4gICAgICAgICAgfTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGh5ZHJhdGlvbkRpZmZSb290REVWLmZpYmVyICE9PSBmaWJlcilcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlNhdyBtdWx0aXBsZSBoeWRyYXRpb24gZGlmZiByb290cyBpbiBhIHBhc3MuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYuZGlzdGFuY2VGcm9tTGVhZiA+IGRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgICAgIChoeWRyYXRpb25EaWZmUm9vdERFVi5kaXN0YW5jZUZyb21MZWFmID0gZGlzdGFuY2VGcm9tTGVhZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh5ZHJhdGlvbkRpZmZSb290REVWO1xuICAgICAgfVxuICAgICAgdmFyIHNpYmxpbmdzID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShcbiAgICAgICAgZmliZXIucmV0dXJuLFxuICAgICAgICBkaXN0YW5jZUZyb21MZWFmICsgMVxuICAgICAgKS5jaGlsZHJlbjtcbiAgICAgIGlmICgwIDwgc2libGluZ3MubGVuZ3RoICYmIHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdLmZpYmVyID09PSBmaWJlcilcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoc2libGluZ3MgPSBzaWJsaW5nc1tzaWJsaW5ncy5sZW5ndGggLSAxXSksXG4gICAgICAgICAgc2libGluZ3MuZGlzdGFuY2VGcm9tTGVhZiA+IGRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgICAgIChzaWJsaW5ncy5kaXN0YW5jZUZyb21MZWFmID0gZGlzdGFuY2VGcm9tTGVhZiksXG4gICAgICAgICAgc2libGluZ3NcbiAgICAgICAgKTtcbiAgICAgIGRpc3RhbmNlRnJvbUxlYWYgPSB7XG4gICAgICAgIGZpYmVyOiBmaWJlcixcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICBzZXJ2ZXJQcm9wczogdm9pZCAwLFxuICAgICAgICBzZXJ2ZXJUYWlsOiBbXSxcbiAgICAgICAgZGlzdGFuY2VGcm9tTGVhZjogZGlzdGFuY2VGcm9tTGVhZlxuICAgICAgfTtcbiAgICAgIHNpYmxpbmdzLnB1c2goZGlzdGFuY2VGcm9tTGVhZik7XG4gICAgICByZXR1cm4gZGlzdGFuY2VGcm9tTGVhZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2UoZmliZXIsIHJlamVjdGVkQ2FuZGlkYXRlKSB7XG4gICAgICBkaWRTdXNwZW5kT3JFcnJvckRFViB8fFxuICAgICAgICAoKGZpYmVyID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCkpLFxuICAgICAgICAoZmliZXIuc2VydmVyUHJvcHMgPSBudWxsKSxcbiAgICAgICAgbnVsbCAhPT0gcmVqZWN0ZWRDYW5kaWRhdGUgJiZcbiAgICAgICAgICAoKHJlamVjdGVkQ2FuZGlkYXRlID1cbiAgICAgICAgICAgIGRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MocmVqZWN0ZWRDYW5kaWRhdGUpKSxcbiAgICAgICAgICBmaWJlci5zZXJ2ZXJUYWlsLnB1c2gocmVqZWN0ZWRDYW5kaWRhdGUpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcikge1xuICAgICAgdmFyIGRpZmYgPSBcIlwiLFxuICAgICAgICBkaWZmUm9vdCA9IGh5ZHJhdGlvbkRpZmZSb290REVWO1xuICAgICAgbnVsbCAhPT0gZGlmZlJvb3QgJiZcbiAgICAgICAgKChoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwpLCAoZGlmZiA9IGRlc2NyaWJlRGlmZihkaWZmUm9vdCkpKTtcbiAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IoXG4gICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgXCJIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIGRpZG4ndCBtYXRjaCB0aGUgY2xpZW50LiBBcyBhIHJlc3VsdCB0aGlzIHRyZWUgd2lsbCBiZSByZWdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LiBUaGlzIGNhbiBoYXBwZW4gaWYgYSBTU1ItZWQgQ2xpZW50IENvbXBvbmVudCB1c2VkOlxcblxcbi0gQSBzZXJ2ZXIvY2xpZW50IGJyYW5jaCBgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKWAuXFxuLSBWYXJpYWJsZSBpbnB1dCBzdWNoIGFzIGBEYXRlLm5vdygpYCBvciBgTWF0aC5yYW5kb20oKWAgd2hpY2ggY2hhbmdlcyBlYWNoIHRpbWUgaXQncyBjYWxsZWQuXFxuLSBEYXRlIGZvcm1hdHRpbmcgaW4gYSB1c2VyJ3MgbG9jYWxlIHdoaWNoIGRvZXNuJ3QgbWF0Y2ggdGhlIHNlcnZlci5cXG4tIEV4dGVybmFsIGNoYW5naW5nIGRhdGEgd2l0aG91dCBzZW5kaW5nIGEgc25hcHNob3Qgb2YgaXQgYWxvbmcgd2l0aCB0aGUgSFRNTC5cXG4tIEludmFsaWQgSFRNTCB0YWcgbmVzdGluZy5cXG5cXG5JdCBjYW4gYWxzbyBoYXBwZW4gaWYgdGhlIGNsaWVudCBoYXMgYSBicm93c2VyIGV4dGVuc2lvbiBpbnN0YWxsZWQgd2hpY2ggbWVzc2VzIHdpdGggdGhlIEhUTUwgYmVmb3JlIFJlYWN0IGxvYWRlZC5cXG5cXG5odHRwczovL3JlYWN0LmRldi9saW5rL2h5ZHJhdGlvbi1taXNtYXRjaFwiICtcbiAgICAgICAgICAgICAgZGlmZlxuICAgICAgICAgICksXG4gICAgICAgICAgZmliZXJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRocm93IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLCBob3N0Q29udGV4dCkge1xuICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbilcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICBoeWRyYXRlSW5zdGFuY2UoXG4gICAgICAgIGZpYmVyLnN0YXRlTm9kZSxcbiAgICAgICAgZmliZXIudHlwZSxcbiAgICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgaG9zdENvbnRleHQsXG4gICAgICAgIGZpYmVyXG4gICAgICApIHx8IHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpIHtcbiAgICAgIGZvciAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlci5yZXR1cm47IGh5ZHJhdGlvblBhcmVudEZpYmVyOyApXG4gICAgICAgIHN3aXRjaCAoaHlkcmF0aW9uUGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXIucmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uIHx8IGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikgcmV0dXJuICExO1xuICAgICAgaWYgKCFpc0h5ZHJhdGluZylcbiAgICAgICAgcmV0dXJuIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpLCAoaXNIeWRyYXRpbmcgPSAhMCksICExO1xuICAgICAgdmFyIHNob3VsZENsZWFyID0gITE7XG4gICAgICBzdXBwb3J0c1NpbmdsZXRvbnNcbiAgICAgICAgPyAzICE9PSBmaWJlci50YWcgJiZcbiAgICAgICAgICAyNyAhPT0gZmliZXIudGFnICYmXG4gICAgICAgICAgKDUgIT09IGZpYmVyLnRhZyB8fFxuICAgICAgICAgICAgKHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzKGZpYmVyLnR5cGUpICYmXG4gICAgICAgICAgICAgICFzaG91bGRTZXRUZXh0Q29udGVudChmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkpICYmXG4gICAgICAgICAgKHNob3VsZENsZWFyID0gITApXG4gICAgICAgIDogMyAhPT0gZmliZXIudGFnICYmXG4gICAgICAgICAgKDUgIT09IGZpYmVyLnRhZyB8fFxuICAgICAgICAgICAgKHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzKGZpYmVyLnR5cGUpICYmXG4gICAgICAgICAgICAgICFzaG91bGRTZXRUZXh0Q29udGVudChmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkpICYmXG4gICAgICAgICAgKHNob3VsZENsZWFyID0gITApO1xuICAgICAgaWYgKHNob3VsZENsZWFyICYmIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpIHtcbiAgICAgICAgZm9yIChzaG91bGRDbGVhciA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7IHNob3VsZENsZWFyOyApIHtcbiAgICAgICAgICB2YXIgZGlmZk5vZGUgPSBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKGZpYmVyLCAwKSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyhzaG91bGRDbGVhcik7XG4gICAgICAgICAgZGlmZk5vZGUuc2VydmVyVGFpbC5wdXNoKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICBzaG91bGRDbGVhciA9XG4gICAgICAgICAgICBcIlN1c3BlbnNlXCIgPT09IGRlc2NyaXB0aW9uLnR5cGVcbiAgICAgICAgICAgICAgPyBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHNob3VsZENsZWFyKVxuICAgICAgICAgICAgICA6IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhzaG91bGRDbGVhcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgICAgIH1cbiAgICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgICAgaWYgKDEzID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgZmliZXIgPSBudWxsICE9PSBmaWJlciA/IGZpYmVyLmRlaHlkcmF0ZWQgOiBudWxsO1xuICAgICAgICBpZiAoIWZpYmVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID1cbiAgICAgICAgICBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKGZpYmVyKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXJcbiAgICAgICAgICA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICAgICAgc3VwcG9ydHNIeWRyYXRpb24gJiZcbiAgICAgICAgKChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsKSxcbiAgICAgICAgKGRpZFN1c3BlbmRPckVycm9yREVWID0gaXNIeWRyYXRpbmcgPSAhMSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWV1ZUh5ZHJhdGlvbkVycm9yKGVycm9yKSB7XG4gICAgICBudWxsID09PSBoeWRyYXRpb25FcnJvcnNcbiAgICAgICAgPyAoaHlkcmF0aW9uRXJyb3JzID0gW2Vycm9yXSlcbiAgICAgICAgOiBoeWRyYXRpb25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MoKSB7XG4gICAgICB2YXIgZGlmZlJvb3QgPSBoeWRyYXRpb25EaWZmUm9vdERFVjtcbiAgICAgIG51bGwgIT09IGRpZmZSb290ICYmXG4gICAgICAgICgoaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsKSxcbiAgICAgICAgKGRpZmZSb290ID0gZGVzY3JpYmVEaWZmKGRpZmZSb290KSksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBIHRyZWUgaHlkcmF0ZWQgYnV0IHNvbWUgYXR0cmlidXRlcyBvZiB0aGUgc2VydmVyIHJlbmRlcmVkIEhUTUwgZGlkbid0IG1hdGNoIHRoZSBjbGllbnQgcHJvcGVydGllcy4gVGhpcyB3b24ndCBiZSBwYXRjaGVkIHVwLiBUaGlzIGNhbiBoYXBwZW4gaWYgYSBTU1ItZWQgQ2xpZW50IENvbXBvbmVudCB1c2VkOlxcblxcbi0gQSBzZXJ2ZXIvY2xpZW50IGJyYW5jaCBgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKWAuXFxuLSBWYXJpYWJsZSBpbnB1dCBzdWNoIGFzIGBEYXRlLm5vdygpYCBvciBgTWF0aC5yYW5kb20oKWAgd2hpY2ggY2hhbmdlcyBlYWNoIHRpbWUgaXQncyBjYWxsZWQuXFxuLSBEYXRlIGZvcm1hdHRpbmcgaW4gYSB1c2VyJ3MgbG9jYWxlIHdoaWNoIGRvZXNuJ3QgbWF0Y2ggdGhlIHNlcnZlci5cXG4tIEV4dGVybmFsIGNoYW5naW5nIGRhdGEgd2l0aG91dCBzZW5kaW5nIGEgc25hcHNob3Qgb2YgaXQgYWxvbmcgd2l0aCB0aGUgSFRNTC5cXG4tIEludmFsaWQgSFRNTCB0YWcgbmVzdGluZy5cXG5cXG5JdCBjYW4gYWxzbyBoYXBwZW4gaWYgdGhlIGNsaWVudCBoYXMgYSBicm93c2VyIGV4dGVuc2lvbiBpbnN0YWxsZWQgd2hpY2ggbWVzc2VzIHdpdGggdGhlIEhUTUwgYmVmb3JlIFJlYWN0IGxvYWRlZC5cXG5cXG4lcyVzXCIsXG4gICAgICAgICAgXCJodHRwczovL3JlYWN0LmRldi9saW5rL2h5ZHJhdGlvbi1taXNtYXRjaFwiLFxuICAgICAgICAgIGRpZmZSb290XG4gICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gY29uY3VycmVudFF1ZXVlc0luZGV4LFxuICAgICAgICAgIGkgPSAoY29uY3VycmVudGx5VXBkYXRlZExhbmVzID0gY29uY3VycmVudFF1ZXVlc0luZGV4ID0gMCk7XG4gICAgICAgIGkgPCBlbmRJbmRleDtcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBmaWJlciA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgICAgIHZhciBxdWV1ZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgICAgIHZhciB1cGRhdGUgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgICAgICBjb25jdXJyZW50UXVldWVzW2krK10gPSBudWxsO1xuICAgICAgICB2YXIgbGFuZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgICAgIGlmIChudWxsICE9PSBxdWV1ZSAmJiBudWxsICE9PSB1cGRhdGUpIHtcbiAgICAgICAgICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG4gICAgICAgICAgbnVsbCA9PT0gcGVuZGluZ1xuICAgICAgICAgICAgPyAodXBkYXRlLm5leHQgPSB1cGRhdGUpXG4gICAgICAgICAgICA6ICgodXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQpLCAocGVuZGluZy5uZXh0ID0gdXBkYXRlKSk7XG4gICAgICAgICAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICAwICE9PSBsYW5lICYmIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCB1cGRhdGUsIGxhbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gZmliZXI7XG4gICAgICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IHF1ZXVlO1xuICAgICAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSB1cGRhdGU7XG4gICAgICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IGxhbmU7XG4gICAgICBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgfD0gbGFuZTtcbiAgICAgIGZpYmVyLmxhbmVzIHw9IGxhbmU7XG4gICAgICBmaWJlciA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgIT09IGZpYmVyICYmIChmaWJlci5sYW5lcyB8PSBsYW5lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKSB7XG4gICAgICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuICAgICAgcmV0dXJuIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIGxhbmUpIHtcbiAgICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgbnVsbCwgbnVsbCwgbGFuZSk7XG4gICAgICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHNvdXJjZUZpYmVyLCB1cGRhdGUsIGxhbmUpIHtcbiAgICAgIHNvdXJjZUZpYmVyLmxhbmVzIHw9IGxhbmU7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUubGFuZXMgfD0gbGFuZSk7XG4gICAgICBmb3IgKHZhciBpc0hpZGRlbiA9ICExLCBwYXJlbnQgPSBzb3VyY2VGaWJlci5yZXR1cm47IG51bGwgIT09IHBhcmVudDsgKVxuICAgICAgICAocGFyZW50LmNoaWxkTGFuZXMgfD0gbGFuZSksXG4gICAgICAgICAgKGFsdGVybmF0ZSA9IHBhcmVudC5hbHRlcm5hdGUpLFxuICAgICAgICAgIG51bGwgIT09IGFsdGVybmF0ZSAmJiAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgfD0gbGFuZSksXG4gICAgICAgICAgMjIgPT09IHBhcmVudC50YWcgJiZcbiAgICAgICAgICAgICgoc291cmNlRmliZXIgPSBwYXJlbnQuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgIG51bGwgPT09IHNvdXJjZUZpYmVyIHx8XG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLl92aXNpYmlsaXR5ICYgMSB8fFxuICAgICAgICAgICAgICAoaXNIaWRkZW4gPSAhMCkpLFxuICAgICAgICAgIChzb3VyY2VGaWJlciA9IHBhcmVudCksXG4gICAgICAgICAgKHBhcmVudCA9IHBhcmVudC5yZXR1cm4pO1xuICAgICAgaXNIaWRkZW4gJiZcbiAgICAgICAgbnVsbCAhPT0gdXBkYXRlICYmXG4gICAgICAgIDMgPT09IHNvdXJjZUZpYmVyLnRhZyAmJlxuICAgICAgICAoKHBhcmVudCA9IHNvdXJjZUZpYmVyLnN0YXRlTm9kZSksXG4gICAgICAgIChpc0hpZGRlbiA9IDMxIC0gY2x6MzIobGFuZSkpLFxuICAgICAgICAocGFyZW50ID0gcGFyZW50LmhpZGRlblVwZGF0ZXMpLFxuICAgICAgICAoc291cmNlRmliZXIgPSBwYXJlbnRbaXNIaWRkZW5dKSxcbiAgICAgICAgbnVsbCA9PT0gc291cmNlRmliZXJcbiAgICAgICAgICA/IChwYXJlbnRbaXNIaWRkZW5dID0gW3VwZGF0ZV0pXG4gICAgICAgICAgOiBzb3VyY2VGaWJlci5wdXNoKHVwZGF0ZSksXG4gICAgICAgICh1cGRhdGUubGFuZSA9IGxhbmUgfCA1MzY4NzA5MTIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihzb3VyY2VGaWJlcikge1xuICAgICAgaWYgKG5lc3RlZFVwZGF0ZUNvdW50ID4gTkVTVEVEX1VQREFURV9MSU1JVClcbiAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICgobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gbmVzdGVkVXBkYXRlQ291bnQgPSAwKSxcbiAgICAgICAgICAocm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGwpLFxuICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgXCJNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuXCJcbiAgICAgICAgICApKVxuICAgICAgICApO1xuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID4gTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUICYmXG4gICAgICAgICgobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMCksXG4gICAgICAgIChyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIHVzZUVmZmVjdCwgYnV0IHVzZUVmZmVjdCBlaXRoZXIgZG9lc24ndCBoYXZlIGEgZGVwZW5kZW5jeSBhcnJheSwgb3Igb25lIG9mIHRoZSBkZXBlbmRlbmNpZXMgY2hhbmdlcyBvbiBldmVyeSByZW5kZXIuXCJcbiAgICAgICAgKSk7XG4gICAgICBudWxsID09PSBzb3VyY2VGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgMCAhPT0gKHNvdXJjZUZpYmVyLmZsYWdzICYgNDA5OCkgJiZcbiAgICAgICAgd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7XG4gICAgICBmb3IgKHZhciBub2RlID0gc291cmNlRmliZXIsIHBhcmVudCA9IG5vZGUucmV0dXJuOyBudWxsICE9PSBwYXJlbnQ7IClcbiAgICAgICAgbnVsbCA9PT0gbm9kZS5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAwICE9PSAobm9kZS5mbGFncyAmIDQwOTgpICYmXG4gICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlciksXG4gICAgICAgICAgKG5vZGUgPSBwYXJlbnQpLFxuICAgICAgICAgIChwYXJlbnQgPSBub2RlLnJldHVybik7XG4gICAgICByZXR1cm4gMyA9PT0gbm9kZS50YWcgPyBub2RlLnN0YXRlTm9kZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKSB7XG4gICAgICB2YXIgcHJldkVmZmVjdER1cmF0aW9uID0gcHJvZmlsZXJFZmZlY3REdXJhdGlvbjtcbiAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgcmV0dXJuIHByZXZFZmZlY3REdXJhdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wTmVzdGVkRWZmZWN0RHVyYXRpb25zKHByZXZFZmZlY3REdXJhdGlvbikge1xuICAgICAgdmFyIGVsYXBzZWRUaW1lID0gcHJvZmlsZXJFZmZlY3REdXJhdGlvbjtcbiAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gPSBwcmV2RWZmZWN0RHVyYXRpb247XG4gICAgICByZXR1cm4gZWxhcHNlZFRpbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pIHtcbiAgICAgIHZhciBlbGFwc2VkVGltZSA9IHByb2ZpbGVyRWZmZWN0RHVyYXRpb247XG4gICAgICBwcm9maWxlckVmZmVjdER1cmF0aW9uICs9IHByZXZFZmZlY3REdXJhdGlvbjtcbiAgICAgIHJldHVybiBlbGFwc2VkVGltZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRQcm9maWxlclRpbWVyKGZpYmVyKSB7XG4gICAgICBwcm9maWxlclN0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgMCA+IGZpYmVyLmFjdHVhbFN0YXJ0VGltZSAmJiAoZmliZXIuYWN0dWFsU3RhcnRUaW1lID0gcHJvZmlsZXJTdGFydFRpbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZER1cmF0aW9uKGZpYmVyKSB7XG4gICAgICBpZiAoMCA8PSBwcm9maWxlclN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3coKSAtIHByb2ZpbGVyU3RhcnRUaW1lO1xuICAgICAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgICAgZmliZXIuc2VsZkJhc2VEdXJhdGlvbiA9IGVsYXBzZWRUaW1lO1xuICAgICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZEluY29tcGxldGVEdXJhdGlvbihmaWJlcikge1xuICAgICAgaWYgKDAgPD0gcHJvZmlsZXJTdGFydFRpbWUpIHtcbiAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gbm93KCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICAgICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY29yZEVmZmVjdER1cmF0aW9uKCkge1xuICAgICAgaWYgKDAgPD0gcHJvZmlsZXJTdGFydFRpbWUpIHtcbiAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gbm93KCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgICAgICAgcHJvZmlsZXJFZmZlY3REdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRFZmZlY3RUaW1lcigpIHtcbiAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gbm93KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24oZmliZXIpIHtcbiAgICAgIGZvciAodmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7IGNoaWxkOyApXG4gICAgICAgIChmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbiksIChjaGlsZCA9IGNoaWxkLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCkge1xuICAgICAgcm9vdCAhPT0gbGFzdFNjaGVkdWxlZFJvb3QgJiZcbiAgICAgICAgbnVsbCA9PT0gcm9vdC5uZXh0ICYmXG4gICAgICAgIChudWxsID09PSBsYXN0U2NoZWR1bGVkUm9vdFxuICAgICAgICAgID8gKGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdClcbiAgICAgICAgICA6IChsYXN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290Lm5leHQgPSByb290KSk7XG4gICAgICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSAhMDtcbiAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlXG4gICAgICAgID8gZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0IHx8XG4gICAgICAgICAgKChkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QgPSAhMCksXG4gICAgICAgICAgc2NoZWR1bGVJbW1lZGlhdGVUYXNrKHByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzaykpXG4gICAgICAgIDogZGlkU2NoZWR1bGVNaWNyb3Rhc2sgfHxcbiAgICAgICAgICAoKGRpZFNjaGVkdWxlTWljcm90YXNrID0gITApLFxuICAgICAgICAgIHNjaGVkdWxlSW1tZWRpYXRlVGFzayhwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2spKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoc3luY1RyYW5zaXRpb25MYW5lcywgb25seUxlZ2FjeSkge1xuICAgICAgaWYgKCFpc0ZsdXNoaW5nV29yayAmJiBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmspIHtcbiAgICAgICAgaXNGbHVzaGluZ1dvcmsgPSAhMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciBkaWRQZXJmb3JtU29tZVdvcmsgPSAhMTtcbiAgICAgICAgICBmb3IgKHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290OyBudWxsICE9PSByb290OyApIHtcbiAgICAgICAgICAgIGlmICghb25seUxlZ2FjeSlcbiAgICAgICAgICAgICAgaWYgKDAgIT09IHN5bmNUcmFuc2l0aW9uTGFuZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHBlbmRpbmdMYW5lcykgdmFyIG5leHRMYW5lcyA9IDA7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgICBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7XG4gICAgICAgICAgICAgICAgICBuZXh0TGFuZXMgPVxuICAgICAgICAgICAgICAgICAgICAoMSA8PCAoMzEgLSBjbHozMig0MiB8IHN5bmNUcmFuc2l0aW9uTGFuZXMpICsgMSkpIC0gMTtcbiAgICAgICAgICAgICAgICAgIG5leHRMYW5lcyAmPSBwZW5kaW5nTGFuZXMgJiB+KHN1c3BlbmRlZExhbmVzICYgfnBpbmdlZExhbmVzKTtcbiAgICAgICAgICAgICAgICAgIG5leHRMYW5lcyA9XG4gICAgICAgICAgICAgICAgICAgIG5leHRMYW5lcyAmIDIwMTMyNjY3N1xuICAgICAgICAgICAgICAgICAgICAgID8gKG5leHRMYW5lcyAmIDIwMTMyNjY3NykgfCAxXG4gICAgICAgICAgICAgICAgICAgICAgOiBuZXh0TGFuZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV4dExhbmVzIHwgMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAwICE9PSBuZXh0TGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgICgoZGlkUGVyZm9ybVNvbWVXb3JrID0gITApLFxuICAgICAgICAgICAgICAgICAgcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QsIG5leHRMYW5lcykpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAobmV4dExhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhcbiAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gbmV4dExhbmVzIDogMFxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAwID09PSAobmV4dExhbmVzICYgMykgfHxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCBuZXh0TGFuZXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICgoZGlkUGVyZm9ybVNvbWVXb3JrID0gITApLFxuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCwgbmV4dExhbmVzKSk7XG4gICAgICAgICAgICByb290ID0gcm9vdC5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlkUGVyZm9ybVNvbWVXb3JrKTtcbiAgICAgICAgaXNGbHVzaGluZ1dvcmsgPSAhMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrKCkge1xuICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID1cbiAgICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0ID1cbiAgICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPVxuICAgICAgICAgICExO1xuICAgICAgdmFyIHN5bmNUcmFuc2l0aW9uTGFuZXMgPSAwO1xuICAgICAgMCAhPT0gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgJiZcbiAgICAgICAgKHNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24oKSAmJlxuICAgICAgICAgIChzeW5jVHJhbnNpdGlvbkxhbmVzID0gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUpLFxuICAgICAgICAoY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSAwKSk7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBub3ckMSgpLCBwcmV2ID0gbnVsbCwgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgbnVsbCAhPT0gcm9vdDtcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBuZXh0ID0gcm9vdC5uZXh0LFxuICAgICAgICAgIG5leHRMYW5lcyA9IHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgY3VycmVudFRpbWUpO1xuICAgICAgICBpZiAoMCA9PT0gbmV4dExhbmVzKVxuICAgICAgICAgIChyb290Lm5leHQgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgPT09IHByZXYgPyAoZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dCkgOiAocHJldi5uZXh0ID0gbmV4dCksXG4gICAgICAgICAgICBudWxsID09PSBuZXh0ICYmIChsYXN0U2NoZWR1bGVkUm9vdCA9IHByZXYpO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAoKHByZXYgPSByb290KSwgMCAhPT0gc3luY1RyYW5zaXRpb25MYW5lcyB8fCAwICE9PSAobmV4dExhbmVzICYgMykpXG4gICAgICAgIClcbiAgICAgICAgICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSAhMDtcbiAgICAgICAgcm9vdCA9IG5leHQ7XG4gICAgICB9XG4gICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbChzeW5jVHJhbnNpdGlvbkxhbmVzLCAhMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgY3VycmVudFRpbWUpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXMsXG4gICAgICAgICAgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzLFxuICAgICAgICAgIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzLFxuICAgICAgICAgIGxhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXMgJiAtNjI5MTQ1NjE7XG4gICAgICAgIDAgPCBsYW5lcztcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4LFxuICAgICAgICAgIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWVzW2luZGV4XTtcbiAgICAgICAgaWYgKC0xID09PSBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIGlmICgwID09PSAobGFuZSAmIHN1c3BlbmRlZExhbmVzKSB8fCAwICE9PSAobGFuZSAmIHBpbmdlZExhbmVzKSlcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBjb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSwgY3VycmVudFRpbWUpO1xuICAgICAgICB9IGVsc2UgZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWUgJiYgKHJvb3QuZXhwaXJlZExhbmVzIHw9IGxhbmUpO1xuICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRUaW1lID0gd29ya0luUHJvZ3Jlc3NSb290O1xuICAgICAgc3VzcGVuZGVkTGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcztcbiAgICAgIHN1c3BlbmRlZExhbmVzID0gZ2V0TmV4dExhbmVzKFxuICAgICAgICByb290LFxuICAgICAgICByb290ID09PSBjdXJyZW50VGltZSA/IHN1c3BlbmRlZExhbmVzIDogMFxuICAgICAgKTtcbiAgICAgIHBpbmdlZExhbmVzID0gcm9vdC5jYWxsYmFja05vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIDAgPT09IHN1c3BlbmRlZExhbmVzIHx8XG4gICAgICAgIChyb290ID09PSBjdXJyZW50VGltZSAmJlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGEpIHx8XG4gICAgICAgIG51bGwgIT09IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdFxuICAgICAgKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG51bGwgIT09IHBpbmdlZExhbmVzICYmIGNhbmNlbENhbGxiYWNrKHBpbmdlZExhbmVzKSxcbiAgICAgICAgICAocm9vdC5jYWxsYmFja05vZGUgPSBudWxsKSxcbiAgICAgICAgICAocm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gKHN1c3BlbmRlZExhbmVzICYgMykgfHxcbiAgICAgICAgY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCBzdXNwZW5kZWRMYW5lcylcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50VGltZSA9IHN1c3BlbmRlZExhbmVzICYgLXN1c3BlbmRlZExhbmVzO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY3VycmVudFRpbWUgIT09IHJvb3QuY2FsbGJhY2tQcmlvcml0eSB8fFxuICAgICAgICAgIChudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICAgICAgcGluZ2VkTGFuZXMgIT09IGZha2VBY3RDYWxsYmFja05vZGUkMSlcbiAgICAgICAgKVxuICAgICAgICAgIGNhbmNlbENhbGxiYWNrKHBpbmdlZExhbmVzKTtcbiAgICAgICAgZWxzZSByZXR1cm4gY3VycmVudFRpbWU7XG4gICAgICAgIHN3aXRjaCAobGFuZXNUb0V2ZW50UHJpb3JpdHkoc3VzcGVuZGVkTGFuZXMpKSB7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHN1c3BlbmRlZExhbmVzID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IElkbGVQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgIH1cbiAgICAgICAgcGluZ2VkTGFuZXMgPSBwZXJmb3JtV29ya09uUm9vdFZpYVNjaGVkdWxlclRhc2suYmluZChudWxsLCByb290KTtcbiAgICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWVcbiAgICAgICAgICA/IChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZS5wdXNoKHBpbmdlZExhbmVzKSxcbiAgICAgICAgICAgIChzdXNwZW5kZWRMYW5lcyA9IGZha2VBY3RDYWxsYmFja05vZGUkMSkpXG4gICAgICAgICAgOiAoc3VzcGVuZGVkTGFuZXMgPSBzY2hlZHVsZUNhbGxiYWNrJDMoc3VzcGVuZGVkTGFuZXMsIHBpbmdlZExhbmVzKSk7XG4gICAgICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICByb290LmNhbGxiYWNrTm9kZSA9IHN1c3BlbmRlZExhbmVzO1xuICAgICAgICByZXR1cm4gY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICBudWxsICE9PSBwaW5nZWRMYW5lcyAmJiBjYW5jZWxDYWxsYmFjayhwaW5nZWRMYW5lcyk7XG4gICAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSAyO1xuICAgICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290VmlhU2NoZWR1bGVyVGFzayhyb290LCBkaWRUaW1lb3V0KSB7XG4gICAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSAhMTtcbiAgICAgIHZhciBvcmlnaW5hbENhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuICAgICAgaWYgKGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSAmJiByb290LmNhbGxiYWNrTm9kZSAhPT0gb3JpZ2luYWxDYWxsYmFja05vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCA9IGdldE5leHRMYW5lcyhcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDAgOiAwXG4gICAgICApO1xuICAgICAgaWYgKDAgPT09IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwKSByZXR1cm4gbnVsbDtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KFxuICAgICAgICByb290LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCxcbiAgICAgICAgZGlkVGltZW91dFxuICAgICAgKTtcbiAgICAgIHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgbm93JDEoKSk7XG4gICAgICByZXR1cm4gbnVsbCAhPSByb290LmNhbGxiYWNrTm9kZSAmJlxuICAgICAgICByb290LmNhbGxiYWNrTm9kZSA9PT0gb3JpZ2luYWxDYWxsYmFja05vZGVcbiAgICAgICAgPyBwZXJmb3JtV29ya09uUm9vdFZpYVNjaGVkdWxlclRhc2suYmluZChudWxsLCByb290KVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290LCBsYW5lcykge1xuICAgICAgaWYgKGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSkgcmV0dXJuIG51bGw7XG4gICAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQ7XG4gICAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSAhMTtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGxhbmVzLCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbENhbGxiYWNrKGNhbGxiYWNrTm9kZSkge1xuICAgICAgY2FsbGJhY2tOb2RlICE9PSBmYWtlQWN0Q2FsbGJhY2tOb2RlJDEgJiZcbiAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2tOb2RlICYmXG4gICAgICAgIGNhbmNlbENhbGxiYWNrJDEoY2FsbGJhY2tOb2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVJbW1lZGlhdGVUYXNrKGNiKSB7XG4gICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIHN1cHBvcnRzTWljcm90YXNrc1xuICAgICAgICA/IHNjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dFxuICAgICAgICAgICAgICA/IHNjaGVkdWxlQ2FsbGJhY2skMyhJbW1lZGlhdGVQcmlvcml0eSwgY2IpXG4gICAgICAgICAgICAgIDogY2IoKTtcbiAgICAgICAgICB9KVxuICAgICAgICA6IHNjaGVkdWxlQ2FsbGJhY2skMyhJbW1lZGlhdGVQcmlvcml0eSwgY2IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKSB7XG4gICAgICAwID09PSBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSAmJlxuICAgICAgICAoY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpKTtcbiAgICAgIHJldHVybiBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50YW5nbGVBc3luY0FjdGlvbih0cmFuc2l0aW9uLCB0aGVuYWJsZSkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGVudGFuZ2xlZExpc3RlbmVycyA9IChjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gW10pO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ID0gMDtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKTtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0ge1xuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgZW50YW5nbGVkTGlzdGVuZXJzLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCsrO1xuICAgICAgdGhlbmFibGUudGhlbihwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlLCBwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlKTtcbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGluZ0VuZ3RhbmdsZWRBY3Rpb25TY29wZSgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gLS1jdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnNcbiAgICAgICkge1xuICAgICAgICBudWxsICE9PSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgJiZcbiAgICAgICAgICAoY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIpO1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudEVudGFuZ2xlZExpc3RlbmVycztcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gMDtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspICgwLCBsaXN0ZW5lcnNbaV0pKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoYWluVGhlbmFibGVWYWx1ZSh0aGVuYWJsZSwgcmVzdWx0KSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gW10sXG4gICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlID0ge1xuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgcmVhc29uOiBudWxsLFxuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChyZXNvbHZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB0aGVuYWJsZS50aGVuKFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZS52YWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykgKDAsIGxpc3RlbmVyc1tpXSkocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgIGZvciAoZXJyb3IgPSAwOyBlcnJvciA8IGxpc3RlbmVycy5sZW5ndGg7IGVycm9yKyspXG4gICAgICAgICAgICAoMCwgbGlzdGVuZXJzW2Vycm9yXSkodm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGVuYWJsZVdpdGhPdmVycmlkZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGZpYmVyKSB7XG4gICAgICBmaWJlci51cGRhdGVRdWV1ZSA9IHtcbiAgICAgICAgYmFzZVN0YXRlOiBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgICAgICBmaXJzdEJhc2VVcGRhdGU6IG51bGwsXG4gICAgICAgIGxhc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgICAgICBzaGFyZWQ6IHsgcGVuZGluZzogbnVsbCwgbGFuZXM6IDAsIGhpZGRlbkNhbGxiYWNrczogbnVsbCB9LFxuICAgICAgICBjYWxsYmFja3M6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0ge1xuICAgICAgICAgIGJhc2VTdGF0ZTogY3VycmVudC5iYXNlU3RhdGUsXG4gICAgICAgICAgZmlyc3RCYXNlVXBkYXRlOiBjdXJyZW50LmZpcnN0QmFzZVVwZGF0ZSxcbiAgICAgICAgICBsYXN0QmFzZVVwZGF0ZTogY3VycmVudC5sYXN0QmFzZVVwZGF0ZSxcbiAgICAgICAgICBzaGFyZWQ6IGN1cnJlbnQuc2hhcmVkLFxuICAgICAgICAgIGNhbGxiYWNrczogbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVXBkYXRlKGxhbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhbmU6IGxhbmUsXG4gICAgICAgIHRhZzogVXBkYXRlU3RhdGUsXG4gICAgICAgIHBheWxvYWQ6IG51bGwsXG4gICAgICAgIGNhbGxiYWNrOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIGxhbmUpIHtcbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKG51bGwgPT09IHVwZGF0ZVF1ZXVlKSByZXR1cm4gbnVsbDtcbiAgICAgIHVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuICAgICAgaWYgKFxuICAgICAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPT09IHVwZGF0ZVF1ZXVlICYmXG4gICAgICAgICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCB3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSBjYWxsYmFjay5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50OiAlc1wiLFxuICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoY29tcG9uZW50TmFtZSA9IHVwZGF0ZVF1ZXVlLnBlbmRpbmcpLFxuICAgICAgICAgIG51bGwgPT09IGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgID8gKHVwZGF0ZS5uZXh0ID0gdXBkYXRlKVxuICAgICAgICAgICAgOiAoKHVwZGF0ZS5uZXh0ID0gY29tcG9uZW50TmFtZS5uZXh0KSxcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUubmV4dCA9IHVwZGF0ZSkpLFxuICAgICAgICAgICh1cGRhdGVRdWV1ZS5wZW5kaW5nID0gdXBkYXRlKSxcbiAgICAgICAgICAodXBkYXRlID0gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcikpLFxuICAgICAgICAgIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCBudWxsLCBsYW5lKSxcbiAgICAgICAgICB1cGRhdGVcbiAgICAgICAgKTtcbiAgICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgdXBkYXRlUXVldWUsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAgICAgIGZpYmVyID0gZmliZXIudXBkYXRlUXVldWU7XG4gICAgICBpZiAobnVsbCAhPT0gZmliZXIgJiYgKChmaWJlciA9IGZpYmVyLnNoYXJlZCksIDAgIT09IChsYW5lICYgNDE5NDE3NikpKSB7XG4gICAgICAgIHZhciBxdWV1ZUxhbmVzID0gZmliZXIubGFuZXM7XG4gICAgICAgIHF1ZXVlTGFuZXMgJj0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICAgIGxhbmUgfD0gcXVldWVMYW5lcztcbiAgICAgICAgZmliZXIubGFuZXMgPSBsYW5lO1xuICAgICAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBsYW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBjYXB0dXJlZFVwZGF0ZSkge1xuICAgICAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUsXG4gICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksIHF1ZXVlID09PSBjdXJyZW50KVxuICAgICAgKSB7XG4gICAgICAgIHZhciBuZXdGaXJzdCA9IG51bGwsXG4gICAgICAgICAgbmV3TGFzdCA9IG51bGw7XG4gICAgICAgIHF1ZXVlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gcXVldWUpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgICAgIGxhbmU6IHF1ZXVlLmxhbmUsXG4gICAgICAgICAgICAgIHRhZzogcXVldWUudGFnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBxdWV1ZS5wYXlsb2FkLFxuICAgICAgICAgICAgICBjYWxsYmFjazogbnVsbCxcbiAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG51bGwgPT09IG5ld0xhc3RcbiAgICAgICAgICAgICAgPyAobmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2xvbmUpXG4gICAgICAgICAgICAgIDogKG5ld0xhc3QgPSBuZXdMYXN0Lm5leHQgPSBjbG9uZSk7XG4gICAgICAgICAgICBxdWV1ZSA9IHF1ZXVlLm5leHQ7XG4gICAgICAgICAgfSB3aGlsZSAobnVsbCAhPT0gcXVldWUpO1xuICAgICAgICAgIG51bGwgPT09IG5ld0xhc3RcbiAgICAgICAgICAgID8gKG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlKVxuICAgICAgICAgICAgOiAobmV3TGFzdCA9IG5ld0xhc3QubmV4dCA9IGNhcHR1cmVkVXBkYXRlKTtcbiAgICAgICAgfSBlbHNlIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICBxdWV1ZSA9IHtcbiAgICAgICAgICBiYXNlU3RhdGU6IGN1cnJlbnQuYmFzZVN0YXRlLFxuICAgICAgICAgIGZpcnN0QmFzZVVwZGF0ZTogbmV3Rmlyc3QsXG4gICAgICAgICAgbGFzdEJhc2VVcGRhdGU6IG5ld0xhc3QsXG4gICAgICAgICAgc2hhcmVkOiBjdXJyZW50LnNoYXJlZCxcbiAgICAgICAgICBjYWxsYmFja3M6IGN1cnJlbnQuY2FsbGJhY2tzXG4gICAgICAgIH07XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gcXVldWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdvcmtJblByb2dyZXNzID0gcXVldWUubGFzdEJhc2VVcGRhdGU7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICA/IChxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZSlcbiAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MubmV4dCA9IGNhcHR1cmVkVXBkYXRlKTtcbiAgICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKSB7XG4gICAgICBpZiAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbikge1xuICAgICAgICB2YXIgZW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGU7XG4gICAgICAgIGlmIChudWxsICE9PSBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSkgdGhyb3cgZW50YW5nbGVkQWN0aW9uVGhlbmFibGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcHJvcHMsXG4gICAgICBpbnN0YW5jZSRqc2NvbXAkMCxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITE7XG4gICAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITE7XG4gICAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQ7XG4gICAgICB2YXIgZmlyc3RCYXNlVXBkYXRlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgICBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlLFxuICAgICAgICBwZW5kaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQucGVuZGluZztcbiAgICAgIGlmIChudWxsICE9PSBwZW5kaW5nUXVldWUpIHtcbiAgICAgICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB2YXIgbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWUsXG4gICAgICAgICAgZmlyc3RQZW5kaW5nVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUubmV4dDtcbiAgICAgICAgbGFzdFBlbmRpbmdVcGRhdGUubmV4dCA9IG51bGw7XG4gICAgICAgIG51bGwgPT09IGxhc3RCYXNlVXBkYXRlXG4gICAgICAgICAgPyAoZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlKVxuICAgICAgICAgIDogKGxhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGUpO1xuICAgICAgICBsYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWUpLFxuICAgICAgICAgIChwZW5kaW5nUXVldWUgPSBjdXJyZW50Lmxhc3RCYXNlVXBkYXRlKSxcbiAgICAgICAgICBwZW5kaW5nUXVldWUgIT09IGxhc3RCYXNlVXBkYXRlICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gcGVuZGluZ1F1ZXVlXG4gICAgICAgICAgICAgID8gKGN1cnJlbnQuZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlKVxuICAgICAgICAgICAgICA6IChwZW5kaW5nUXVldWUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZSksXG4gICAgICAgICAgICAoY3VycmVudC5sYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlKSkpO1xuICAgICAgfVxuICAgICAgaWYgKG51bGwgIT09IGZpcnN0QmFzZVVwZGF0ZSkge1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7XG4gICAgICAgIGxhc3RCYXNlVXBkYXRlID0gMDtcbiAgICAgICAgY3VycmVudCA9IGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlID0gbnVsbDtcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gZmlyc3RCYXNlVXBkYXRlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIHVwZGF0ZUxhbmUgPSBwZW5kaW5nUXVldWUubGFuZSAmIC01MzY4NzA5MTMsXG4gICAgICAgICAgICBpc0hpZGRlblVwZGF0ZSA9IHVwZGF0ZUxhbmUgIT09IHBlbmRpbmdRdWV1ZS5sYW5lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzSGlkZGVuVXBkYXRlXG4gICAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICAgICAgICAgOiAocmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgMCAhPT0gdXBkYXRlTGFuZSAmJlxuICAgICAgICAgICAgICB1cGRhdGVMYW5lID09PSBjdXJyZW50RW50YW5nbGVkTGFuZSAmJlxuICAgICAgICAgICAgICAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICEwKTtcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50Lm5leHQgPVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGxhbmU6IDAsXG4gICAgICAgICAgICAgICAgICB0YWc6IHBlbmRpbmdRdWV1ZS50YWcsXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkOiBwZW5kaW5nUXVldWUucGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBudWxsLFxuICAgICAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICB1cGRhdGVMYW5lID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgIHZhciBwYXJ0aWFsU3RhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgICAgICAgICAgIHZhciBuZXh0UHJvcHMgPSBwcm9wcyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlJGpzY29tcCQwO1xuICAgICAgICAgICAgICBzd2l0Y2ggKHBhcnRpYWxTdGF0ZS50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFJlcGxhY2VTdGF0ZTpcbiAgICAgICAgICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IHBhcnRpYWxTdGF0ZS5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHBhcnRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gITA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSBwYXJ0aWFsU3RhdGUuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUxhbmUubW9kZSAmIDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxTdGF0ZS5jYWxsKGluc3RhbmNlLCBuZXdTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gITE7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBwYXJ0aWFsU3RhdGU7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgQ2FwdHVyZVVwZGF0ZTpcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZUxhbmUuZmxhZ3MgPSAodXBkYXRlTGFuZS5mbGFncyAmIC02NTUzNykgfCAxMjg7XG4gICAgICAgICAgICAgICAgY2FzZSBVcGRhdGVTdGF0ZTpcbiAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IHBhcnRpYWxTdGF0ZS5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5leHRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gITA7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IG5leHRTdGF0ZS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlTGFuZS5tb2RlICYgOCkge1xuICAgICAgICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmNhbGwoaW5zdGFuY2UsIG5ld1N0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBwYXJ0aWFsU3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gcGFydGlhbFN0YXRlIHx8IHZvaWQgMCA9PT0gcGFydGlhbFN0YXRlKSBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBhc3NpZ24oe30sIG5ld1N0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIEZvcmNlVXBkYXRlOlxuICAgICAgICAgICAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlTGFuZSA9IHBlbmRpbmdRdWV1ZS5jYWxsYmFjaztcbiAgICAgICAgICAgIG51bGwgIT09IHVwZGF0ZUxhbmUgJiZcbiAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NCksXG4gICAgICAgICAgICAgIGlzSGlkZGVuVXBkYXRlICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKSxcbiAgICAgICAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0gcXVldWUuY2FsbGJhY2tzKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gaXNIaWRkZW5VcGRhdGVcbiAgICAgICAgICAgICAgICA/IChxdWV1ZS5jYWxsYmFja3MgPSBbdXBkYXRlTGFuZV0pXG4gICAgICAgICAgICAgICAgOiBpc0hpZGRlblVwZGF0ZS5wdXNoKHVwZGF0ZUxhbmUpKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIChpc0hpZGRlblVwZGF0ZSA9IHtcbiAgICAgICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICAgICAgdGFnOiBwZW5kaW5nUXVldWUudGFnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBwZW5kaW5nUXVldWUucGF5bG9hZCxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6IHBlbmRpbmdRdWV1ZS5jYWxsYmFjayxcbiAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgICA/ICgoZmlyc3RQZW5kaW5nVXBkYXRlID0gY3VycmVudCA9IGlzSGlkZGVuVXBkYXRlKSxcbiAgICAgICAgICAgICAgICAgIChsYXN0UGVuZGluZ1VwZGF0ZSA9IG5ld1N0YXRlKSlcbiAgICAgICAgICAgICAgICA6IChjdXJyZW50ID0gY3VycmVudC5uZXh0ID0gaXNIaWRkZW5VcGRhdGUpLFxuICAgICAgICAgICAgICAobGFzdEJhc2VVcGRhdGUgfD0gdXBkYXRlTGFuZSk7XG4gICAgICAgICAgcGVuZGluZ1F1ZXVlID0gcGVuZGluZ1F1ZXVlLm5leHQ7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHBlbmRpbmdRdWV1ZSlcbiAgICAgICAgICAgIGlmICgoKHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nKSwgbnVsbCA9PT0gcGVuZGluZ1F1ZXVlKSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIChpc0hpZGRlblVwZGF0ZSA9IHBlbmRpbmdRdWV1ZSksXG4gICAgICAgICAgICAgICAgKHBlbmRpbmdRdWV1ZSA9IGlzSGlkZGVuVXBkYXRlLm5leHQpLFxuICAgICAgICAgICAgICAgIChpc0hpZGRlblVwZGF0ZS5uZXh0ID0gbnVsbCksXG4gICAgICAgICAgICAgICAgKHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gaXNIaWRkZW5VcGRhdGUpLFxuICAgICAgICAgICAgICAgIChxdWV1ZS5zaGFyZWQucGVuZGluZyA9IG51bGwpO1xuICAgICAgICB9IHdoaWxlICgxKTtcbiAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJiAobGFzdFBlbmRpbmdVcGRhdGUgPSBuZXdTdGF0ZSk7XG4gICAgICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gY3VycmVudDtcbiAgICAgICAgbnVsbCA9PT0gZmlyc3RCYXNlVXBkYXRlICYmIChxdWV1ZS5zaGFyZWQubGFuZXMgPSAwKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IGxhc3RCYXNlVXBkYXRlO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGxhc3RCYXNlVXBkYXRlO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjYWxsYmFjaylcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogXCIgK1xuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgKTtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhpZGRlbkNhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgY29udGV4dCkge1xuICAgICAgdmFyIGhpZGRlbkNhbGxiYWNrcyA9IHVwZGF0ZVF1ZXVlLnNoYXJlZC5oaWRkZW5DYWxsYmFja3M7XG4gICAgICBpZiAobnVsbCAhPT0gaGlkZGVuQ2FsbGJhY2tzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHVwZGF0ZVF1ZXVlLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MgPSBudWxsLCB1cGRhdGVRdWV1ZSA9IDA7XG4gICAgICAgICAgdXBkYXRlUXVldWUgPCBoaWRkZW5DYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlKytcbiAgICAgICAgKVxuICAgICAgICAgIGNhbGxDYWxsYmFjayhoaWRkZW5DYWxsYmFja3NbdXBkYXRlUXVldWVdLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Q2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY2FsbGJhY2tzID0gdXBkYXRlUXVldWUuY2FsbGJhY2tzO1xuICAgICAgaWYgKG51bGwgIT09IGNhbGxiYWNrcylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB1cGRhdGVRdWV1ZS5jYWxsYmFja3MgPSBudWxsLCB1cGRhdGVRdWV1ZSA9IDA7XG4gICAgICAgICAgdXBkYXRlUXVldWUgPCBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlKytcbiAgICAgICAgKVxuICAgICAgICAgIGNhbGxDYWxsYmFjayhjYWxsYmFja3NbdXBkYXRlUXVldWVdLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgICAgIGlmIChvYmplY3RJcyhvYmpBLCBvYmpCKSkgcmV0dXJuICEwO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb2JqQSB8fFxuICAgICAgICBudWxsID09PSBvYmpBIHx8XG4gICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvYmpCIHx8XG4gICAgICAgIG51bGwgPT09IG9iakJcbiAgICAgIClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSksXG4gICAgICAgIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG4gICAgICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgIGZvciAoa2V5c0IgPSAwOyBrZXlzQiA8IGtleXNBLmxlbmd0aDsga2V5c0IrKykge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IGtleXNBW2tleXNCXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGN1cnJlbnRLZXkpIHx8XG4gICAgICAgICAgIW9iamVjdElzKG9iakFbY3VycmVudEtleV0sIG9iakJbY3VycmVudEtleV0pXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRoZW5hYmxlU3RhdGUoKSB7XG4gICAgICByZXR1cm4geyBkaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2U6ICExLCB0aGVuYWJsZXM6IFtdIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVGhlbmFibGVSZXNvbHZlZCh0aGVuYWJsZSkge1xuICAgICAgdGhlbmFibGUgPSB0aGVuYWJsZS5zdGF0dXM7XG4gICAgICByZXR1cm4gXCJmdWxmaWxsZWRcIiA9PT0gdGhlbmFibGUgfHwgXCJyZWplY3RlZFwiID09PSB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCQxKCkge31cbiAgICBmdW5jdGlvbiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpIHtcbiAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICYmXG4gICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5kaWRVc2VQcm9taXNlID0gITApO1xuICAgICAgdmFyIHRyYWNrZWRUaGVuYWJsZXMgPSB0aGVuYWJsZVN0YXRlLnRoZW5hYmxlcztcbiAgICAgIGluZGV4ID0gdHJhY2tlZFRoZW5hYmxlc1tpbmRleF07XG4gICAgICB2b2lkIDAgPT09IGluZGV4XG4gICAgICAgID8gdHJhY2tlZFRoZW5hYmxlcy5wdXNoKHRoZW5hYmxlKVxuICAgICAgICA6IGluZGV4ICE9PSB0aGVuYWJsZSAmJlxuICAgICAgICAgICh0aGVuYWJsZVN0YXRlLmRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZSB8fFxuICAgICAgICAgICAgKCh0aGVuYWJsZVN0YXRlLmRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQSBjb21wb25lbnQgd2FzIHN1c3BlbmRlZCBieSBhbiB1bmNhY2hlZCBwcm9taXNlLiBDcmVhdGluZyBwcm9taXNlcyBpbnNpZGUgYSBDbGllbnQgQ29tcG9uZW50IG9yIGhvb2sgaXMgbm90IHlldCBzdXBwb3J0ZWQsIGV4Y2VwdCB2aWEgYSBTdXNwZW5zZS1jb21wYXRpYmxlIGxpYnJhcnkgb3IgZnJhbWV3b3JrLlwiXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICB0aGVuYWJsZS50aGVuKG5vb3AkMSwgbm9vcCQxKSxcbiAgICAgICAgICAodGhlbmFibGUgPSBpbmRleCkpO1xuICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgKCh0aGVuYWJsZVN0YXRlID0gdGhlbmFibGUucmVhc29uKSxcbiAgICAgICAgICAgIGNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoKHRoZW5hYmxlU3RhdGUpLFxuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZSlcbiAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdGhlbmFibGUuc3RhdHVzKVxuICAgICAgICAgICAgdGhlbmFibGUudGhlbihub29wJDEsIG5vb3AkMSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGVuYWJsZVN0YXRlID0gd29ya0luUHJvZ3Jlc3NSb290O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBudWxsICE9PSB0aGVuYWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgIDEwMCA8IHRoZW5hYmxlU3RhdGUuc2hlbGxTdXNwZW5kQ291bnRlclxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImFzeW5jL2F3YWl0IGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGluIENsaWVudCBDb21wb25lbnRzLCBvbmx5IFNlcnZlciBDb21wb25lbnRzLiBUaGlzIGVycm9yIGlzIG9mdGVuIGNhdXNlZCBieSBhY2NpZGVudGFsbHkgYWRkaW5nIGAndXNlIGNsaWVudCdgIHRvIGEgbW9kdWxlIHRoYXQgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBmb3IgdGhlIHNlcnZlci5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGZ1bGZpbGxlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICAgKCh0aGVuYWJsZVN0YXRlID0gdGhlbmFibGUucmVhc29uKSxcbiAgICAgICAgICAgICAgICBjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaCh0aGVuYWJsZVN0YXRlKSxcbiAgICAgICAgICAgICAgICB0aGVuYWJsZVN0YXRlKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gITA7XG4gICAgICAgICAgdGhyb3cgU3VzcGVuc2VFeGNlcHRpb247XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkge1xuICAgICAgaWYgKG51bGwgPT09IHN1c3BlbmRlZFRoZW5hYmxlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIGEgc3VzcGVuZGVkIHRoZW5hYmxlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgICAgdmFyIHRoZW5hYmxlID0gc3VzcGVuZGVkVGhlbmFibGU7XG4gICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGw7XG4gICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9ICExO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaChyZWplY3RlZFJlYXNvbikge1xuICAgICAgaWYgKHJlamVjdGVkUmVhc29uID09PSBTdXNwZW5zZUV4Y2VwdGlvbilcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJIb29rcyBhcmUgbm90IHN1cHBvcnRlZCBpbnNpZGUgYW4gYXN5bmMgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIG9mdGVuIGNhdXNlZCBieSBhY2NpZGVudGFsbHkgYWRkaW5nIGAndXNlIGNsaWVudCdgIHRvIGEgbW9kdWxlIHRoYXQgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBmb3IgdGhlIHNlcnZlci5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoRGVidWdJbmZvKGRlYnVnSW5mbykge1xuICAgICAgdmFyIHByZXZpb3VzRGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgIG51bGwgIT0gZGVidWdJbmZvICYmXG4gICAgICAgIChjdXJyZW50RGVidWdJbmZvID1cbiAgICAgICAgICBudWxsID09PSBwcmV2aW91c0RlYnVnSW5mb1xuICAgICAgICAgICAgPyBkZWJ1Z0luZm9cbiAgICAgICAgICAgIDogcHJldmlvdXNEZWJ1Z0luZm8uY29uY2F0KGRlYnVnSW5mbykpO1xuICAgICAgcmV0dXJuIHByZXZpb3VzRGVidWdJbmZvO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCwgZmliZXIsIHJldHVybkZpYmVyKSB7XG4gICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoZWxlbWVudC5wcm9wcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKFwiY2hpbGRyZW5cIiAhPT0ga2V5ICYmIFwia2V5XCIgIT09IGtleSkge1xuICAgICAgICAgIG51bGwgPT09IGZpYmVyICYmXG4gICAgICAgICAgICAoKGZpYmVyID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCAwKSksXG4gICAgICAgICAgICAoZmliZXIuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgKGZpYmVyLnJldHVybiA9IHJldHVybkZpYmVyKSk7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcmVkS2V5KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiBSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLlwiLFxuICAgICAgICAgICAgICAgIGVycm9yZWRLZXlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGVuYWJsZUluZGV4Q291bnRlciQxO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSArPSAxO1xuICAgICAgbnVsbCA9PT0gdGhlbmFibGVTdGF0ZSQxICYmICh0aGVuYWJsZVN0YXRlJDEgPSBjcmVhdGVUaGVuYWJsZVN0YXRlKCkpO1xuICAgICAgcmV0dXJuIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUkMSwgdGhlbmFibGUsIGluZGV4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29lcmNlUmVmKHdvcmtJblByb2dyZXNzLCBlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wcm9wcy5yZWY7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSB2b2lkIDAgIT09IGVsZW1lbnQgPyBlbGVtZW50IDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAnQSBSZWFjdCBFbGVtZW50IGZyb20gYW4gb2xkZXIgdmVyc2lvbiBvZiBSZWFjdCB3YXMgcmVuZGVyZWQuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gSXQgY2FuIGhhcHBlbiBpZjpcXG4tIE11bHRpcGxlIGNvcGllcyBvZiB0aGUgXCJyZWFjdFwiIHBhY2thZ2UgaXMgdXNlZC5cXG4tIEEgbGlicmFyeSBwcmUtYnVuZGxlZCBhbiBvbGQgY29weSBvZiBcInJlYWN0XCIgb3IgXCJyZWFjdC9qc3gtcnVudGltZVwiLlxcbi0gQSBjb21waWxlciB0cmllcyB0byBcImlubGluZVwiIEpTWCBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBydW50aW1lLidcbiAgICAgICAgKTtcbiAgICAgIHJldHVybkZpYmVyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKTtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgK1xuICAgICAgICAgIChcIltvYmplY3QgT2JqZWN0XVwiID09PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgPyBcIm9iamVjdCB3aXRoIGtleXMge1wiICsgT2JqZWN0LmtleXMobmV3Q2hpbGQpLmpvaW4oXCIsIFwiKSArIFwifVwiXG4gICAgICAgICAgICA6IHJldHVybkZpYmVyKSArXG4gICAgICAgICAgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgaW52YWxpZENoaWxkKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0gfHxcbiAgICAgICAgKChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0gPSAhMCksXG4gICAgICAgIChpbnZhbGlkQ2hpbGQgPVxuICAgICAgICAgIGludmFsaWRDaGlsZC5kaXNwbGF5TmFtZSB8fCBpbnZhbGlkQ2hpbGQubmFtZSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgMyA9PT0gcmV0dXJuRmliZXIudGFnXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkZ1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiB5b3UgcmV0dXJuICVzIGluc3RlYWQgb2YgPCVzIC8+IGZyb20gcmVuZGVyLiBPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC5cXG4gIHJvb3QucmVuZGVyKCVzKVwiLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkZ1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiB5b3UgcmV0dXJuICVzIGluc3RlYWQgb2YgPCVzIC8+IGZyb20gcmVuZGVyLiBPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC5cXG4gIDwlcz57JXN9PC8lcz5cIixcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIHBhcmVudE5hbWUsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgcGFyZW50TmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIGludmFsaWRDaGlsZCkge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgb3duZXJIYXNTeW1ib2xUeXBlV2FybmluZ1twYXJlbnROYW1lXSB8fFxuICAgICAgICAoKG93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0gPSAhMCksXG4gICAgICAgIChpbnZhbGlkQ2hpbGQgPSBTdHJpbmcoaW52YWxpZENoaWxkKSksXG4gICAgICAgIDMgPT09IHJldHVybkZpYmVyLnRhZ1xuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTeW1ib2xzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC5cXG4gIHJvb3QucmVuZGVyKCVzKVwiLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGRcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiU3ltYm9scyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuXFxuICA8JXM+JXM8LyVzPlwiLFxuICAgICAgICAgICAgICBwYXJlbnROYW1lLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIHBhcmVudE5hbWVcbiAgICAgICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZFJlY29uY2lsZXIoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuICAgICAgICAgIG51bGwgPT09IGRlbGV0aW9uc1xuICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjaGlsZFRvRGVsZXRlXSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlci5mbGFncyB8PSAxNikpXG4gICAgICAgICAgICA6IGRlbGV0aW9ucy5wdXNoKGNoaWxkVG9EZWxldGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAgICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICg7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSxcbiAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1hcFJlbWFpbmluZ0NoaWxkcmVuKGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgICAgIGZvciAodmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQua2V5XG4gICAgICAgICAgICA/IGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGN1cnJlbnRGaXJzdENoaWxkLmtleSwgY3VycmVudEZpcnN0Q2hpbGQpXG4gICAgICAgICAgICA6IGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGN1cnJlbnRGaXJzdENoaWxkLmluZGV4LCBjdXJyZW50Rmlyc3RDaGlsZCksXG4gICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzKSB7XG4gICAgICAgIGZpYmVyID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoZmliZXIsIHBlbmRpbmdQcm9wcyk7XG4gICAgICAgIGZpYmVyLmluZGV4ID0gMDtcbiAgICAgICAgZmliZXIuc2libGluZyA9IG51bGw7XG4gICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICAgICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcbiAgICAgICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKVxuICAgICAgICAgIHJldHVybiAobmV3RmliZXIuZmxhZ3MgfD0gMTA0ODU3NiksIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgICAgbmV3SW5kZXggPSBuZXdGaWJlci5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChudWxsICE9PSBuZXdJbmRleClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKG5ld0luZGV4ID0gbmV3SW5kZXguaW5kZXgpLFxuICAgICAgICAgICAgbmV3SW5kZXggPCBsYXN0UGxhY2VkSW5kZXhcbiAgICAgICAgICAgICAgPyAoKG5ld0ZpYmVyLmZsYWdzIHw9IDMzNTU0NDM0KSwgbGFzdFBsYWNlZEluZGV4KVxuICAgICAgICAgICAgICA6IG5ld0luZGV4XG4gICAgICAgICAgKTtcbiAgICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gMzM1NTQ0MzQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKSB7XG4gICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICBudWxsID09PSBuZXdGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAobmV3RmliZXIuZmxhZ3MgfD0gMzM1NTQ0MzQpO1xuICAgICAgICByZXR1cm4gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudCwgdGV4dENvbnRlbnQsIGxhbmVzKSB7XG4gICAgICAgIGlmIChudWxsID09PSBjdXJyZW50IHx8IDYgIT09IGN1cnJlbnQudGFnKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoXG4gICAgICAgICAgICAgIHRleHRDb250ZW50LFxuICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAoY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgdGV4dENvbnRlbnQpO1xuICAgICAgICBjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICBjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQsIGxhbmVzKSB7XG4gICAgICAgIHZhciBlbGVtZW50VHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IHVwZGF0ZUZyYWdtZW50KFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgZWxlbWVudC5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIGVsZW1lbnQua2V5XG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50LCBjdXJyZW50LCByZXR1cm5GaWJlciksXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAoY3VycmVudC5lbGVtZW50VHlwZSA9PT0gZWxlbWVudFR5cGUgfHxcbiAgICAgICAgICAgIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhjdXJyZW50LCBlbGVtZW50KSB8fFxuICAgICAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBlbGVtZW50VHlwZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBlbGVtZW50VHlwZSAmJlxuICAgICAgICAgICAgICBlbGVtZW50VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgIGNhbGxMYXp5SW5pdEluREVWKGVsZW1lbnRUeXBlKSA9PT0gY3VycmVudC50eXBlKSlcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IHVzZUZpYmVyKGN1cnJlbnQsIGVsZW1lbnQucHJvcHMpKSxcbiAgICAgICAgICAgIGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KSxcbiAgICAgICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgICAgY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgICBjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICBjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBsYW5lcykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgIDQgIT09IGN1cnJlbnQudGFnIHx8XG4gICAgICAgICAgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHxcbiAgICAgICAgICBjdXJyZW50LnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiAhPT0gcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcykpLFxuICAgICAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgICBjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICBjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgbGFuZXMsIGtleSkge1xuICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCA3ICE9PSBjdXJyZW50LnRhZylcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgZnJhZ21lbnQsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnT3duZXIgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudCA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50KTtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChuZXdDaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoXG4gICAgICAgICAgICAgIFwiXCIgKyBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKG5ld0NoaWxkLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChuZXdDaGlsZC5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChuZXdDaGlsZC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgbnVsbCAhPT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAobGFuZXMgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KFxuICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBjb2VyY2VSZWYobGFuZXMsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKG5ld0NoaWxkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKFxuICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAobmV3Q2hpbGQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICB2YXIgX3ByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IF9wcmV2RGVidWdJbmZvO1xuICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuRmliZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAobGFuZXMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgIChsYW5lcy5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChfcHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBjcmVhdGVDaGlsZChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gX3ByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgICAgIHZhciBrZXkgPSBudWxsICE9PSBvbGRGaWJlciA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIG51bGwgIT09IGtleVxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgXCJcIiArIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgbnVsbCAhPT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkLmtleSA9PT0ga2V5XG4gICAgICAgICAgICAgICAgPyAoKGtleSA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBrZXkpLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkLmtleSA9PT0ga2V5XG4gICAgICAgICAgICAgICAgPyB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKGtleSA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKG5ld0NoaWxkKSksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBrZXkpLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBrZXkpIHJldHVybiBudWxsO1xuICAgICAgICAgICAga2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgIHJldHVybkZpYmVyID0gdXBkYXRlRnJhZ21lbnQoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IGtleTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoa2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZVNsb3QoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGtleSksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoXG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4sXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBuZXdJZHgsXG4gICAgICAgIG5ld0NoaWxkLFxuICAgICAgICBsYW5lc1xuICAgICAgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsKSxcbiAgICAgICAgICAgIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBleGlzdGluZ0NoaWxkcmVuLCBcIlwiICsgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgbnVsbCAhPT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAobmV3SWR4ID1cbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSBuZXdDaGlsZC5rZXkgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXlcbiAgICAgICAgICAgICAgICAgICkgfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgKGV4aXN0aW5nQ2hpbGRyZW4gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBleGlzdGluZ0NoaWxkcmVuKSxcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmdldChcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV3Q2hpbGQua2V5ID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5XG4gICAgICAgICAgICAgICAgICApIHx8IG51bGwpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgZXhpc3RpbmdDaGlsZHJlbiwgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHZhciBfcHJldkRlYnVnSW5mbzcgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSB1cGRhdGVGcm9tTWFwKFxuICAgICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBfcHJldkRlYnVnSW5mbzc7XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSlcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChuZXdJZHggPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGwpLFxuICAgICAgICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVGcmFnbWVudChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBleGlzdGluZ0NoaWxkcmVuKSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoX3ByZXZEZWJ1Z0luZm83ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IF9wcmV2RGVidWdJbmZvNyksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KHJldHVybkZpYmVyLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGQsIGtub3duS2V5cykge1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGNoaWxkIHx8IG51bGwgPT09IGNoaWxkKSByZXR1cm4ga25vd25LZXlzO1xuICAgICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KHJldHVybkZpYmVyLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGQpO1xuICAgICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2Yga2V5KSBicmVhaztcbiAgICAgICAgICAgIGlmIChudWxsID09PSBrbm93bktleXMpIHtcbiAgICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKHdvcmtJblByb2dyZXNzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuIEtleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCBcXHUyMDE0IHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uXCIsXG4gICAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgKGNoaWxkID0gY2FsbExhenlJbml0SW5ERVYoY2hpbGQpKSxcbiAgICAgICAgICAgICAgd2Fybk9uSW52YWxpZEtleShyZXR1cm5GaWJlciwgd29ya0luUHJvZ3Jlc3MsIGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KFxuICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgIG5ld0NoaWxkcmVuLFxuICAgICAgICBsYW5lc1xuICAgICAgKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGwsXG4gICAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbCxcbiAgICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBudWxsLFxuICAgICAgICAgICAgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgIG5ld0lkeCA9IChjdXJyZW50Rmlyc3RDaGlsZCA9IDApLFxuICAgICAgICAgICAgbmV4dE9sZEZpYmVyID0gbnVsbDtcbiAgICAgICAgICBudWxsICE9PSBvbGRGaWJlciAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgbmV3SWR4KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgb2xkRmliZXIuaW5kZXggPiBuZXdJZHhcbiAgICAgICAgICAgID8gKChuZXh0T2xkRmliZXIgPSBvbGRGaWJlciksIChvbGRGaWJlciA9IG51bGwpKVxuICAgICAgICAgICAgOiAobmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZyk7XG4gICAgICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChudWxsID09PSBuZXdGaWJlcikge1xuICAgICAgICAgICAgbnVsbCA9PT0gb2xkRmliZXIgJiYgKG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdGaWJlcixcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICApO1xuICAgICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICAgIG9sZEZpYmVyICYmXG4gICAgICAgICAgICBudWxsID09PSBuZXdGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3SWR4KTtcbiAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXIpXG4gICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcik7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdJZHggPT09IG5ld0NoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKSxcbiAgICAgICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KSxcbiAgICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBpZiAobnVsbCA9PT0gb2xkRmliZXIpIHtcbiAgICAgICAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKylcbiAgICAgICAgICAgIChvbGRGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcykpLFxuICAgICAgICAgICAgICBudWxsICE9PSBvbGRGaWJlciAmJlxuICAgICAgICAgICAgICAgICgoa25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChcbiAgICAgICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICBuZXdJZHhcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gb2xkRmliZXIpXG4gICAgICAgICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBvbGRGaWJlciksXG4gICAgICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBvbGRGaWJlcikpO1xuICAgICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIG9sZEZpYmVyID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ob2xkRmliZXIpO1xuICAgICAgICAgIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBuZXdJZHgrK1xuICAgICAgICApXG4gICAgICAgICAgKG5leHRPbGRGaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKSksXG4gICAgICAgICAgICBudWxsICE9PSBuZXh0T2xkRmliZXIgJiZcbiAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5leHRPbGRGaWJlcixcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICBvbGRGaWJlci5kZWxldGUoXG4gICAgICAgICAgICAgICAgICBudWxsID09PSBuZXh0T2xkRmliZXIua2V5ID8gbmV3SWR4IDogbmV4dE9sZEZpYmVyLmtleVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQoXG4gICAgICAgICAgICAgICAgbmV4dE9sZEZpYmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXh0T2xkRmliZXIpXG4gICAgICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV4dE9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBuZXh0T2xkRmliZXIpKTtcbiAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgIG9sZEZpYmVyLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3Q2hpbGRyZW4sXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKG51bGwgPT0gbmV3Q2hpbGRyZW4pXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuXCIpO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbCxcbiAgICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBudWxsLFxuICAgICAgICAgICAgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgIG5ld0lkeCA9IChjdXJyZW50Rmlyc3RDaGlsZCA9IDApLFxuICAgICAgICAgICAgbmV4dE9sZEZpYmVyID0gbnVsbCxcbiAgICAgICAgICAgIGtub3duS2V5cyA9IG51bGwsXG4gICAgICAgICAgICBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmICFzdGVwLmRvbmU7XG4gICAgICAgICAgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KClcbiAgICAgICAgKSB7XG4gICAgICAgICAgb2xkRmliZXIuaW5kZXggPiBuZXdJZHhcbiAgICAgICAgICAgID8gKChuZXh0T2xkRmliZXIgPSBvbGRGaWJlciksIChvbGRGaWJlciA9IG51bGwpKVxuICAgICAgICAgICAgOiAobmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZyk7XG4gICAgICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gbmV3RmliZXIpIHtcbiAgICAgICAgICAgIG51bGwgPT09IG9sZEZpYmVyICYmIChvbGRGaWJlciA9IG5leHRPbGRGaWJlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgbmV3RmliZXIsXG4gICAgICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICBvbGRGaWJlciAmJlxuICAgICAgICAgICAgbnVsbCA9PT0gbmV3RmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChuZXdGaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0lkeCk7XG4gICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgPyAocmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyKVxuICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXIpO1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RlcC5kb25lKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpLFxuICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpLFxuICAgICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChudWxsID09PSBvbGRGaWJlcikge1xuICAgICAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSlcbiAgICAgICAgICAgIChvbGRGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBzdGVwLnZhbHVlLCBsYW5lcykpLFxuICAgICAgICAgICAgICBudWxsICE9PSBvbGRGaWJlciAmJlxuICAgICAgICAgICAgICAgICgoa25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChcbiAgICAgICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICBuZXdJZHhcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gb2xkRmliZXIpXG4gICAgICAgICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBvbGRGaWJlciksXG4gICAgICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBvbGRGaWJlcikpO1xuICAgICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIG9sZEZpYmVyID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ob2xkRmliZXIpO1xuICAgICAgICAgICFzdGVwLmRvbmU7XG4gICAgICAgICAgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KClcbiAgICAgICAgKVxuICAgICAgICAgIChuZXh0T2xkRmliZXIgPSB1cGRhdGVGcm9tTWFwKFxuICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICkpLFxuICAgICAgICAgICAgbnVsbCAhPT0gbmV4dE9sZEZpYmVyICYmXG4gICAgICAgICAgICAgICgoa25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBuZXh0T2xkRmliZXIsXG4gICAgICAgICAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0T2xkRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgb2xkRmliZXIuZGVsZXRlKFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV4dE9sZEZpYmVyLmtleSA/IG5ld0lkeCA6IG5leHRPbGRGaWJlci5rZXlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICAgIG5leHRPbGRGaWJlcixcbiAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICBuZXdJZHhcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gbmV4dE9sZEZpYmVyKVxuICAgICAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5leHRPbGRGaWJlciksXG4gICAgICAgICAgICAgIChwcmV2aW91c05ld0ZpYmVyID0gbmV4dE9sZEZpYmVyKSk7XG4gICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICBvbGRGaWJlci5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmXG4gICAgICAgICAgbnVsbCAhPT0gbmV3Q2hpbGQgJiZcbiAgICAgICAgICBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmXG4gICAgICAgICAgbnVsbCA9PT0gbmV3Q2hpbGQua2V5ICYmXG4gICAgICAgICAgKHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhuZXdDaGlsZCwgbnVsbCwgcmV0dXJuRmliZXIpLFxuICAgICAgICAgIChuZXdDaGlsZCA9IG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgbnVsbCAhPT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIHByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5ID0gbmV3Q2hpbGQua2V5OyBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDsgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gbmV3Q2hpbGQudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICg3ID09PSBjdXJyZW50Rmlyc3RDaGlsZC50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVzID0gdXNlRmliZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZXMuX2RlYnVnT3duZXIgPSBuZXdDaGlsZC5fb3duZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhuZXdDaGlsZCwgbGFuZXMsIHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5lbGVtZW50VHlwZSA9PT0ga2V5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICAgICAgICAgICAgICAgICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIGtleSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0ga2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbExhenlJbml0SW5ERVYoa2V5KSA9PT0gY3VycmVudEZpcnN0Q2hpbGQudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb2VyY2VSZWYobGFuZXMsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5fZGVidWdPd25lciA9IG5ld0NoaWxkLl9vd25lcjtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGxhbmVzO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQuc2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRVxuICAgICAgICAgICAgICAgICAgPyAoKGxhbmVzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5rZXlcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKG5ld0NoaWxkLCBsYW5lcywgcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpXG4gICAgICAgICAgICAgICAgICA6ICgobGFuZXMgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIGNvZXJjZVJlZihsYW5lcywgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybkZpYmVyID0gcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcik7XG4gICAgICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvO1xuICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mbyA9IG5ld0NoaWxkO1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IHByZXZEZWJ1Z0luZm8ua2V5O1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZC5rZXkgPT09IG5ld0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgNCA9PT0gY3VycmVudEZpcnN0Q2hpbGQudGFnICYmXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvLmNvbnRhaW5lckluZm8gJiZcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvLmltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcyA9IHVzZUZpYmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvLmNoaWxkcmVuIHx8IFtdXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGxhbmVzO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChcbiAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8sXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmV0dXJuRmliZXIpO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKHByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgICAobmV3Q2hpbGQgPSBjYWxsTGF6eUluaXRJbkRFVihuZXdDaGlsZCkpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgICAgICBwcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgIGtleSA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpO1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGtleSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSBrZXkuY2FsbChuZXdDaGlsZCk7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGRyZW4gPT09IG5ld0NoaWxkKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAwICE9PSByZXR1cm5GaWJlci50YWcgfHxcbiAgICAgICAgICAgICAgICBcIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dXCIgIT09XG4gICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmV0dXJuRmliZXIudHlwZSkgfHxcbiAgICAgICAgICAgICAgICBcIltvYmplY3QgR2VuZXJhdG9yXVwiICE9PVxuICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkcmVuKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyB8fFxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJVc2luZyBJdGVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkIHVuZXhwZWN0ZWQgcmVzdWx0cyBiZWNhdXNlIGVudW1lcmF0aW5nIGEgZ2VuZXJhdG9yIG11dGF0ZXMgaXQuIFlvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSBgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIFlvdSBjYW4gYWxzbyB1c2UgYW4gSXRlcmFibGUgdGhhdCBjYW4gaXRlcmF0ZSBtdWx0aXBsZSB0aW1lcyBvdmVyIHRoZSBzYW1lIGl0ZW1zLlwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSAhMCk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgbmV3Q2hpbGQuZW50cmllcyAhPT0ga2V5IHx8XG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0TWFwcyB8fFxuICAgICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRNYXBzID0gITApKTtcbiAgICAgICAgICAgIHJldHVybkZpYmVyID0gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICBuZXdDaGlsZHJlbixcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gcHJldkRlYnVnSW5mbztcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBcIlwiICE9PSBuZXdDaGlsZCkgfHxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgbmV3Q2hpbGQgfHxcbiAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgbmV3Q2hpbGRcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IFwiXCIgKyBuZXdDaGlsZCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZCAmJiA2ID09PSBjdXJyZW50Rmlyc3RDaGlsZC50YWdcbiAgICAgICAgICAgICAgPyAoZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmdcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChsYW5lcyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCBwcmV2RGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpXG4gICAgICAgICAgICAgIDogKGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCksXG4gICAgICAgICAgICAgICAgKGxhbmVzID0gY3JlYXRlRmliZXJGcm9tVGV4dChcbiAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8sXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSksXG4gICAgICAgICAgICBwbGFjZVNpbmdsZUNoaWxkKHJldHVybkZpYmVyKVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmXG4gICAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgICAgICB2YXIgcHJldkRlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwO1xuICAgICAgICAgIHZhciBmaXJzdENoaWxkRmliZXIgPSByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhlbmFibGVTdGF0ZSQxID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gZmlyc3RDaGlsZEZpYmVyO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgaWYgKHggPT09IFN1c3BlbnNlRXhjZXB0aW9uKSB0aHJvdyB4O1xuICAgICAgICAgIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKDI5LCB4LCBudWxsLCByZXR1cm5GaWJlci5tb2RlKTtcbiAgICAgICAgICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICAgICAgICAgIGZpYmVyLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHZhciBkZWJ1Z0luZm8gPSAoZmliZXIuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pO1xuICAgICAgICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIuX2RlYnVnT3duZXI7XG4gICAgICAgICAgaWYgKG51bGwgIT0gZGVidWdJbmZvKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlYnVnSW5mby5sZW5ndGggLSAxOyAwIDw9IGk7IGktLSlcbiAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBkZWJ1Z0luZm9baV0uc3RhY2spIHtcbiAgICAgICAgICAgICAgICBmaWJlci5fZGVidWdPd25lciA9IGRlYnVnSW5mb1tpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gcHJldkRlYnVnSW5mbztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEhpZGRlbkNvbnRleHQoZmliZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXMgPSBlbnRhbmdsZWRSZW5kZXJMYW5lcztcbiAgICAgIHB1c2gocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLCBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXMsIGZpYmVyKTtcbiAgICAgIHB1c2goY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciwgY29udGV4dCwgZmliZXIpO1xuICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXMgfCBjb250ZXh0LmJhc2VMYW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayhmaWJlcikge1xuICAgICAgcHVzaChwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IsIGVudGFuZ2xlZFJlbmRlckxhbmVzLCBmaWJlcik7XG4gICAgICBwdXNoKFxuICAgICAgICBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLFxuICAgICAgICBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLmN1cnJlbnQsXG4gICAgICAgIGZpYmVyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BIaWRkZW5Db250ZXh0KGZpYmVyKSB7XG4gICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvci5jdXJyZW50O1xuICAgICAgcG9wKGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICAgIHBvcChwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IsIGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaGFuZGxlci5hbHRlcm5hdGU7XG4gICAgICBwdXNoKFxuICAgICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yLFxuICAgICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayxcbiAgICAgICAgaGFuZGxlclxuICAgICAgKTtcbiAgICAgIHB1c2goc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGhhbmRsZXIsIGhhbmRsZXIpO1xuICAgICAgbnVsbCA9PT0gc2hlbGxCb3VuZGFyeSAmJlxuICAgICAgICAobnVsbCA9PT0gY3VycmVudCB8fCBudWxsICE9PSBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLmN1cnJlbnRcbiAgICAgICAgICA/IChzaGVsbEJvdW5kYXJ5ID0gaGFuZGxlcilcbiAgICAgICAgICA6IG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJiAoc2hlbGxCb3VuZGFyeSA9IGhhbmRsZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlcihmaWJlcikge1xuICAgICAgaWYgKDIyID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgZmliZXIpLFxuICAgICAgICAgIHB1c2goc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlciksXG4gICAgICAgICAgbnVsbCA9PT0gc2hlbGxCb3VuZGFyeSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAoc2hlbGxCb3VuZGFyeSA9IGZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayhmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayhmaWJlcikge1xuICAgICAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIGZpYmVyKTtcbiAgICAgIHB1c2goXG4gICAgICAgIHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLFxuICAgICAgICBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50LFxuICAgICAgICBmaWJlclxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wU3VzcGVuc2VIYW5kbGVyKGZpYmVyKSB7XG4gICAgICBwb3Aoc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICAgIHNoZWxsQm91bmRhcnkgPT09IGZpYmVyICYmIChzaGVsbEJvdW5kYXJ5ID0gbnVsbCk7XG4gICAgICBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kRmlyc3RTdXNwZW5kZWQocm93KSB7XG4gICAgICBmb3IgKHZhciBub2RlID0gcm93OyBudWxsICE9PSBub2RlOyApIHtcbiAgICAgICAgaWYgKDEzID09PSBub2RlLnRhZykge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IG5vZGUubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsICE9PSBzdGF0ZSAmJlxuICAgICAgICAgICAgKChzdGF0ZSA9IHN0YXRlLmRlaHlkcmF0ZWQpLFxuICAgICAgICAgICAgbnVsbCA9PT0gc3RhdGUgfHxcbiAgICAgICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhzdGF0ZSkgfHxcbiAgICAgICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soc3RhdGUpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIDE5ID09PSBub2RlLnRhZyAmJlxuICAgICAgICAgIHZvaWQgMCAhPT0gbm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICgwICE9PSAobm9kZS5mbGFncyAmIDEyOCkpIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2UgaWYgKG51bGwgIT09IG5vZGUuY2hpbGQpIHtcbiAgICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT09IHJvdykgYnJlYWs7XG4gICAgICAgIGZvciAoOyBudWxsID09PSBub2RlLnNpYmxpbmc7ICkge1xuICAgICAgICAgIGlmIChudWxsID09PSBub2RlLnJldHVybiB8fCBub2RlLnJldHVybiA9PT0gcm93KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50SG9va1R5cGVzRGV2KCkge1xuICAgICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG4gICAgICBudWxsID09PSBob29rVHlwZXNEZXZcbiAgICAgICAgPyAoaG9va1R5cGVzRGV2ID0gW2hvb2tOYW1lXSlcbiAgICAgICAgOiBob29rVHlwZXNEZXYucHVzaChob29rTmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUhvb2tUeXBlc0RldigpIHtcbiAgICAgIHZhciBob29rTmFtZSA9IGN1cnJlbnRIb29rTmFtZUluRGV2O1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSBob29rVHlwZXNEZXYgJiZcbiAgICAgICAgKGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2KyssXG4gICAgICAgIGhvb2tUeXBlc0Rldltob29rVHlwZXNVcGRhdGVJbmRleERldl0gIT09IGhvb2tOYW1lKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihcbiAgICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxXG4gICAgICAgICk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSAmJlxuICAgICAgICAgIChkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpLFxuICAgICAgICAgIG51bGwgIT09IGhvb2tUeXBlc0RldilcbiAgICAgICAgKSB7XG4gICAgICAgICAgZm9yICh2YXIgdGFibGUgPSBcIlwiLCBpID0gMDsgaSA8PSBob29rVHlwZXNVcGRhdGVJbmRleERldjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2xkSG9va05hbWUgPSBob29rVHlwZXNEZXZbaV0sXG4gICAgICAgICAgICAgIG5ld0hvb2tOYW1lID1cbiAgICAgICAgICAgICAgICBpID09PSBob29rVHlwZXNVcGRhdGVJbmRleERldiA/IGhvb2tOYW1lIDogb2xkSG9va05hbWU7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBvbGRIb29rTmFtZSA9IGkgKyAxICsgXCIuIFwiICsgb2xkSG9va05hbWU7XG4gICAgICAgICAgICAgIDMwID4gb2xkSG9va05hbWUubGVuZ3RoO1xuXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIG9sZEhvb2tOYW1lICs9IFwiIFwiO1xuICAgICAgICAgICAgb2xkSG9va05hbWUgKz0gbmV3SG9va05hbWUgKyBcIlxcblwiO1xuICAgICAgICAgICAgdGFibGUgKz0gb2xkSG9va05hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0IGhhcyBkZXRlY3RlZCBhIGNoYW5nZSBpbiB0aGUgb3JkZXIgb2YgSG9va3MgY2FsbGVkIGJ5ICVzLiBUaGlzIHdpbGwgbGVhZCB0byBidWdzIGFuZCBlcnJvcnMgaWYgbm90IGZpeGVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVhZCB0aGUgUnVsZXMgb2YgSG9va3M6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvcnVsZXMtb2YtaG9va3NcXG5cXG4gICBQcmV2aW91cyByZW5kZXIgICAgICAgICAgICBOZXh0IHJlbmRlclxcbiAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiVzICAgXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXFxuXCIsXG4gICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgdGFibGVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpIHtcbiAgICAgIHZvaWQgMCA9PT0gZGVwcyB8fFxuICAgICAgICBudWxsID09PSBkZXBzIHx8XG4gICAgICAgIGlzQXJyYXlJbXBsKGRlcHMpIHx8XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCIlcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IHRoYXQgaXMgbm90IGFuIGFycmF5IChpbnN0ZWFkLCByZWNlaXZlZCBgJXNgKS4gV2hlbiBzcGVjaWZpZWQsIHRoZSBmaW5hbCBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5LlwiLFxuICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2LFxuICAgICAgICAgIHR5cGVvZiBkZXBzXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO1xuICAgICAgZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlLmhhcyhjb21wb25lbnROYW1lKSB8fFxuICAgICAgICAoZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlLmFkZChjb21wb25lbnROYW1lKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0RE9NLnVzZUZvcm1TdGF0ZSBoYXMgYmVlbiByZW5hbWVkIHRvIFJlYWN0LnVzZUFjdGlvblN0YXRlLiBQbGVhc2UgdXBkYXRlICVzIHRvIHVzZSBSZWFjdC51c2VBY3Rpb25TdGF0ZS5cIixcbiAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0ludmFsaWRIb29rRXJyb3IoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAgICAgIGlmIChpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcykgcmV0dXJuICExO1xuICAgICAgaWYgKG51bGwgPT09IHByZXZEZXBzKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsIGl0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLlwiLFxuICAgICAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXZcbiAgICAgICAgICApLFxuICAgICAgICAgICExXG4gICAgICAgICk7XG4gICAgICBuZXh0RGVwcy5sZW5ndGggIT09IHByZXZEZXBzLmxlbmd0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG5QcmV2aW91czogJXNcXG5JbmNvbWluZzogJXNcIixcbiAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldixcbiAgICAgICAgICBcIltcIiArIHByZXZEZXBzLmpvaW4oXCIsIFwiKSArIFwiXVwiLFxuICAgICAgICAgIFwiW1wiICsgbmV4dERlcHMuam9pbihcIiwgXCIpICsgXCJdXCJcbiAgICAgICAgKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFvYmplY3RJcyhuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSByZXR1cm4gITE7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHByb3BzLFxuICAgICAgc2Vjb25kQXJnLFxuICAgICAgbmV4dFJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICByZW5kZXJMYW5lcyA9IG5leHRSZW5kZXJMYW5lcztcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIGhvb2tUeXBlc0RldiA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlcyA6IG51bGw7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPVxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIGN1cnJlbnQudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgIGlmIChcbiAgICAgICAgXCJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dXCIgPT09XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKENvbXBvbmVudCkgfHxcbiAgICAgICAgXCJbb2JqZWN0IEFzeW5jR2VuZXJhdG9yRnVuY3Rpb25dXCIgPT09XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKENvbXBvbmVudClcbiAgICAgIClcbiAgICAgICAgKG5leHRSZW5kZXJMYW5lcyA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoXG4gICAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMVxuICAgICAgICApKSxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudC5oYXMobmV4dFJlbmRlckxhbmVzKSB8fFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50LmFkZChuZXh0UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJhc3luYy9hd2FpdCBpcyBub3QgeWV0IHN1cHBvcnRlZCBpbiBDbGllbnQgQ29tcG9uZW50cywgb25seSBTZXJ2ZXIgQ29tcG9uZW50cy4gVGhpcyBlcnJvciBpcyBvZnRlbiBjYXVzZWQgYnkgYWNjaWRlbnRhbGx5IGFkZGluZyBgJ3VzZSBjbGllbnQnYCB0byBhIG1vZHVsZSB0aGF0IHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gZm9yIHRoZSBzZXJ2ZXIuXCJcbiAgICAgICAgICAgICkpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDA7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID1cbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICA/IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVZcbiAgICAgICAgICA6IG51bGwgIT09IGhvb2tUeXBlc0RldlxuICAgICAgICAgICAgPyBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWXG4gICAgICAgICAgICA6IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWID0gbmV4dFJlbmRlckxhbmVzID1cbiAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiA4KSAhPT0gTm9Nb2RlO1xuICAgICAgdmFyIGNoaWxkcmVuID0gY2FsbENvbXBvbmVudEluREVWKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9ICExO1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzICYmXG4gICAgICAgIChjaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rc0FnYWluKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBzZWNvbmRBcmdcbiAgICAgICAgKSk7XG4gICAgICBpZiAobmV4dFJlbmRlckxhbmVzKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rc0FnYWluKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHNlY29uZEFyZ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaFJlbmRlcmluZ0hvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXMgPSBob29rVHlwZXNEZXY7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXNcbiAgICAgICAgPyBudWxsICE9PSB0aGVuYWJsZVN0YXRlICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgICAgIGxhbmVzOiAwLFxuICAgICAgICAgICAgZmlyc3RDb250ZXh0OiBudWxsLFxuICAgICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogdGhlbmFibGVTdGF0ZVxuICAgICAgICAgIH0pXG4gICAgICAgIDogKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcy5fZGVidWdUaGVuYWJsZVN0YXRlID0gdGhlbmFibGVTdGF0ZSk7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICAgICAgdmFyIGRpZFJlbmRlclRvb0Zld0hvb2tzID1cbiAgICAgICAgbnVsbCAhPT0gY3VycmVudEhvb2sgJiYgbnVsbCAhPT0gY3VycmVudEhvb2submV4dDtcbiAgICAgIHJlbmRlckxhbmVzID0gMDtcbiAgICAgIGhvb2tUeXBlc0RldiA9XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID1cbiAgICAgICAgY3VycmVudEhvb2sgPVxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID1cbiAgICAgICAgICBudWxsO1xuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgKGN1cnJlbnQuZmxhZ3MgJiAzMTQ1NzI4MCkgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDMxNDU3MjgwKSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEV4cGVjdGVkIHN0YXRpYyBmbGFnIHdhcyBtaXNzaW5nLiBQbGVhc2Ugbm90aWZ5IHRoZSBSZWFjdCB0ZWFtLlwiXG4gICAgICAgICk7XG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITE7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgICAgIGlmIChkaWRSZW5kZXJUb29GZXdIb29rcylcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJSZW5kZXJlZCBmZXdlciBob29rcyB0aGFuIGV4cGVjdGVkLiBUaGlzIG1heSBiZSBjYXVzZWQgYnkgYW4gYWNjaWRlbnRhbCBlYXJseSByZXR1cm4gc3RhdGVtZW50LlwiXG4gICAgICAgICk7XG4gICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgfHxcbiAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC5kZXBlbmRlbmNpZXMpLFxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnQpICYmXG4gICAgICAgICAgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCkpO1xuICAgICAgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVZcbiAgICAgICAgPyAoKG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gITEpLCAoY3VycmVudCA9ICEwKSlcbiAgICAgICAgOiAoY3VycmVudCA9ICExKTtcbiAgICAgIGN1cnJlbnQgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgXCJVbmtub3duXCIpLFxuICAgICAgICBkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaC5oYXMod29ya0luUHJvZ3Jlc3MpIHx8XG4gICAgICAgICAgZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQuaGFzKHdvcmtJblByb2dyZXNzKSB8fFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaC5hZGQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImB1c2VgIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSB0cnkvY2F0Y2ggYmxvY2suIFRoaXMgaXMgbm90IGFsbG93ZWQgYW5kIGNhbiBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIFRvIGhhbmRsZSBlcnJvcnMgdHJpZ2dlcmVkIGJ5IGB1c2VgLCB3cmFwIHlvdXIgY29tcG9uZW50IGluIGEgZXJyb3IgYm91bmRhcnkuXCJcbiAgICAgICAgICApKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlcldpdGhIb29rc0FnYWluKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyAmJiAodGhlbmFibGVTdGF0ZSA9IG51bGwpO1xuICAgICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9ICExO1xuICAgICAgICBpZiAobnVtYmVyT2ZSZVJlbmRlcnMgPj0gUkVfUkVOREVSX0xJTUlUKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7XG4gICAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gITE7XG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRIb29rID0gbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBjaGlsZHJlbi5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICBjaGlsZHJlbi5ldmVudHMgPSBudWxsO1xuICAgICAgICAgIGNoaWxkcmVuLnN0b3JlcyA9IG51bGw7XG4gICAgICAgICAgbnVsbCAhPSBjaGlsZHJlbi5tZW1vQ2FjaGUgJiYgKGNoaWxkcmVuLm1lbW9DYWNoZS5pbmRleCA9IDApO1xuICAgICAgICB9XG4gICAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG4gICAgICAgIGNoaWxkcmVuID0gY2FsbENvbXBvbmVudEluREVWKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICB9IHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpO1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50KCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5ILFxuICAgICAgICBtYXliZVRoZW5hYmxlID0gZGlzcGF0Y2hlci51c2VTdGF0ZSgpWzBdO1xuICAgICAgbWF5YmVUaGVuYWJsZSA9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1heWJlVGhlbmFibGUudGhlblxuICAgICAgICAgID8gdXNlVGhlbmFibGUobWF5YmVUaGVuYWJsZSlcbiAgICAgICAgICA6IG1heWJlVGhlbmFibGU7XG4gICAgICBkaXNwYXRjaGVyID0gZGlzcGF0Y2hlci51c2VTdGF0ZSgpWzBdO1xuICAgICAgKG51bGwgIT09IGN1cnJlbnRIb29rID8gY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSA6IG51bGwpICE9PVxuICAgICAgICBkaXNwYXRjaGVyICYmIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IDEwMjQpO1xuICAgICAgcmV0dXJuIG1heWJlVGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrRGlkUmVuZGVySWRIb29rKCkge1xuICAgICAgdmFyIGRpZFJlbmRlcklkSG9vayA9IDAgIT09IGxvY2FsSWRDb3VudGVyO1xuICAgICAgbG9jYWxJZENvdW50ZXIgPSAwO1xuICAgICAgcmV0dXJuIGRpZFJlbmRlcklkSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBsYW5lcykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPVxuICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDE2KSAhPT0gTm9Nb2RlXG4gICAgICAgICAgPyB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIC0yMDEzMjg2NDVcbiAgICAgICAgICA6IHdvcmtJblByb2dyZXNzLmZsYWdzICYgLTIwNTM7XG4gICAgICBjdXJyZW50LmxhbmVzICY9IH5sYW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRIb29rc09uVW53aW5kKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBpZiAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcztcblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy5xdWV1ZTtcbiAgICAgICAgICBudWxsICE9PSBxdWV1ZSAmJiAocXVldWUucGVuZGluZyA9IG51bGwpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITE7XG4gICAgICB9XG4gICAgICByZW5kZXJMYW5lcyA9IDA7XG4gICAgICBob29rVHlwZXNEZXYgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgICAgICBjdXJyZW50SG9vayA9XG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPVxuICAgICAgICAgIG51bGw7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gITE7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IGxvY2FsSWRDb3VudGVyID0gMDtcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgICAgIHZhciBob29rID0ge1xuICAgICAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgICAgICBiYXNlU3RhdGU6IG51bGwsXG4gICAgICAgIGJhc2VRdWV1ZTogbnVsbCxcbiAgICAgICAgcXVldWU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgPyAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaylcbiAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBob29rKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50SG9vaykge1xuICAgICAgICB2YXIgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGU7XG4gICAgICAgIG5leHRDdXJyZW50SG9vayA9XG4gICAgICAgICAgbnVsbCAhPT0gbmV4dEN1cnJlbnRIb29rID8gbmV4dEN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUgOiBudWxsO1xuICAgICAgfSBlbHNlIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gICAgICB2YXIgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9XG4gICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICAgID8gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcbiAgICAgIGlmIChudWxsICE9PSBuZXh0V29ya0luUHJvZ3Jlc3NIb29rKVxuICAgICAgICAod29ya0luUHJvZ3Jlc3NIb29rID0gbmV4dFdvcmtJblByb2dyZXNzSG9vayksXG4gICAgICAgICAgKGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAobnVsbCA9PT0gbmV4dEN1cnJlbnRIb29rKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVXBkYXRlIGhvb2sgY2FsbGVkIG9uIGluaXRpYWwgcmVuZGVyLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICAgICAgICBuZXh0Q3VycmVudEhvb2sgPSB7XG4gICAgICAgICAgbWVtb2l6ZWRTdGF0ZTogY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICBiYXNlU3RhdGU6IGN1cnJlbnRIb29rLmJhc2VTdGF0ZSxcbiAgICAgICAgICBiYXNlUXVldWU6IGN1cnJlbnRIb29rLmJhc2VRdWV1ZSxcbiAgICAgICAgICBxdWV1ZTogY3VycmVudEhvb2sucXVldWUsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgICA/IChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgICAgICAgICAgICBuZXh0Q3VycmVudEhvb2spXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBuZXh0Q3VycmVudEhvb2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlVGhlbmFibGUodGhlbmFibGUpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoZW5hYmxlSW5kZXhDb3VudGVyO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgKz0gMTtcbiAgICAgIG51bGwgPT09IHRoZW5hYmxlU3RhdGUgJiYgKHRoZW5hYmxlU3RhdGUgPSBjcmVhdGVUaGVuYWJsZVN0YXRlKCkpO1xuICAgICAgdGhlbmFibGUgPSB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpO1xuICAgICAgaW5kZXggPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICAgICAgbnVsbCA9PT1cbiAgICAgICAgKG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICAgID8gaW5kZXgubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgIDogd29ya0luUHJvZ3Jlc3NIb29rLm5leHQpICYmXG4gICAgICAgICgoaW5kZXggPSBpbmRleC5hbHRlcm5hdGUpLFxuICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9XG4gICAgICAgICAgbnVsbCAhPT0gaW5kZXggJiYgbnVsbCAhPT0gaW5kZXgubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWXG4gICAgICAgICAgICA6IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVikpO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2UodXNhYmxlKSB7XG4gICAgICBpZiAobnVsbCAhPT0gdXNhYmxlICYmIFwib2JqZWN0XCIgPT09IHR5cGVvZiB1c2FibGUpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVzYWJsZS50aGVuKSByZXR1cm4gdXNlVGhlbmFibGUodXNhYmxlKTtcbiAgICAgICAgaWYgKHVzYWJsZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSByZXR1cm4gcmVhZENvbnRleHQodXNhYmxlKTtcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFwiQW4gdW5zdXBwb3J0ZWQgdHlwZSB3YXMgcGFzc2VkIHRvIHVzZSgpOiBcIiArIFN0cmluZyh1c2FibGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlTWVtb0NhY2hlKHNpemUpIHtcbiAgICAgIHZhciBtZW1vQ2FjaGUgPSBudWxsLFxuICAgICAgICB1cGRhdGVRdWV1ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG4gICAgICBudWxsICE9PSB1cGRhdGVRdWV1ZSAmJiAobWVtb0NhY2hlID0gdXBkYXRlUXVldWUubWVtb0NhY2hlKTtcbiAgICAgIGlmIChudWxsID09IG1lbW9DYWNoZSkge1xuICAgICAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlO1xuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC5tZW1vQ2FjaGUpLFxuICAgICAgICAgICAgbnVsbCAhPSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIChtZW1vQ2FjaGUgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogY3VycmVudC5kYXRhLm1hcChmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgICBudWxsID09IG1lbW9DYWNoZSAmJiAobWVtb0NhY2hlID0geyBkYXRhOiBbXSwgaW5kZXg6IDAgfSk7XG4gICAgICBudWxsID09PSB1cGRhdGVRdWV1ZSAmJlxuICAgICAgICAoKHVwZGF0ZVF1ZXVlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpKSxcbiAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZSkpO1xuICAgICAgdXBkYXRlUXVldWUubWVtb0NhY2hlID0gbWVtb0NhY2hlO1xuICAgICAgdXBkYXRlUXVldWUgPSBtZW1vQ2FjaGUuZGF0YVttZW1vQ2FjaGUuaW5kZXhdO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gdXBkYXRlUXVldWUgfHwgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdXBkYXRlUXVldWUgPSBtZW1vQ2FjaGUuZGF0YVttZW1vQ2FjaGUuaW5kZXhdID0gQXJyYXkoc2l6ZSksXG4gICAgICAgICAgICBjdXJyZW50ID0gMDtcbiAgICAgICAgICBjdXJyZW50IDwgc2l6ZTtcbiAgICAgICAgICBjdXJyZW50KytcbiAgICAgICAgKVxuICAgICAgICAgIHVwZGF0ZVF1ZXVlW2N1cnJlbnRdID0gUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTDtcbiAgICAgIGVsc2VcbiAgICAgICAgdXBkYXRlUXVldWUubGVuZ3RoICE9PSBzaXplICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgYSBjb25zdGFudCBzaXplIGFyZ3VtZW50IGZvciBlYWNoIGludm9jYXRpb24gb2YgdXNlTWVtb0NhY2hlLiBUaGUgcHJldmlvdXMgY2FjaGUgd2FzIGFsbG9jYXRlZCB3aXRoIHNpemUgJXMgYnV0IHNpemUgJXMgd2FzIHJlcXVlc3RlZC5cIixcbiAgICAgICAgICAgIHVwZGF0ZVF1ZXVlLmxlbmd0aCxcbiAgICAgICAgICAgIHNpemVcbiAgICAgICAgICApO1xuICAgICAgbWVtb0NhY2hlLmluZGV4Kys7XG4gICAgICByZXR1cm4gdXBkYXRlUXVldWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhc2ljU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhY3Rpb24gPyBhY3Rpb24oc3RhdGUpIDogYWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gaW5pdCkge1xuICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5pdChpbml0aWFsQXJnKTtcbiAgICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbml0KGluaXRpYWxBcmcpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaW5pdGlhbFN0YXRlID0gaW5pdGlhbEFyZztcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgcmVkdWNlciA9IHtcbiAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiByZWR1Y2VyLFxuICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gICAgICB9O1xuICAgICAgaG9vay5xdWV1ZSA9IHJlZHVjZXI7XG4gICAgICByZWR1Y2VyID0gcmVkdWNlci5kaXNwYXRjaCA9IGRpc3BhdGNoUmVkdWNlckFjdGlvbi5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICByZWR1Y2VyXG4gICAgICApO1xuICAgICAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIHJlZHVjZXJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVkdWNlckltcGwoaG9vaywgY3VycmVudEhvb2ssIHJlZHVjZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVSZWR1Y2VySW1wbChob29rLCBjdXJyZW50LCByZWR1Y2VyKSB7XG4gICAgICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuICAgICAgaWYgKG51bGwgPT09IHF1ZXVlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlNob3VsZCBoYXZlIGEgcXVldWUuIFlvdSBhcmUgbGlrZWx5IGNhbGxpbmcgSG9va3MgY29uZGl0aW9uYWxseSwgd2hpY2ggaXMgbm90IGFsbG93ZWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsKVwiXG4gICAgICAgICk7XG4gICAgICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgIHZhciBiYXNlUXVldWUgPSBob29rLmJhc2VRdWV1ZSxcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gcXVldWUucGVuZGluZztcbiAgICAgIGlmIChudWxsICE9PSBwZW5kaW5nUXVldWUpIHtcbiAgICAgICAgaWYgKG51bGwgIT09IGJhc2VRdWV1ZSkge1xuICAgICAgICAgIHZhciBiYXNlRmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgICAgICBiYXNlUXVldWUubmV4dCA9IHBlbmRpbmdRdWV1ZS5uZXh0O1xuICAgICAgICAgIHBlbmRpbmdRdWV1ZS5uZXh0ID0gYmFzZUZpcnN0O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQuYmFzZVF1ZXVlICE9PSBiYXNlUXVldWUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbCBlcnJvcjogRXhwZWN0ZWQgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSB0byBiZSBhIGNsb25lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudC5iYXNlUXVldWUgPSBiYXNlUXVldWUgPSBwZW5kaW5nUXVldWU7XG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgfVxuICAgICAgcGVuZGluZ1F1ZXVlID0gaG9vay5iYXNlU3RhdGU7XG4gICAgICBpZiAobnVsbCA9PT0gYmFzZVF1ZXVlKSBob29rLm1lbW9pemVkU3RhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3VycmVudCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgICAgICB2YXIgbmV3QmFzZVF1ZXVlRmlyc3QgPSAoYmFzZUZpcnN0ID0gbnVsbCksXG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG51bGwsXG4gICAgICAgICAgdXBkYXRlID0gY3VycmVudCxcbiAgICAgICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lICYgLTUzNjg3MDkxMztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB1cGRhdGVMYW5lICE9PSB1cGRhdGUubGFuZVxuICAgICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIHVwZGF0ZUxhbmUpID09PSB1cGRhdGVMYW5lXG4gICAgICAgICAgICAgIDogKHJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciByZXZlcnRMYW5lID0gdXBkYXRlLnJldmVydExhbmU7XG4gICAgICAgICAgICBpZiAoMCA9PT0gcmV2ZXJ0TGFuZSlcbiAgICAgICAgICAgICAgbnVsbCAhPT0gbmV3QmFzZVF1ZXVlTGFzdCAmJlxuICAgICAgICAgICAgICAgIChuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID1cbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZTogMCxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0TGFuZTogMCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHVwZGF0ZUxhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgICAgICAgICAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKChyZW5kZXJMYW5lcyAmIHJldmVydExhbmUpID09PSByZXZlcnRMYW5lKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICAgICAgICByZXZlcnRMYW5lID09PSBjdXJyZW50RW50YW5nbGVkTGFuZSAmJlxuICAgICAgICAgICAgICAgIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITApO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAodXBkYXRlTGFuZSA9IHtcbiAgICAgICAgICAgICAgICBsYW5lOiAwLFxuICAgICAgICAgICAgICAgIHJldmVydExhbmU6IHVwZGF0ZS5yZXZlcnRMYW5lLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IG5ld0Jhc2VRdWV1ZUxhc3RcbiAgICAgICAgICAgICAgICAgID8gKChuZXdCYXNlUXVldWVGaXJzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QgPSB1cGRhdGVMYW5lKSxcbiAgICAgICAgICAgICAgICAgICAgKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSkpXG4gICAgICAgICAgICAgICAgICA6IChuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gdXBkYXRlTGFuZSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgfD0gcmV2ZXJ0TGFuZSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSByZXZlcnRMYW5lKTtcbiAgICAgICAgICAgIHVwZGF0ZUxhbmUgPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgICAgICAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgJiZcbiAgICAgICAgICAgICAgcmVkdWNlcihwZW5kaW5nUXVldWUsIHVwZGF0ZUxhbmUpO1xuICAgICAgICAgICAgcGVuZGluZ1F1ZXVlID0gdXBkYXRlLmhhc0VhZ2VyU3RhdGVcbiAgICAgICAgICAgICAgPyB1cGRhdGUuZWFnZXJTdGF0ZVxuICAgICAgICAgICAgICA6IHJlZHVjZXIocGVuZGluZ1F1ZXVlLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIChyZXZlcnRMYW5lID0ge1xuICAgICAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgICAgICByZXZlcnRMYW5lOiB1cGRhdGUucmV2ZXJ0TGFuZSxcbiAgICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBudWxsID09PSBuZXdCYXNlUXVldWVMYXN0XG4gICAgICAgICAgICAgICAgPyAoKG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbmV3QmFzZVF1ZXVlTGFzdCA9IHJldmVydExhbmUpLFxuICAgICAgICAgICAgICAgICAgKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSkpXG4gICAgICAgICAgICAgICAgOiAobmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IHJldmVydExhbmUpLFxuICAgICAgICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyB8PSB1cGRhdGVMYW5lKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSB1cGRhdGVMYW5lKTtcbiAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgfSB3aGlsZSAobnVsbCAhPT0gdXBkYXRlICYmIHVwZGF0ZSAhPT0gY3VycmVudCk7XG4gICAgICAgIG51bGwgPT09IG5ld0Jhc2VRdWV1ZUxhc3RcbiAgICAgICAgICA/IChiYXNlRmlyc3QgPSBwZW5kaW5nUXVldWUpXG4gICAgICAgICAgOiAobmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gbmV3QmFzZVF1ZXVlRmlyc3QpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIW9iamVjdElzKHBlbmRpbmdRdWV1ZSwgaG9vay5tZW1vaXplZFN0YXRlKSAmJlxuICAgICAgICAgICgoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKSxcbiAgICAgICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uICYmXG4gICAgICAgICAgICAoKHJlZHVjZXIgPSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUpLCBudWxsICE9PSByZWR1Y2VyKSlcbiAgICAgICAgKVxuICAgICAgICAgIHRocm93IHJlZHVjZXI7XG4gICAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgICAgaG9vay5iYXNlU3RhdGUgPSBiYXNlRmlyc3Q7XG4gICAgICAgIGhvb2suYmFzZVF1ZXVlID0gbmV3QmFzZVF1ZXVlTGFzdDtcbiAgICAgICAgcXVldWUubGFzdFJlbmRlcmVkU3RhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgICB9XG4gICAgICBudWxsID09PSBiYXNlUXVldWUgJiYgKHF1ZXVlLmxhbmVzID0gMCk7XG4gICAgICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgcXVldWUuZGlzcGF0Y2hdO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlclJlZHVjZXIocmVkdWNlcikge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICAgICAgcXVldWUgPSBob29rLnF1ZXVlO1xuICAgICAgaWYgKG51bGwgPT09IHF1ZXVlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlNob3VsZCBoYXZlIGEgcXVldWUuIFlvdSBhcmUgbGlrZWx5IGNhbGxpbmcgSG9va3MgY29uZGl0aW9uYWxseSwgd2hpY2ggaXMgbm90IGFsbG93ZWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsKVwiXG4gICAgICAgICk7XG4gICAgICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoLFxuICAgICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBxdWV1ZS5wZW5kaW5nLFxuICAgICAgICBuZXdTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAgICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgICAgIHZhciB1cGRhdGUgPSAobGFzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQpO1xuICAgICAgICBkb1xuICAgICAgICAgIChuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIHVwZGF0ZS5hY3Rpb24pKSwgKHVwZGF0ZSA9IHVwZGF0ZS5uZXh0KTtcbiAgICAgICAgd2hpbGUgKHVwZGF0ZSAhPT0gbGFzdFJlbmRlclBoYXNlVXBkYXRlKTtcbiAgICAgICAgb2JqZWN0SXMobmV3U3RhdGUsIGhvb2subWVtb2l6ZWRTdGF0ZSkgfHwgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCk7XG4gICAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBudWxsID09PSBob29rLmJhc2VRdWV1ZSAmJiAoaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZSk7XG4gICAgICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gW25ld1N0YXRlLCBkaXNwYXRjaF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IGdldFNlcnZlclNuYXBzaG90KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3Igc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICApO1xuICAgICAgICB2YXIgbmV4dFNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QoKTtcbiAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgfHxcbiAgICAgICAgICBuZXh0U25hcHNob3QgPT09IGdldFNlcnZlclNuYXBzaG90KCkgfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHJlc3VsdCBvZiBnZXRTZXJ2ZXJTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3BcIlxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gITApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG4gICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90IHx8XG4gICAgICAgICAgKChnZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNuYXBzaG90KCkpLFxuICAgICAgICAgIG9iamVjdElzKG5leHRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gITApKSk7XG4gICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIDAgIT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDYwKSB8fFxuICAgICAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBuZXh0U25hcHNob3QpO1xuICAgICAgfVxuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV4dFNuYXBzaG90O1xuICAgICAgZ2V0U2VydmVyU25hcHNob3QgPSB7IHZhbHVlOiBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCB9O1xuICAgICAgaG9vay5xdWV1ZSA9IGdldFNlcnZlclNuYXBzaG90O1xuICAgICAgbW91bnRFZmZlY3QoXG4gICAgICAgIHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgZ2V0U2VydmVyU25hcHNob3QsIHN1YnNjcmliZSksXG4gICAgICAgIFtzdWJzY3JpYmVdXG4gICAgICApO1xuICAgICAgZmliZXIuZmxhZ3MgfD0gMjA0ODtcbiAgICAgIHB1c2hFZmZlY3QoXG4gICAgICAgIEhhc0VmZmVjdCB8IFBhc3NpdmUsXG4gICAgICAgIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgICAgIG5leHRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTbmFwc2hvdFxuICAgICAgICApLFxuICAgICAgICB7IGRlc3Ryb3k6IHZvaWQgMCB9LFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5leHRTbmFwc2hvdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBnZXRTbmFwc2hvdCxcbiAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgKSB7XG4gICAgICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICAgIGlzSHlkcmF0aW5nJGpzY29tcCQwID0gaXNIeWRyYXRpbmc7XG4gICAgICBpZiAoaXNIeWRyYXRpbmckanNjb21wJDApIHtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gZ2V0U2VydmVyU25hcHNob3QpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIk1pc3NpbmcgZ2V0U2VydmVyU25hcHNob3QsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciBzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QoKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICgoZ2V0U2VydmVyU25hcHNob3QgPSBnZXRTbmFwc2hvdCgpKSwgIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjYWNoZWRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG4gICAgICAgIG9iamVjdElzKGdldFNlcnZlclNuYXBzaG90LCBjYWNoZWRTbmFwc2hvdCkgfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3BcIlxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gITApKTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgKGNhY2hlZFNuYXBzaG90ID0gIW9iamVjdElzKFxuICAgICAgICAgIChjdXJyZW50SG9vayB8fCBob29rKS5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICkpXG4gICAgICApXG4gICAgICAgIChob29rLm1lbW9pemVkU3RhdGUgPSBnZXRTZXJ2ZXJTbmFwc2hvdCksIChkaWRSZWNlaXZlVXBkYXRlID0gITApO1xuICAgICAgaG9vayA9IGhvb2sucXVldWU7XG4gICAgICB2YXIgY3JlYXRlID0gc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsIGZpYmVyLCBob29rLCBzdWJzY3JpYmUpO1xuICAgICAgdXBkYXRlRWZmZWN0SW1wbCgyMDQ4LCBQYXNzaXZlLCBjcmVhdGUsIFtzdWJzY3JpYmVdKTtcbiAgICAgIGlmIChcbiAgICAgICAgaG9vay5nZXRTbmFwc2hvdCAhPT0gZ2V0U25hcHNob3QgfHxcbiAgICAgICAgY2FjaGVkU25hcHNob3QgfHxcbiAgICAgICAgKG51bGwgIT09IHdvcmtJblByb2dyZXNzSG9vayAmJlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLnRhZyAmIEhhc0VmZmVjdClcbiAgICAgICkge1xuICAgICAgICBmaWJlci5mbGFncyB8PSAyMDQ4O1xuICAgICAgICBwdXNoRWZmZWN0KFxuICAgICAgICAgIEhhc0VmZmVjdCB8IFBhc3NpdmUsXG4gICAgICAgICAgdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgaG9vayxcbiAgICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgICAgICAgZ2V0U25hcHNob3RcbiAgICAgICAgICApLFxuICAgICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICBpc0h5ZHJhdGluZyRqc2NvbXAkMCB8fFxuICAgICAgICAgIDAgIT09IChyZW5kZXJMYW5lcyAmIDYwKSB8fFxuICAgICAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0U2VydmVyU25hcHNob3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCByZW5kZXJlZFNuYXBzaG90KSB7XG4gICAgICBmaWJlci5mbGFncyB8PSAxNjM4NDtcbiAgICAgIGZpYmVyID0geyBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QsIHZhbHVlOiByZW5kZXJlZFNuYXBzaG90IH07XG4gICAgICBnZXRTbmFwc2hvdCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG4gICAgICBudWxsID09PSBnZXRTbmFwc2hvdFxuICAgICAgICA/ICgoZ2V0U25hcHNob3QgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkpLFxuICAgICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gZ2V0U25hcHNob3QpLFxuICAgICAgICAgIChnZXRTbmFwc2hvdC5zdG9yZXMgPSBbZmliZXJdKSlcbiAgICAgICAgOiAoKHJlbmRlcmVkU25hcHNob3QgPSBnZXRTbmFwc2hvdC5zdG9yZXMpLFxuICAgICAgICAgIG51bGwgPT09IHJlbmRlcmVkU25hcHNob3RcbiAgICAgICAgICAgID8gKGdldFNuYXBzaG90LnN0b3JlcyA9IFtmaWJlcl0pXG4gICAgICAgICAgICA6IHJlbmRlcmVkU25hcHNob3QucHVzaChmaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTdG9yZUluc3RhbmNlKGZpYmVyLCBpbnN0LCBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90KSB7XG4gICAgICBpbnN0LnZhbHVlID0gbmV4dFNuYXBzaG90O1xuICAgICAgaW5zdC5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90O1xuICAgICAgY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSAmJiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdWJzY3JpYmVUb1N0b3JlKGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpIHtcbiAgICAgIHJldHVybiBzdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpICYmIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSB7XG4gICAgICB2YXIgbGF0ZXN0R2V0U25hcHNob3QgPSBpbnN0LmdldFNuYXBzaG90O1xuICAgICAgaW5zdCA9IGluc3QudmFsdWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICAgICAgcmV0dXJuICFvYmplY3RJcyhpbnN0LCBuZXh0VmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpIHtcbiAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHJvb3QgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCAyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTdGF0ZUltcGwoaW5pdGlhbFN0YXRlKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIHZhciBpbml0aWFsU3RhdGVJbml0aWFsaXplciA9IGluaXRpYWxTdGF0ZTtcbiAgICAgICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIoKTtcbiAgICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbml0aWFsU3RhdGVJbml0aWFsaXplcigpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgIGhvb2sucXVldWUgPSB7XG4gICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgIGxhbmVzOiAwLFxuICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgICAgIH07XG4gICAgICByZXR1cm4gaG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgICAgIGluaXRpYWxTdGF0ZSA9IG1vdW50U3RhdGVJbXBsKGluaXRpYWxTdGF0ZSk7XG4gICAgICB2YXIgcXVldWUgPSBpbml0aWFsU3RhdGUucXVldWUsXG4gICAgICAgIGRpc3BhdGNoID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgICBxdWV1ZVxuICAgICAgICApO1xuICAgICAgcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICAgIHJldHVybiBbaW5pdGlhbFN0YXRlLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IHBhc3N0aHJvdWdoO1xuICAgICAgdmFyIHF1ZXVlID0ge1xuICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICBsYW5lczogMCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBudWxsXG4gICAgICB9O1xuICAgICAgaG9vay5xdWV1ZSA9IHF1ZXVlO1xuICAgICAgaG9vayA9IGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgICEwLFxuICAgICAgICBxdWV1ZVxuICAgICAgKTtcbiAgICAgIHF1ZXVlLmRpc3BhdGNoID0gaG9vaztcbiAgICAgIHJldHVybiBbcGFzc3Rocm91Z2gsIGhvb2tdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCBwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnQsIHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IHBhc3N0aHJvdWdoO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXJJbXBsKFxuICAgICAgICBob29rLFxuICAgICAgICBjdXJyZW50SG9vayxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVkdWNlciA/IHJlZHVjZXIgOiBiYXNpY1N0YXRlUmVkdWNlclxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRIb29rKVxuICAgICAgICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudEhvb2ssIHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gICAgICByZXR1cm4gW3Bhc3N0aHJvdWdoLCBob29rLnF1ZXVlLmRpc3BhdGNoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb25TdGF0ZShcbiAgICAgIGZpYmVyLFxuICAgICAgYWN0aW9uUXVldWUsXG4gICAgICBzZXRQZW5kaW5nU3RhdGUsXG4gICAgICBzZXRTdGF0ZSxcbiAgICAgIHBheWxvYWRcbiAgICApIHtcbiAgICAgIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIGZvcm0gc3RhdGUgd2hpbGUgcmVuZGVyaW5nLlwiKTtcbiAgICAgIGZpYmVyID0gYWN0aW9uUXVldWUuYWN0aW9uO1xuICAgICAgaWYgKG51bGwgIT09IGZpYmVyKSB7XG4gICAgICAgIHZhciBhY3Rpb25Ob2RlID0ge1xuICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgYWN0aW9uOiBmaWJlcixcbiAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgIGlzVHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICByZWFzb246IG51bGwsXG4gICAgICAgICAgbGlzdGVuZXJzOiBbXSxcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGFjdGlvbk5vZGUubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVFxuICAgICAgICAgID8gc2V0UGVuZGluZ1N0YXRlKCEwKVxuICAgICAgICAgIDogKGFjdGlvbk5vZGUuaXNUcmFuc2l0aW9uID0gITEpO1xuICAgICAgICBzZXRTdGF0ZShhY3Rpb25Ob2RlKTtcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlID0gYWN0aW9uUXVldWUucGVuZGluZztcbiAgICAgICAgbnVsbCA9PT0gc2V0UGVuZGluZ1N0YXRlXG4gICAgICAgICAgPyAoKGFjdGlvbk5vZGUubmV4dCA9IGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBhY3Rpb25Ob2RlKSxcbiAgICAgICAgICAgIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBhY3Rpb25Ob2RlKSlcbiAgICAgICAgICA6ICgoYWN0aW9uTm9kZS5uZXh0ID0gc2V0UGVuZGluZ1N0YXRlLm5leHQpLFxuICAgICAgICAgICAgKGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBzZXRQZW5kaW5nU3RhdGUubmV4dCA9IGFjdGlvbk5vZGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIG5vZGUpIHtcbiAgICAgIHZhciBhY3Rpb24gPSBub2RlLmFjdGlvbixcbiAgICAgICAgcGF5bG9hZCA9IG5vZGUucGF5bG9hZCxcbiAgICAgICAgcHJldlN0YXRlID0gYWN0aW9uUXVldWUuc3RhdGU7XG4gICAgICBpZiAobm9kZS5pc1RyYW5zaXRpb24pIHtcbiAgICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gY3VycmVudFRyYW5zaXRpb247XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQuX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gYWN0aW9uKHByZXZTdGF0ZSwgcGF5bG9hZCksXG4gICAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgICAgICAgbnVsbCAhPT0gb25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKGN1cnJlbnRUcmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBub2RlLCBlcnJvcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgICBudWxsID09PSBwcmV2VHJhbnNpdGlvbiAmJlxuICAgICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyAmJlxuICAgICAgICAgICAgICAoKGFjdGlvblF1ZXVlID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZSksXG4gICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCksXG4gICAgICAgICAgICAgIDEwIDwgYWN0aW9uUXVldWUgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBcIkRldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gSWYgdGhpcyBpcyBkdWUgdG8gYSBzdWJzY3JpcHRpb24gcGxlYXNlIHJlLXdyaXRlIGl0IHRvIHVzZSBSZWFjdCBwcm92aWRlZCBob29rcy4gT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLlwiXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIChjdXJyZW50VHJhbnNpdGlvbiA9IGFjdGlvbihwcmV2U3RhdGUsIHBheWxvYWQpKSxcbiAgICAgICAgICAgIGhhbmRsZUFjdGlvblJldHVyblZhbHVlKGFjdGlvblF1ZXVlLCBub2RlLCBjdXJyZW50VHJhbnNpdGlvbik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yJDIpIHtcbiAgICAgICAgICBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBub2RlLCBlcnJvciQyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVBY3Rpb25SZXR1cm5WYWx1ZShhY3Rpb25RdWV1ZSwgbm9kZSwgcmV0dXJuVmFsdWUpIHtcbiAgICAgIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW5cbiAgICAgICAgPyAocmV0dXJuVmFsdWUudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgICAgb25BY3Rpb25TdWNjZXNzKGFjdGlvblF1ZXVlLCBub2RlLCBuZXh0U3RhdGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICByZXR1cm4gb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICksXG4gICAgICAgICAgbm9kZS5pc1RyYW5zaXRpb24gfHxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQW4gYXN5bmMgZnVuY3Rpb24gd2FzIHBhc3NlZCB0byB1c2VBY3Rpb25TdGF0ZSwgYnV0IGl0IHdhcyBkaXNwYXRjaGVkIG91dHNpZGUgb2YgYW4gYWN0aW9uIGNvbnRleHQuIFRoaXMgaXMgbGlrZWx5IG5vdCB3aGF0IHlvdSBpbnRlbmRlZC4gRWl0aGVyIHBhc3MgdGhlIGRpc3BhdGNoIGZ1bmN0aW9uIHRvIGFuIGBhY3Rpb25gIHByb3AsIG9yIGRpc3BhdGNoIG1hbnVhbGx5IGluc2lkZSBgc3RhcnRUcmFuc2l0aW9uYFwiXG4gICAgICAgICAgICApKVxuICAgICAgICA6IG9uQWN0aW9uU3VjY2VzcyhhY3Rpb25RdWV1ZSwgbm9kZSwgcmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkFjdGlvblN1Y2Nlc3MoYWN0aW9uUXVldWUsIGFjdGlvbk5vZGUsIG5leHRTdGF0ZSkge1xuICAgICAgYWN0aW9uTm9kZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgYWN0aW9uTm9kZS52YWx1ZSA9IG5leHRTdGF0ZTtcbiAgICAgIG5vdGlmeUFjdGlvbkxpc3RlbmVycyhhY3Rpb25Ob2RlKTtcbiAgICAgIGFjdGlvblF1ZXVlLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgYWN0aW9uTm9kZSA9IGFjdGlvblF1ZXVlLnBlbmRpbmc7XG4gICAgICBudWxsICE9PSBhY3Rpb25Ob2RlICYmXG4gICAgICAgICgobmV4dFN0YXRlID0gYWN0aW9uTm9kZS5uZXh0KSxcbiAgICAgICAgbmV4dFN0YXRlID09PSBhY3Rpb25Ob2RlXG4gICAgICAgICAgPyAoYWN0aW9uUXVldWUucGVuZGluZyA9IG51bGwpXG4gICAgICAgICAgOiAoKG5leHRTdGF0ZSA9IG5leHRTdGF0ZS5uZXh0KSxcbiAgICAgICAgICAgIChhY3Rpb25Ob2RlLm5leHQgPSBuZXh0U3RhdGUpLFxuICAgICAgICAgICAgcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIG5leHRTdGF0ZSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgYWN0aW9uTm9kZSwgZXJyb3IpIHtcbiAgICAgIHZhciBsYXN0ID0gYWN0aW9uUXVldWUucGVuZGluZztcbiAgICAgIGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgaWYgKG51bGwgIT09IGxhc3QpIHtcbiAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICAgICAgZG9cbiAgICAgICAgICAoYWN0aW9uTm9kZS5zdGF0dXMgPSBcInJlamVjdGVkXCIpLFxuICAgICAgICAgICAgKGFjdGlvbk5vZGUucmVhc29uID0gZXJyb3IpLFxuICAgICAgICAgICAgbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpLFxuICAgICAgICAgICAgKGFjdGlvbk5vZGUgPSBhY3Rpb25Ob2RlLm5leHQpO1xuICAgICAgICB3aGlsZSAoYWN0aW9uTm9kZSAhPT0gbGFzdCk7XG4gICAgICB9XG4gICAgICBhY3Rpb25RdWV1ZS5hY3Rpb24gPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3RpZnlBY3Rpb25MaXN0ZW5lcnMoYWN0aW9uTm9kZSkge1xuICAgICAgYWN0aW9uTm9kZSA9IGFjdGlvbk5vZGUubGlzdGVuZXJzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3Rpb25Ob2RlLmxlbmd0aDsgaSsrKSAoMCwgYWN0aW9uTm9kZVtpXSkoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWN0aW9uU3RhdGVSZWR1Y2VyKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlUHJvcCkge1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHZhciBzc3JGb3JtU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc1Jvb3QuZm9ybVN0YXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gc3NyRm9ybVN0YXRlKSB7XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgdmFyIGlzTWF0Y2hpbmcgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICAgICAgICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgICAgIGlmIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtlckluc3RhbmNlID0gY2FuSHlkcmF0ZUZvcm1TdGF0ZU1hcmtlcihcbiAgICAgICAgICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAobWFya2VySW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgICAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobWFya2VySW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgaXNNYXRjaGluZyA9IGlzRm9ybVN0YXRlTWFya2VyTWF0Y2hpbmcobWFya2VySW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGlzTWF0Y2hpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNNYXRjaGluZyA9ICExO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc01hdGNoaW5nICYmIChpbml0aWFsU3RhdGVQcm9wID0gc3NyRm9ybVN0YXRlWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3NyRm9ybVN0YXRlID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHNzckZvcm1TdGF0ZS5tZW1vaXplZFN0YXRlID0gc3NyRm9ybVN0YXRlLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZVByb3A7XG4gICAgICBpc01hdGNoaW5nID0ge1xuICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICBsYW5lczogMCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGFjdGlvblN0YXRlUmVkdWNlcixcbiAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVByb3BcbiAgICAgIH07XG4gICAgICBzc3JGb3JtU3RhdGUucXVldWUgPSBpc01hdGNoaW5nO1xuICAgICAgc3NyRm9ybVN0YXRlID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBpc01hdGNoaW5nXG4gICAgICApO1xuICAgICAgaXNNYXRjaGluZy5kaXNwYXRjaCA9IHNzckZvcm1TdGF0ZTtcbiAgICAgIGlzTWF0Y2hpbmcgPSBtb3VudFN0YXRlSW1wbCghMSk7XG4gICAgICB2YXIgc2V0UGVuZGluZ1N0YXRlID0gZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgITEsXG4gICAgICAgIGlzTWF0Y2hpbmcucXVldWVcbiAgICAgICk7XG4gICAgICBpc01hdGNoaW5nID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIG1hcmtlckluc3RhbmNlID0ge1xuICAgICAgICBzdGF0ZTogaW5pdGlhbFN0YXRlUHJvcCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBwZW5kaW5nOiBudWxsXG4gICAgICB9O1xuICAgICAgaXNNYXRjaGluZy5xdWV1ZSA9IG1hcmtlckluc3RhbmNlO1xuICAgICAgc3NyRm9ybVN0YXRlID0gZGlzcGF0Y2hBY3Rpb25TdGF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBtYXJrZXJJbnN0YW5jZSxcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlLFxuICAgICAgICBzc3JGb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICBtYXJrZXJJbnN0YW5jZS5kaXNwYXRjaCA9IHNzckZvcm1TdGF0ZTtcbiAgICAgIGlzTWF0Y2hpbmcubWVtb2l6ZWRTdGF0ZSA9IGFjdGlvbjtcbiAgICAgIHJldHVybiBbaW5pdGlhbFN0YXRlUHJvcCwgc3NyRm9ybVN0YXRlLCAhMV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbikge1xuICAgICAgdmFyIHN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRIb29rLCBhY3Rpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb24pIHtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPSB1cGRhdGVSZWR1Y2VySW1wbChcbiAgICAgICAgc3RhdGVIb29rLFxuICAgICAgICBjdXJyZW50U3RhdGVIb29rLFxuICAgICAgICBhY3Rpb25TdGF0ZVJlZHVjZXJcbiAgICAgIClbMF07XG4gICAgICBzdGF0ZUhvb2sgPSB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKVswXTtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPVxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY3VycmVudFN0YXRlSG9vayAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50U3RhdGVIb29rICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGN1cnJlbnRTdGF0ZUhvb2sudGhlblxuICAgICAgICAgID8gdXNlVGhlbmFibGUoY3VycmVudFN0YXRlSG9vaylcbiAgICAgICAgICA6IGN1cnJlbnRTdGF0ZUhvb2s7XG4gICAgICB2YXIgYWN0aW9uUXVldWVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICAgIGFjdGlvblF1ZXVlID0gYWN0aW9uUXVldWVIb29rLnF1ZXVlLFxuICAgICAgICBkaXNwYXRjaCA9IGFjdGlvblF1ZXVlLmRpc3BhdGNoO1xuICAgICAgYWN0aW9uICE9PSBhY3Rpb25RdWV1ZUhvb2subWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgIHB1c2hFZmZlY3QoXG4gICAgICAgICAgSGFzRWZmZWN0IHwgUGFzc2l2ZSxcbiAgICAgICAgICBhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdC5iaW5kKG51bGwsIGFjdGlvblF1ZXVlLCBhY3Rpb24pLFxuICAgICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgICAgbnVsbFxuICAgICAgICApKTtcbiAgICAgIHJldHVybiBbY3VycmVudFN0YXRlSG9vaywgZGlzcGF0Y2gsIHN0YXRlSG9va107XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjdGlvblN0YXRlQWN0aW9uRWZmZWN0KGFjdGlvblF1ZXVlLCBhY3Rpb24pIHtcbiAgICAgIGFjdGlvblF1ZXVlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pIHtcbiAgICAgIHZhciBzdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICAgICAgY3VycmVudFN0YXRlSG9vayA9IGN1cnJlbnRIb29rO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRTdGF0ZUhvb2spXG4gICAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb24pO1xuICAgICAgdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBzdGF0ZUhvb2sgPSBzdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHZhciBkaXNwYXRjaCA9IGN1cnJlbnRTdGF0ZUhvb2sucXVldWUuZGlzcGF0Y2g7XG4gICAgICBjdXJyZW50U3RhdGVIb29rLm1lbW9pemVkU3RhdGUgPSBhY3Rpb247XG4gICAgICByZXR1cm4gW3N0YXRlSG9vaywgZGlzcGF0Y2gsICExXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEVmZmVjdCh0YWcsIGNyZWF0ZSwgaW5zdCwgZGVwcykge1xuICAgICAgdGFnID0geyB0YWc6IHRhZywgY3JlYXRlOiBjcmVhdGUsIGluc3Q6IGluc3QsIGRlcHM6IGRlcHMsIG5leHQ6IG51bGwgfTtcbiAgICAgIGNyZWF0ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG4gICAgICBudWxsID09PSBjcmVhdGUgJiZcbiAgICAgICAgKChjcmVhdGUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkpLFxuICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGNyZWF0ZSkpO1xuICAgICAgaW5zdCA9IGNyZWF0ZS5sYXN0RWZmZWN0O1xuICAgICAgbnVsbCA9PT0gaW5zdFxuICAgICAgICA/IChjcmVhdGUubGFzdEVmZmVjdCA9IHRhZy5uZXh0ID0gdGFnKVxuICAgICAgICA6ICgoZGVwcyA9IGluc3QubmV4dCksXG4gICAgICAgICAgKGluc3QubmV4dCA9IHRhZyksXG4gICAgICAgICAgKHRhZy5uZXh0ID0gZGVwcyksXG4gICAgICAgICAgKGNyZWF0ZS5sYXN0RWZmZWN0ID0gdGFnKSk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFJlZihpbml0aWFsVmFsdWUpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGluaXRpYWxWYWx1ZSA9IHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH07XG4gICAgICByZXR1cm4gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxWYWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChcbiAgICAgICAgSGFzRWZmZWN0IHwgaG9va0ZsYWdzLFxuICAgICAgICBjcmVhdGUsXG4gICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgIHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIGluc3QgPSBob29rLm1lbW9pemVkU3RhdGUuaW5zdDtcbiAgICAgIG51bGwgIT09IGN1cnJlbnRIb29rICYmXG4gICAgICBudWxsICE9PSBkZXBzICYmXG4gICAgICBhcmVIb29rSW5wdXRzRXF1YWwoZGVwcywgY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZS5kZXBzKVxuICAgICAgICA/IChob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KGhvb2tGbGFncywgY3JlYXRlLCBpbnN0LCBkZXBzKSlcbiAgICAgICAgOiAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncyksXG4gICAgICAgICAgKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoXG4gICAgICAgICAgICBIYXNFZmZlY3QgfCBob29rRmxhZ3MsXG4gICAgICAgICAgICBjcmVhdGUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgZGVwc1xuICAgICAgICAgICkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiA2NCkgPT09IE5vTW9kZVxuICAgICAgICA/IG1vdW50RWZmZWN0SW1wbCgxNDI2MDgzODQsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcylcbiAgICAgICAgOiBtb3VudEVmZmVjdEltcGwoODM5MDY1NiwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgZmliZXJGbGFncyA9IDQxOTQzMDg7XG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgICAgKGZpYmVyRmxhZ3MgfD0gNjcxMDg4NjQpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QoY3JlYXRlLCByZWYpIHtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWYpIHtcbiAgICAgICAgY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgICAgIHZhciByZWZDbGVhbnVwID0gcmVmKGNyZWF0ZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmQ2xlYW51cCA/IHJlZkNsZWFudXAoKSA6IHJlZihudWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChudWxsICE9PSByZWYgJiYgdm9pZCAwICE9PSByZWYpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmVmLmhhc093blByb3BlcnR5KFwiY3VycmVudFwiKSB8fFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgZmlyc3QgYXJndW1lbnQgdG8gZWl0aGVyIGJlIGEgcmVmIGNhbGxiYWNrIG9yIFJlYWN0LmNyZWF0ZVJlZigpIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgICAgIFwiYW4gb2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhyZWYpLmpvaW4oXCIsIFwiKSArIFwifVwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIChjcmVhdGUgPSBjcmVhdGUoKSksXG4gICAgICAgICAgKHJlZi5jdXJyZW50ID0gY3JlYXRlKSxcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNyZWF0ZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgbnVsbCAhPT0gY3JlYXRlID8gdHlwZW9mIGNyZWF0ZSA6IFwibnVsbFwiXG4gICAgICAgICk7XG4gICAgICBkZXBzID0gbnVsbCAhPT0gZGVwcyAmJiB2b2lkIDAgIT09IGRlcHMgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICAgICAgdmFyIGZpYmVyRmxhZ3MgPSA0MTk0MzA4O1xuICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIDE2KSAhPT0gTm9Nb2RlICYmXG4gICAgICAgIChmaWJlckZsYWdzIHw9IDY3MTA4ODY0KTtcbiAgICAgIG1vdW50RWZmZWN0SW1wbChcbiAgICAgICAgZmliZXJGbGFncyxcbiAgICAgICAgTGF5b3V0LFxuICAgICAgICBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLFxuICAgICAgICBkZXBzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjcmVhdGUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBoYW5kbGUuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLlwiLFxuICAgICAgICAgIG51bGwgIT09IGNyZWF0ZSA/IHR5cGVvZiBjcmVhdGUgOiBcIm51bGxcIlxuICAgICAgICApO1xuICAgICAgZGVwcyA9IG51bGwgIT09IGRlcHMgJiYgdm9pZCAwICE9PSBkZXBzID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgICAgIHVwZGF0ZUVmZmVjdEltcGwoXG4gICAgICAgIDQsXG4gICAgICAgIExheW91dCxcbiAgICAgICAgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSxcbiAgICAgICAgZGVwc1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICAgICAgbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlID0gW1xuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHNcbiAgICAgIF07XG4gICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBkZXBzICYmIGFyZUhvb2tJbnB1dHNFcXVhbChkZXBzLCBwcmV2U3RhdGVbMV0pKVxuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBkZXBzXTtcbiAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICAgIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gICAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5leHRDcmVhdGUoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIGRlcHNdO1xuICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBkZXBzICYmIGFyZUhvb2tJbnB1dHNFcXVhbChkZXBzLCBwcmV2U3RhdGVbMV0pKVxuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgcHJldlN0YXRlID0gbmV4dENyZWF0ZSgpO1xuICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXh0Q3JlYXRlKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBbcHJldlN0YXRlLCBkZXBzXTtcbiAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKFxuICAgICAgICBob29rLFxuICAgICAgICBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW5pdGlhbFZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHJldHVybiBudWxsID09PSBjdXJyZW50SG9va1xuICAgICAgICA/IG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSlcbiAgICAgICAgOiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChcbiAgICAgICAgICAgIGhvb2ssXG4gICAgICAgICAgICBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBpbml0aWFsVmFsdWVcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IGluaXRpYWxWYWx1ZSB8fCAwICE9PSAocmVuZGVyTGFuZXMgJiAxMDczNzQxODI0KSlcbiAgICAgICAgcmV0dXJuIChob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZSk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsVmFsdWU7XG4gICAgICBob29rID0gcmVxdWVzdERlZmVycmVkTGFuZSgpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyB8PSBob29rO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IGhvb2s7XG4gICAgICByZXR1cm4gaW5pdGlhbFZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChob29rLCBwcmV2VmFsdWUsIHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGlmIChvYmplY3RJcyh2YWx1ZSwgcHJldlZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoaG9vayA9IG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSkpLFxuICAgICAgICAgIG9iamVjdElzKGhvb2ssIHByZXZWYWx1ZSkgfHwgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCksXG4gICAgICAgICAgaG9va1xuICAgICAgICApO1xuICAgICAgaWYgKDAgPT09IChyZW5kZXJMYW5lcyAmIDQyKSlcbiAgICAgICAgcmV0dXJuIChkaWRSZWNlaXZlVXBkYXRlID0gITApLCAoaG9vay5tZW1vaXplZFN0YXRlID0gdmFsdWUpO1xuICAgICAgaG9vayA9IHJlcXVlc3REZWZlcnJlZExhbmUoKTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgfD0gaG9vaztcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSBob29rO1xuICAgICAgcmV0dXJuIHByZXZWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKFxuICAgICAgZmliZXIsXG4gICAgICBxdWV1ZSxcbiAgICAgIHBlbmRpbmdTdGF0ZSxcbiAgICAgIGZpbmlzaGVkU3RhdGUsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShcbiAgICAgICAgMCAhPT0gcHJldmlvdXNQcmlvcml0eSAmJiA4ID4gcHJldmlvdXNQcmlvcml0eSA/IHByZXZpb3VzUHJpb3JpdHkgOiA4XG4gICAgICApO1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgY3VycmVudFRyYW5zaXRpb24gPSB7fTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBjdXJyZW50VHJhbnNpdGlvbjtcbiAgICAgIGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlKGZpYmVyLCAhMSwgcXVldWUsIHBlbmRpbmdTdGF0ZSk7XG4gICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGNhbGxiYWNrKCksXG4gICAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuICAgICAgICBudWxsICE9PSBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAmJlxuICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKGN1cnJlbnRUcmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBudWxsICE9PSByZXR1cm5WYWx1ZSAmJlxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHRoZW5hYmxlRm9yRmluaXNoZWRTdGF0ZSA9IGNoYWluVGhlbmFibGVWYWx1ZShcbiAgICAgICAgICAgIHJldHVyblZhbHVlLFxuICAgICAgICAgICAgZmluaXNoZWRTdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICAgIHRoZW5hYmxlRm9yRmluaXNoZWRTdGF0ZSxcbiAgICAgICAgICAgIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgcXVldWUsXG4gICAgICAgICAgICBmaW5pc2hlZFN0YXRlLFxuICAgICAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpXG4gICAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChcbiAgICAgICAgICBmaWJlcixcbiAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICB7IHRoZW46IGZ1bmN0aW9uICgpIHt9LCBzdGF0dXM6IFwicmVqZWN0ZWRcIiwgcmVhc29uOiBlcnJvciB9LFxuICAgICAgICAgIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKVxuICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICAgIG51bGwgPT09IHByZXZUcmFuc2l0aW9uICYmXG4gICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyAmJlxuICAgICAgICAgICAgKChmaWJlciA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemUpLFxuICAgICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKSxcbiAgICAgICAgICAgIDEwIDwgZmliZXIgJiZcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiBJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiBPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcikge1xuICAgICAgdmFyIGV4aXN0aW5nU3RhdGVIb29rID0gZm9ybUZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gZXhpc3RpbmdTdGF0ZUhvb2spIHJldHVybiBleGlzdGluZ1N0YXRlSG9vaztcbiAgICAgIGV4aXN0aW5nU3RhdGVIb29rID0ge1xuICAgICAgICBtZW1vaXplZFN0YXRlOiBOb3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICAgICAgYmFzZVN0YXRlOiBOb3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICAgICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgICAgICBxdWV1ZToge1xuICAgICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IE5vdFBlbmRpbmdUcmFuc2l0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICB2YXIgaW5pdGlhbFJlc2V0U3RhdGUgPSB7fTtcbiAgICAgIGV4aXN0aW5nU3RhdGVIb29rLm5leHQgPSB7XG4gICAgICAgIG1lbW9pemVkU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlLFxuICAgICAgICBiYXNlU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlLFxuICAgICAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgICAgIHF1ZXVlOiB7XG4gICAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgICBsYW5lczogMCxcbiAgICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGVcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGZvcm1GaWJlci5tZW1vaXplZFN0YXRlID0gZXhpc3RpbmdTdGF0ZUhvb2s7XG4gICAgICBmb3JtRmliZXIgPSBmb3JtRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gZm9ybUZpYmVyICYmIChmb3JtRmliZXIubWVtb2l6ZWRTdGF0ZSA9IGV4aXN0aW5nU3RhdGVIb29rKTtcbiAgICAgIHJldHVybiBleGlzdGluZ1N0YXRlSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRUcmFuc2l0aW9uKCkge1xuICAgICAgdmFyIHN0YXRlSG9vayA9IG1vdW50U3RhdGVJbXBsKCExKTtcbiAgICAgIHN0YXRlSG9vayA9IHN0YXJ0VHJhbnNpdGlvbi5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBzdGF0ZUhvb2sucXVldWUsXG4gICAgICAgICEwLFxuICAgICAgICAhMVxuICAgICAgKTtcbiAgICAgIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZSA9IHN0YXRlSG9vaztcbiAgICAgIHJldHVybiBbITEsIHN0YXRlSG9va107XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVRyYW5zaXRpb24oKSB7XG4gICAgICB2YXIgYm9vbGVhbk9yVGhlbmFibGUgPSB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKVswXSxcbiAgICAgICAgc3RhcnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiBib29sZWFuT3JUaGVuYWJsZVxuICAgICAgICAgID8gYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgICA6IHVzZVRoZW5hYmxlKGJvb2xlYW5PclRoZW5hYmxlKSxcbiAgICAgICAgc3RhcnRcbiAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcmVuZGVyVHJhbnNpdGlvbigpIHtcbiAgICAgIHZhciBib29sZWFuT3JUaGVuYWJsZSA9IHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcilbMF0sXG4gICAgICAgIHN0YXJ0ID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgICA/IGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgICAgOiB1c2VUaGVuYWJsZShib29sZWFuT3JUaGVuYWJsZSksXG4gICAgICAgIHN0YXJ0XG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cygpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChIb3N0VHJhbnNpdGlvbkNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudElkKCkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgICBpZGVudGlmaWVyUHJlZml4ID0gd29ya0luUHJvZ3Jlc3NSb290LmlkZW50aWZpZXJQcmVmaXg7XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgdmFyIHRyZWVJZCA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gICAgICAgIHZhciBpZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcbiAgICAgICAgdHJlZUlkID1cbiAgICAgICAgICAoXG4gICAgICAgICAgICBpZFdpdGhMZWFkaW5nQml0ICYgfigxIDw8ICgzMiAtIGNsejMyKGlkV2l0aExlYWRpbmdCaXQpIC0gMSkpXG4gICAgICAgICAgKS50b1N0cmluZygzMikgKyB0cmVlSWQ7XG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXggPSBcIjpcIiArIGlkZW50aWZpZXJQcmVmaXggKyBcIlJcIiArIHRyZWVJZDtcbiAgICAgICAgdHJlZUlkID0gbG9jYWxJZENvdW50ZXIrKztcbiAgICAgICAgMCA8IHRyZWVJZCAmJiAoaWRlbnRpZmllclByZWZpeCArPSBcIkhcIiArIHRyZWVJZC50b1N0cmluZygzMikpO1xuICAgICAgICBpZGVudGlmaWVyUHJlZml4ICs9IFwiOlwiO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0cmVlSWQgPSBnbG9iYWxDbGllbnRJZENvdW50ZXIrKyksXG4gICAgICAgICAgKGlkZW50aWZpZXJQcmVmaXggPVxuICAgICAgICAgICAgXCI6XCIgKyBpZGVudGlmaWVyUHJlZml4ICsgXCJyXCIgKyB0cmVlSWQudG9TdHJpbmcoMzIpICsgXCI6XCIpO1xuICAgICAgcmV0dXJuIChob29rLm1lbW9pemVkU3RhdGUgPSBpZGVudGlmaWVyUHJlZml4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRSZWZyZXNoKCkge1xuICAgICAgcmV0dXJuIChtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGUgPSByZWZyZXNoQ2FjaGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMVxuICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZnJlc2hDYWNoZShmaWJlciwgc2VlZEtleSkge1xuICAgICAgZm9yICh2YXIgcHJvdmlkZXIgPSBmaWJlci5yZXR1cm47IG51bGwgIT09IHByb3ZpZGVyOyApIHtcbiAgICAgICAgc3dpdGNoIChwcm92aWRlci50YWcpIHtcbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUocHJvdmlkZXIpO1xuICAgICAgICAgICAgZmliZXIgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUocHJvdmlkZXIsIGZpYmVyLCBsYW5lKTtcbiAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBwcm92aWRlciwgbGFuZSksXG4gICAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgcHJvdmlkZXIsIGxhbmUpKTtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gY3JlYXRlQ2FjaGUoKTtcbiAgICAgICAgICAgIG51bGwgIT09IHNlZWRLZXkgJiZcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBzZWVkS2V5ICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoZSBzZWVkIGFyZ3VtZW50IGlzIG5vdCBlbmFibGVkIG91dHNpZGUgZXhwZXJpbWVudGFsIGNoYW5uZWxzLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaWJlci5wYXlsb2FkID0geyBjYWNoZTogcHJvdmlkZXIgfTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm92aWRlciA9IHByb3ZpZGVyLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uKFxuICAgICAgZmliZXIsXG4gICAgICBxdWV1ZSxcbiAgICAgIGFjdGlvbixcbiAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMFxuICAgICkge1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciByZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuXCJcbiAgICAgICAgKTtcbiAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMCA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICAgIGFjdGlvbiA9IHtcbiAgICAgICAgbGFuZTogSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwLFxuICAgICAgICByZXZlcnRMYW5lOiAwLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgaGFzRWFnZXJTdGF0ZTogITEsXG4gICAgICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKVxuICAgICAgICA/IGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgYWN0aW9uKVxuICAgICAgICA6ICgoYWN0aW9uID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMFxuICAgICAgICAgICkpLFxuICAgICAgICAgIG51bGwgIT09IGFjdGlvbiAmJlxuICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihcbiAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKFxuICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDBcbiAgICAgICAgICAgICkpKTtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hTZXRTdGF0ZShcbiAgICAgIGZpYmVyLFxuICAgICAgcXVldWUsXG4gICAgICBhY3Rpb24sXG4gICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDFcbiAgICApIHtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLlwiXG4gICAgICAgICk7XG4gICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDEgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgIGZpYmVyLFxuICAgICAgICBxdWV1ZSxcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDFcbiAgICAgICk7XG4gICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChmaWJlciwgcXVldWUsIGFjdGlvbiwgbGFuZSkge1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgbGFuZTogbGFuZSxcbiAgICAgICAgcmV2ZXJ0TGFuZTogMCxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGhhc0VhZ2VyU3RhdGU6ICExLFxuICAgICAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIDAgPT09IGZpYmVyLmxhbmVzICYmXG4gICAgICAgICAgKG51bGwgPT09IGFsdGVybmF0ZSB8fCAwID09PSBhbHRlcm5hdGUubGFuZXMpICYmXG4gICAgICAgICAgKChhbHRlcm5hdGUgPSBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyKSwgbnVsbCAhPT0gYWx0ZXJuYXRlKVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlLFxuICAgICAgICAgICAgICBlYWdlclN0YXRlID0gYWx0ZXJuYXRlKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIHVwZGF0ZS5oYXNFYWdlclN0YXRlID0gITA7XG4gICAgICAgICAgICB1cGRhdGUuZWFnZXJTdGF0ZSA9IGVhZ2VyU3RhdGU7XG4gICAgICAgICAgICBpZiAob2JqZWN0SXMoZWFnZXJTdGF0ZSwgY3VycmVudFN0YXRlKSlcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIDApLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAgICAgICAgICAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhY3Rpb24gPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuICAgICAgICBpZiAobnVsbCAhPT0gYWN0aW9uKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoYWN0aW9uLCBmaWJlciwgbGFuZSksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUoYWN0aW9uLCBxdWV1ZSwgbGFuZSksXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlKFxuICAgICAgZmliZXIsXG4gICAgICB0aHJvd0lmRHVyaW5nUmVuZGVyLFxuICAgICAgcXVldWUsXG4gICAgICBhY3Rpb25cbiAgICApIHtcbiAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgJiZcbiAgICAgICAgMCA9PT0gY3VycmVudEVudGFuZ2xlZExhbmUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFuIG9wdGltaXN0aWMgc3RhdGUgdXBkYXRlIG9jY3VycmVkIG91dHNpZGUgYSB0cmFuc2l0aW9uIG9yIGFjdGlvbi4gVG8gZml4LCBtb3ZlIHRoZSB1cGRhdGUgdG8gYW4gYWN0aW9uLCBvciB3cmFwIHdpdGggc3RhcnRUcmFuc2l0aW9uLlwiXG4gICAgICAgICk7XG4gICAgICBhY3Rpb24gPSB7XG4gICAgICAgIGxhbmU6IDIsXG4gICAgICAgIHJldmVydExhbmU6IHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgaGFzRWFnZXJTdGF0ZTogITEsXG4gICAgICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICAgICAgaWYgKHRocm93SWZEdXJpbmdSZW5kZXIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIG9wdGltaXN0aWMgc3RhdGUgd2hpbGUgcmVuZGVyaW5nLlwiKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbm5vdCBjYWxsIHN0YXJ0VHJhbnNpdGlvbiB3aGlsZSByZW5kZXJpbmcuXCIpO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0aHJvd0lmRHVyaW5nUmVuZGVyID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKFxuICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAyXG4gICAgICAgICkpLFxuICAgICAgICAgIG51bGwgIT09IHRocm93SWZEdXJpbmdSZW5kZXIgJiZcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcih0aHJvd0lmRHVyaW5nUmVuZGVyLCBmaWJlciwgMik7XG4gICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSB7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgZmliZXIgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgfHxcbiAgICAgICAgKG51bGwgIT09IGFsdGVybmF0ZSAmJiBhbHRlcm5hdGUgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSkge1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID1cbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICEwO1xuICAgICAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuICAgICAgbnVsbCA9PT0gcGVuZGluZ1xuICAgICAgICA/ICh1cGRhdGUubmV4dCA9IHVwZGF0ZSlcbiAgICAgICAgOiAoKHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0KSwgKHBlbmRpbmcubmV4dCA9IHVwZGF0ZSkpO1xuICAgICAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKSB7XG4gICAgICBpZiAoMCAhPT0gKGxhbmUgJiA0MTk0MTc2KSkge1xuICAgICAgICB2YXIgcXVldWVMYW5lcyA9IHF1ZXVlLmxhbmVzO1xuICAgICAgICBxdWV1ZUxhbmVzICY9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgICBsYW5lIHw9IHF1ZXVlTGFuZXM7XG4gICAgICAgIHF1ZXVlLmxhbmVzID0gbGFuZTtcbiAgICAgICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbGFuZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgaWYgKG51bGwgIT09IGNhbGxiYWNrICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBrZXkgPSBTdHJpbmcoY2FsbGJhY2spO1xuICAgICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkgfHxcbiAgICAgICAgICAoZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgY3RvcixcbiAgICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxcbiAgICAgIG5leHRQcm9wc1xuICAgICkge1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDgpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZSAmJlxuICAgICAgICAoKGN0b3IgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY3RvcikgfHxcbiAgICAgICAgICAoZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjdG9yKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKTogQSB2YWxpZCBzdGF0ZSBvYmplY3QgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC5cIixcbiAgICAgICAgICAgIGN0b3JcbiAgICAgICAgICApKSk7XG4gICAgICBwcmV2U3RhdGUgPVxuICAgICAgICBudWxsID09PSBwYXJ0aWFsU3RhdGUgfHwgdm9pZCAwID09PSBwYXJ0aWFsU3RhdGVcbiAgICAgICAgICA/IHByZXZTdGF0ZVxuICAgICAgICAgIDogYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcHJldlN0YXRlO1xuICAgICAgMCA9PT0gd29ya0luUHJvZ3Jlc3MubGFuZXMgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IHByZXZTdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdG9yLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIG9sZFN0YXRlLFxuICAgICAgbmV3U3RhdGUsXG4gICAgICBuZXh0Q29udGV4dFxuICAgICkge1xuICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICBvbGRQcm9wcyA9IGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICBuZXh0Q29udGV4dFxuICAgICAgICApO1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDgpIHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9sZFByb3BzID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgIG5leHRDb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZvaWQgMCA9PT0gb2xkUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSBib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBvbGRQcm9wcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudFxuICAgICAgICA/ICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSlcbiAgICAgICAgOiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgbmV3UHJvcHMsXG4gICAgICBuZXh0Q29udGV4dFxuICAgICkge1xuICAgICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgICBpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5oYXMod29ya0luUHJvZ3Jlc3MpIHx8XG4gICAgICAgICAgKGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5hZGQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICkpLFxuICAgICAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgICBudWxsXG4gICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIGJhc2VQcm9wcykge1xuICAgICAgdmFyIG5ld1Byb3BzID0gYmFzZVByb3BzO1xuICAgICAgaWYgKFwicmVmXCIgaW4gYmFzZVByb3BzKSB7XG4gICAgICAgIG5ld1Byb3BzID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGJhc2VQcm9wcylcbiAgICAgICAgICBcInJlZlwiICE9PSBwcm9wTmFtZSAmJiAobmV3UHJvcHNbcHJvcE5hbWVdID0gYmFzZVByb3BzW3Byb3BOYW1lXSk7XG4gICAgICB9XG4gICAgICBpZiAoKENvbXBvbmVudCA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHMpKSB7XG4gICAgICAgIG5ld1Byb3BzID09PSBiYXNlUHJvcHMgJiYgKG5ld1Byb3BzID0gYXNzaWduKHt9LCBuZXdQcm9wcykpO1xuICAgICAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gQ29tcG9uZW50KVxuICAgICAgICAgIHZvaWQgMCA9PT0gbmV3UHJvcHNbX3Byb3BOYW1lXSAmJlxuICAgICAgICAgICAgKG5ld1Byb3BzW19wcm9wTmFtZV0gPSBDb21wb25lbnRbX3Byb3BOYW1lXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3UHJvcHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ1VuY2F1Z2h0RXJyb3Iocm9vdCwgZXJyb3JJbmZvKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb21wb25lbnROYW1lID0gZXJyb3JJbmZvLnNvdXJjZVxuICAgICAgICAgID8gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihlcnJvckluZm8uc291cmNlKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuICAgICAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG4gICAgICAgIGlmIChudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSlcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBvblVuY2F1Z2h0RXJyb3IgPSByb290Lm9uVW5jYXVnaHRFcnJvcjtcbiAgICAgICAgICBvblVuY2F1Z2h0RXJyb3IoZXJyb3IsIHsgY29tcG9uZW50U3RhY2s6IGVycm9ySW5mby5zdGFjayB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nQ2F1Z2h0RXJyb3Iocm9vdCwgYm91bmRhcnksIGVycm9ySW5mbykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29tcG9uZW50TmFtZSA9IGVycm9ySW5mby5zb3VyY2VcbiAgICAgICAgICA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZXJyb3JJbmZvLnNvdXJjZSlcbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihib3VuZGFyeSk7XG4gICAgICAgIHZhciBvbkNhdWdodEVycm9yID0gcm9vdC5vbkNhdWdodEVycm9yO1xuICAgICAgICBvbkNhdWdodEVycm9yKGVycm9ySW5mby52YWx1ZSwge1xuICAgICAgICAgIGNvbXBvbmVudFN0YWNrOiBlcnJvckluZm8uc3RhY2ssXG4gICAgICAgICAgZXJyb3JCb3VuZGFyeTogMSA9PT0gYm91bmRhcnkudGFnID8gYm91bmRhcnkuc3RhdGVOb2RlIDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290LCBlcnJvckluZm8sIGxhbmUpIHtcbiAgICAgIGxhbmUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICBsYW5lLnRhZyA9IENhcHR1cmVVcGRhdGU7XG4gICAgICBsYW5lLnBheWxvYWQgPSB7IGVsZW1lbnQ6IG51bGwgfTtcbiAgICAgIGxhbmUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGVycm9ySW5mby5zb3VyY2UsIGxvZ1VuY2F1Z2h0RXJyb3IsIHJvb3QsIGVycm9ySW5mbyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUobGFuZSkge1xuICAgICAgbGFuZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgIGxhbmUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZSh1cGRhdGUsIHJvb3QsIGZpYmVyLCBlcnJvckluZm8pIHtcbiAgICAgIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSBmaWJlci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IpIHtcbiAgICAgICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgICAgICB1cGRhdGUucGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGVycm9ySW5mby5zb3VyY2UsXG4gICAgICAgICAgICBsb2dDYXVnaHRFcnJvcixcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGVycm9ySW5mb1xuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgaW5zdCA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIG51bGwgIT09IGluc3QgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdC5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICAgICAodXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGVycm9ySW5mby5zb3VyY2UsXG4gICAgICAgICAgICBsb2dDYXVnaHRFcnJvcixcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGVycm9ySW5mb1xuICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWRcbiAgICAgICAgICAgICAgPyAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBuZXcgU2V0KFt0aGlzXSkpXG4gICAgICAgICAgICAgIDogbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuYWRkKHRoaXMpKTtcbiAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkQ2F0Y2hJbkRFVih0aGlzLCBlcnJvckluZm8pO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciB8fFxuICAgICAgICAgICAgKDAgPT09IChmaWJlci5sYW5lcyAmIDIpICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlczogRXJyb3IgYm91bmRhcmllcyBzaG91bGQgaW1wbGVtZW50IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpLiBJbiB0aGF0IG1ldGhvZCwgcmV0dXJuIGEgc3RhdGUgdXBkYXRlIHRvIGRpc3BsYXkgYW4gZXJyb3IgbWVzc2FnZSBvciBmYWxsYmFjayBVSS5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93RXhjZXB0aW9uKFxuICAgICAgcm9vdCxcbiAgICAgIHJldHVybkZpYmVyLFxuICAgICAgc291cmNlRmliZXIsXG4gICAgICB2YWx1ZSxcbiAgICAgIHJvb3RSZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgc291cmNlRmliZXIuZmxhZ3MgfD0gMzI3Njg7XG4gICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IHZhbHVlICYmXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZS50aGVuXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG4gICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyICYmXG4gICAgICAgICAgcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgICAgcm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgICAgITBcbiAgICAgICAgICApO1xuICAgICAgICBpc0h5ZHJhdGluZyAmJiAoZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMCk7XG4gICAgICAgIHNvdXJjZUZpYmVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgICAgaWYgKG51bGwgIT09IHNvdXJjZUZpYmVyKSB7XG4gICAgICAgICAgc3dpdGNoIChzb3VyY2VGaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gc2hlbGxCb3VuZGFyeVxuICAgICAgICAgICAgICAgICAgPyByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKClcbiAgICAgICAgICAgICAgICAgIDogbnVsbCA9PT0gc291cmNlRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzICYmXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZCksXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzICY9IC0yNTcpLFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmxhbmVzID0gcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlXG4gICAgICAgICAgICAgICAgICA/IChzb3VyY2VGaWJlci5mbGFncyB8PSAxNjM4NClcbiAgICAgICAgICAgICAgICAgIDogKChyZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgICAgICA/IChzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IG5ldyBTZXQoW3ZhbHVlXSkpXG4gICAgICAgICAgICAgICAgICAgICAgOiByZXR1cm5GaWJlci5hZGQodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgdmFsdWUsIHJvb3RSZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgICAgdmFsdWUgPT09IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZVxuICAgICAgICAgICAgICAgICAgPyAoc291cmNlRmliZXIuZmxhZ3MgfD0gMTYzODQpXG4gICAgICAgICAgICAgICAgICA6ICgocmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VySW5zdGFuY2VzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeVF1ZXVlOiBuZXcgU2V0KFt2YWx1ZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IHJldHVybkZpYmVyKSlcbiAgICAgICAgICAgICAgICAgICAgICA6ICgoc291cmNlRmliZXIgPSByZXR1cm5GaWJlci5yZXRyeVF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgPT09IHNvdXJjZUZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gKHJldHVybkZpYmVyLnJldHJ5UXVldWUgPSBuZXcgU2V0KFt2YWx1ZV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNvdXJjZUZpYmVyLmFkZCh2YWx1ZSkpLFxuICAgICAgICAgICAgICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgdmFsdWUsIHJvb3RSZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJVbmV4cGVjdGVkIFN1c3BlbnNlIGhhbmRsZXIgdGFnIChcIiArXG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLnRhZyArXG4gICAgICAgICAgICAgIFwiKS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0h5ZHJhdGluZylcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMCksXG4gICAgICAgICAgKHJldHVybkZpYmVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgID8gKDAgPT09IChyZXR1cm5GaWJlci5mbGFncyAmIDY1NTM2KSAmJiAocmV0dXJuRmliZXIuZmxhZ3MgfD0gMjU2KSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyLmxhbmVzID0gcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgdmFsdWUgIT09IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uICYmXG4gICAgICAgICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICAgICAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcgYnV0IFJlYWN0IHdhcyBhYmxlIHRvIHJlY292ZXIgYnkgaW5zdGVhZCBjbGllbnQgcmVuZGVyaW5nIGZyb20gdGhlIG5lYXJlc3QgU3VzcGVuc2UgYm91bmRhcnkuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgeyBjYXVzZTogdmFsdWUgfVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VGaWJlclxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICA6ICh2YWx1ZSAhPT0gSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24gJiZcbiAgICAgICAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGh5ZHJhdGluZyBidXQgUmVhY3Qgd2FzIGFibGUgdG8gcmVjb3ZlciBieSBpbnN0ZWFkIGNsaWVudCByZW5kZXJpbmcgdGhlIGVudGlyZSByb290LlwiLFxuICAgICAgICAgICAgICAgICAgICAgIHsgY2F1c2U6IHZhbHVlIH1cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlRmliZXJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAocm9vdCA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGUpLFxuICAgICAgICAgICAgICAocm9vdC5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgIChyb290UmVuZGVyTGFuZXMgJj0gLXJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIChyb290LmxhbmVzIHw9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICh2YWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2VGaWJlcikpLFxuICAgICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKFxuICAgICAgICAgICAgICAgIHJvb3Quc3RhdGVOb2RlLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHJvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHJvb3QsIHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgIT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgJiZcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RFcnJvcmVkKSksXG4gICAgICAgICAgITFcbiAgICAgICAgKTtcbiAgICAgIHZhciBlcnJvciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICBFcnJvcihcbiAgICAgICAgICBcIlRoZXJlIHdhcyBhbiBlcnJvciBkdXJpbmcgY29uY3VycmVudCByZW5kZXJpbmcgYnV0IFJlYWN0IHdhcyBhYmxlIHRvIHJlY292ZXIgYnkgaW5zdGVhZCBzeW5jaHJvbm91c2x5IHJlbmRlcmluZyB0aGUgZW50aXJlIHJvb3QuXCIsXG4gICAgICAgICAgeyBjYXVzZTogdmFsdWUgfVxuICAgICAgICApLFxuICAgICAgICBzb3VyY2VGaWJlclxuICAgICAgKTtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnNcbiAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IFtlcnJvcl0pXG4gICAgICAgIDogd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgIT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RXJyb3JlZCk7XG4gICAgICBpZiAobnVsbCA9PT0gcmV0dXJuRmliZXIpIHJldHVybiAhMDtcbiAgICAgIHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgICAgIHNvdXJjZUZpYmVyID0gcmV0dXJuRmliZXI7XG4gICAgICBkbyB7XG4gICAgICAgIHN3aXRjaCAoc291cmNlRmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgKHJvb3QgPSByb290UmVuZGVyTGFuZXMgJiAtcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmxhbmVzIHw9IHJvb3QpLFxuICAgICAgICAgICAgICAocm9vdCA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShcbiAgICAgICAgICAgICAgICBzb3VyY2VGaWJlci5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcm9vdFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHNvdXJjZUZpYmVyLCByb290KSxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKHJldHVybkZpYmVyID0gc291cmNlRmliZXIudHlwZSksXG4gICAgICAgICAgICAgIChlcnJvciA9IHNvdXJjZUZpYmVyLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAgIDAgPT09IChzb3VyY2VGaWJlci5mbGFncyAmIDEyOCkgJiZcbiAgICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuRmliZXIuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIHx8XG4gICAgICAgICAgICAgICAgICAobnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZXJyb3IuY29tcG9uZW50RGlkQ2F0Y2ggJiZcbiAgICAgICAgICAgICAgICAgICAgKG51bGwgPT09IGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIWxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhlcnJvcikpKSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzICY9IC1yb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5sYW5lcyB8PSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgIChyb290UmVuZGVyTGFuZXMgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHJvb3RSZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKFxuICAgICAgICAgICAgICAgICAgcm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZShzb3VyY2VGaWJlciwgcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZUZpYmVyID0gc291cmNlRmliZXIucmV0dXJuO1xuICAgICAgfSB3aGlsZSAobnVsbCAhPT0gc291cmNlRmliZXIpO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5leHRDaGlsZHJlbixcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9XG4gICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICA/IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpXG4gICAgICAgICAgOiByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIGN1cnJlbnQuY2hpbGQsXG4gICAgICAgICAgICAgIG5leHRDaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgQ29tcG9uZW50ID0gQ29tcG9uZW50LnJlbmRlcjtcbiAgICAgIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgICBpZiAoXCJyZWZcIiBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgdmFyIHByb3BzV2l0aG91dFJlZiA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV4dFByb3BzKVxuICAgICAgICAgIFwicmVmXCIgIT09IGtleSAmJiAocHJvcHNXaXRob3V0UmVmW2tleV0gPSBuZXh0UHJvcHNba2V5XSk7XG4gICAgICB9IGVsc2UgcHJvcHNXaXRob3V0UmVmID0gbmV4dFByb3BzO1xuICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbmV4dFByb3BzID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBwcm9wc1dpdGhvdXRSZWYsXG4gICAgICAgIHJlZixcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgICBrZXkgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmICFkaWRSZWNlaXZlVXBkYXRlKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICApO1xuICAgICAgaXNIeWRyYXRpbmcgJiYga2V5ICYmIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlTWVtb0NvbXBvbmVudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICB2YXIgdHlwZSA9IENvbXBvbmVudC50eXBlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgICFzaG91bGRDb25zdHJ1Y3QodHlwZSkgJiZcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUuZGVmYXVsdFByb3BzICYmXG4gICAgICAgICAgbnVsbCA9PT0gQ29tcG9uZW50LmNvbXBhcmVcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoQ29tcG9uZW50ID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50YWcgPSAxNSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCksXG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIHR5cGUpLFxuICAgICAgICAgICAgdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICAgICAgQ29tcG9uZW50LnR5cGUsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSxcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApO1xuICAgICAgICBjdXJyZW50LnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgcmV0dXJuICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgdHlwZSA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICBpZiAoIWNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSkge1xuICAgICAgICB2YXIgcHJldlByb3BzID0gdHlwZS5tZW1vaXplZFByb3BzO1xuICAgICAgICBDb21wb25lbnQgPSBDb21wb25lbnQuY29tcGFyZTtcbiAgICAgICAgQ29tcG9uZW50ID0gbnVsbCAhPT0gQ29tcG9uZW50ID8gQ29tcG9uZW50IDogc2hhbGxvd0VxdWFsO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgQ29tcG9uZW50KHByZXZQcm9wcywgbmV4dFByb3BzKSAmJlxuICAgICAgICAgIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWZcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgIGN1cnJlbnQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyh0eXBlLCBuZXh0UHJvcHMpO1xuICAgICAgY3VycmVudC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgICBjdXJyZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgcmV0dXJuICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpICYmXG4gICAgICAgICAgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZiAmJlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IGN1cnJlbnQudHlwZVxuICAgICAgICApXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKChkaWRSZWNlaXZlVXBkYXRlID0gITEpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IG5leHRQcm9wcyA9IHByZXZQcm9wcyksXG4gICAgICAgICAgICBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMzEwNzIpICYmIChkaWRSZWNlaXZlVXBkYXRlID0gITApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXMpLFxuICAgICAgICAgICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgbmV4dElzRGV0YWNoZWQgPVxuICAgICAgICAgIDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuX3BlbmRpbmdWaXNpYmlsaXR5ICYgMiksXG4gICAgICAgIHByZXZTdGF0ZSA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkU3RhdGUgOiBudWxsO1xuICAgICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAoXCJoaWRkZW5cIiA9PT0gbmV4dFByb3BzLm1vZGUgfHwgbmV4dElzRGV0YWNoZWQpIHtcbiAgICAgICAgaWYgKDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCkpIHtcbiAgICAgICAgICBuZXh0UHJvcHMgPVxuICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgICAgID8gcHJldlN0YXRlLmJhc2VMYW5lcyB8IHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgIDogcmVuZGVyTGFuZXM7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICAgICAgICAgIGZvciAobmV4dElzRGV0YWNoZWQgPSAwOyBudWxsICE9PSBuZXh0Q2hpbGRyZW47IClcbiAgICAgICAgICAgICAgKG5leHRJc0RldGFjaGVkID1cbiAgICAgICAgICAgICAgICBuZXh0SXNEZXRhY2hlZCB8IG5leHRDaGlsZHJlbi5sYW5lcyB8IG5leHRDaGlsZHJlbi5jaGlsZExhbmVzKSxcbiAgICAgICAgICAgICAgICAobmV4dENoaWxkcmVuID0gbmV4dENoaWxkcmVuLnNpYmxpbmcpO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IG5leHRJc0RldGFjaGVkICYgfm5leHRQcm9wcztcbiAgICAgICAgICB9IGVsc2UgKHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSAwKSwgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbCk7XG4gICAgICAgICAgcmV0dXJuIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwICE9PSAocmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpKVxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0geyBiYXNlTGFuZXM6IDAsIGNhY2hlUG9vbDogbnVsbCB9KSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgcHVzaFRyYW5zaXRpb24oXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlID8gcHJldlN0YXRlLmNhY2hlUG9vbCA6IG51bGxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG51bGwgIT09IHByZXZTdGF0ZVxuICAgICAgICAgICAgICA/IHB1c2hIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2U3RhdGUpXG4gICAgICAgICAgICAgIDogcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gNTM2ODcwOTEyKSxcbiAgICAgICAgICAgIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgICAgICAgPyBwcmV2U3RhdGUuYmFzZUxhbmVzIHwgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICA6IHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgPyAocHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZS5jYWNoZVBvb2wpLFxuICAgICAgICAgICAgcHVzaEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZSksXG4gICAgICAgICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsKSlcbiAgICAgICAgICA6IChudWxsICE9PSBjdXJyZW50ICYmIHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBudWxsKSxcbiAgICAgICAgICAgIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dEJhc2VMYW5lcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcGVla0NhY2hlRnJvbVBvb2woKTtcbiAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgIG51bGwgPT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICBwYXJlbnQ6IGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgICAgICAgICAgPyBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgICAgIDogQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWUyLFxuICAgICAgICAgICAgICBwb29sOiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgICAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICBiYXNlTGFuZXM6IG5leHRCYXNlTGFuZXMsXG4gICAgICAgIGNhY2hlUG9vbDogSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG4gICAgICByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsICEwKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgaWYgKG51bGwgPT09IHJlZilcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQucmVmICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwOTc2NjQpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiByZWYgJiYgXCJvYmplY3RcIiAhPT0gdHlwZW9mIHJlZilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24sIGFuIG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVSZWYoKSwgb3IgdW5kZWZpbmVkL251bGwuXCJcbiAgICAgICAgICApO1xuICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCBjdXJyZW50LnJlZiAhPT0gcmVmKVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwOTc2NjQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclxuICAgICAgKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSAhMCkpO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSAmIDggJiZcbiAgICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAodmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgQ29tcG9uZW50LmNvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICgoY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXNbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgICAgICgoZGlkV2FybkFib3V0Q29udGV4dFR5cGVzW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIFJlYWN0LnVzZUNvbnRleHQoKSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKSkpKTtcbiAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIENvbXBvbmVudCA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApO1xuICAgICAgbmV4dFByb3BzID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICAgKTtcbiAgICAgIGlzSHlkcmF0aW5nICYmIG5leHRQcm9wcyAmJiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgc2Vjb25kQXJnLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgY3VycmVudC50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgbmV4dFByb3BzID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4oXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgc2Vjb25kQXJnXG4gICAgICApO1xuICAgICAgZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgQ29tcG9uZW50ID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICAgKTtcbiAgICAgIGlzSHlkcmF0aW5nICYmIENvbXBvbmVudCAmJiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KFxuICAgICAgY3VycmVudCRqc2NvbXAkMCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHN3aXRjaCAoc2hvdWxkRXJyb3JJbXBsKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICBjYXNlICExOlxuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsXG4gICAgICAgICAgICBzdGF0ZSA9IG5ldyB3b3JrSW5Qcm9ncmVzcy50eXBlKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICBfaW5zdGFuY2UuY29udGV4dFxuICAgICAgICAgICAgKS5zdGF0ZTtcbiAgICAgICAgICBfaW5zdGFuY2UudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUoX2luc3RhbmNlLCBzdGF0ZSwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgITA6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4O1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY1NTM2O1xuICAgICAgICAgIF9pbnN0YW5jZSA9IEVycm9yKFwiU2ltdWxhdGVkIGVycm9yIGNvbWluZyBmcm9tIERldlRvb2xzXCIpO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVuZGVyTGFuZXMgJiAtcmVuZGVyTGFuZXM7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgfD0gbGFuZTtcbiAgICAgICAgICBzdGF0ZSA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gc3RhdGUpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGFuZSA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUobGFuZSk7XG4gICAgICAgICAgaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUoXG4gICAgICAgICAgICBsYW5lLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKF9pbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGxhbmUpO1xuICAgICAgfVxuICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSkge1xuICAgICAgICBzdGF0ZSA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgX2luc3RhbmNlID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgICAgICBcImNvbnRleHRUeXBlXCIgaW4gQ29tcG9uZW50ICYmXG4gICAgICAgICAgbnVsbCAhPT0gX2luc3RhbmNlICYmXG4gICAgICAgICAgKHZvaWQgMCA9PT0gX2luc3RhbmNlIHx8IF9pbnN0YW5jZS4kJHR5cGVvZiAhPT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSAmJlxuICAgICAgICAgICFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKENvbXBvbmVudCkgJiZcbiAgICAgICAgICAoZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChDb21wb25lbnQpLFxuICAgICAgICAgIChsYW5lID1cbiAgICAgICAgICAgIHZvaWQgMCA9PT0gX2luc3RhbmNlXG4gICAgICAgICAgICAgID8gXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IGEgdHlwbyBvciBieSBtaXhpbmcgdXAgbmFtZWQgYW5kIGRlZmF1bHQgaW1wb3J0cy4gVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gdHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLlwiXG4gICAgICAgICAgICAgIDogXCJvYmplY3RcIiAhPT0gdHlwZW9mIF9pbnN0YW5jZVxuICAgICAgICAgICAgICAgID8gXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGEgXCIgKyB0eXBlb2YgX2luc3RhbmNlICsgXCIuXCJcbiAgICAgICAgICAgICAgICA6IF9pbnN0YW5jZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRVxuICAgICAgICAgICAgICAgICAgPyBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/XCJcbiAgICAgICAgICAgICAgICAgIDogXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMge1wiICtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoX2luc3RhbmNlKS5qb2luKFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgICBcIn0uXCIpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXNcIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCIsXG4gICAgICAgICAgICBsYW5lXG4gICAgICAgICAgKSk7XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBfaW5zdGFuY2UgJiZcbiAgICAgICAgICBudWxsICE9PSBfaW5zdGFuY2UgJiZcbiAgICAgICAgICAoc3RhdGUgPSByZWFkQ29udGV4dChfaW5zdGFuY2UpKTtcbiAgICAgICAgX2luc3RhbmNlID0gbmV3IENvbXBvbmVudChuZXh0UHJvcHMsIHN0YXRlKTtcbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiA4KSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfaW5zdGFuY2UgPSBuZXcgQ29tcG9uZW50KG5leHRQcm9wcywgc3RhdGUpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgICAgbnVsbCAhPT0gX2luc3RhbmNlLnN0YXRlICYmIHZvaWQgMCAhPT0gX2luc3RhbmNlLnN0YXRlXG4gICAgICAgICAgICA/IF9pbnN0YW5jZS5zdGF0ZVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBfaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gX2luc3RhbmNlO1xuICAgICAgICBfaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxzID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIF9pbnN0YW5jZS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gZmFrZUludGVybmFsSW5zdGFuY2U7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgICBudWxsID09PSBzdGF0ZSAmJlxuICAgICAgICAgICgoc3RhdGUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKHN0YXRlKSB8fFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoc3RhdGUpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJgJXNgIHVzZXMgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYnV0IGl0cyBpbml0aWFsIHN0YXRlIGlzICVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5IGFzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiBUaGlzIGVuc3VyZXMgdGhhdCBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBhcmd1bWVudHMgaGF2ZSBhIGNvbnNpc3RlbnQgc2hhcGUuXCIsXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICBudWxsID09PSBfaW5zdGFuY2Uuc3RhdGUgPyBcIm51bGxcIiA6IFwidW5kZWZpbmVkXCIsXG4gICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICApKSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBmb3VuZFdpbGxVcGRhdGVOYW1lID0gKGxhbmUgPSBzdGF0ZSA9IG51bGwpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAhMCAhPT0gX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICA/IChzdGF0ZSA9IFwiY29tcG9uZW50V2lsbE1vdW50XCIpXG4gICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgIChzdGF0ZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFwiKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICEwICE9PVxuICAgICAgICAgICAgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgPyAobGFuZSA9IFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiKVxuICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgICAobGFuZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIik7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAhMCAhPT0gX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgPyAoZm91bmRXaWxsVXBkYXRlTmFtZSA9IFwiY29tcG9uZW50V2lsbFVwZGF0ZVwiKVxuICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgKGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlXCIpO1xuICAgICAgICAgIGlmIChudWxsICE9PSBzdGF0ZSB8fCBudWxsICE9PSBsYW5lIHx8IG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWUpIHtcbiAgICAgICAgICAgIF9pbnN0YW5jZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgICAgICB2YXIgbmV3QXBpTmFtZSA9XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcbiAgICAgICAgICAgICAgICA/IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKClcIlxuICAgICAgICAgICAgICAgIDogXCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpXCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfaW5zdGFuY2UpIHx8XG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfaW5zdGFuY2UpLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcblRoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbmh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzXCIsXG4gICAgICAgICAgICAgICAgX2luc3RhbmNlLFxuICAgICAgICAgICAgICAgIG5ld0FwaU5hbWUsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gc3RhdGUgPyBcIlxcbiAgXCIgKyBzdGF0ZSA6IFwiXCIsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gbGFuZSA/IFwiXFxuICBcIiArIGxhbmUgOiBcIlwiLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWUgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxVcGRhdGVOYW1lIDogXCJcIlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBzdGF0ZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgIF9pbnN0YW5jZS5yZW5kZXIgfHxcbiAgICAgICAgICAoQ29tcG9uZW50LnByb3RvdHlwZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyXG4gICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlICVzIGluc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yP1wiLFxuICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIk5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgJXMgaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLlwiLFxuICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAhX2luc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fFxuICAgICAgICAgIF9pbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHxcbiAgICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgfHxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiBEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD9cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlLmdldERlZmF1bHRQcm9wcyAmJlxuICAgICAgICAgICFfaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlLmNvbnRleHRUeXBlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzICYmXG4gICAgICAgICAgIWRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzLmhhcyhDb21wb25lbnQpICYmXG4gICAgICAgICAgKGRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzLmFkZChDb21wb25lbnQpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjaGlsZENvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICkpO1xuICAgICAgICBDb21wb25lbnQuY29udGV4dFR5cGVzICYmXG4gICAgICAgICAgIWRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxLmhhcyhDb21wb25lbnQpICYmXG4gICAgICAgICAgKGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxLmFkZChDb21wb25lbnQpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggc3RhdGljIGNvbnRleHRUeXBlIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBDb21wb25lbnQucHJvdG90eXBlICYmXG4gICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJlxuICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiBQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQSBwdXJlIGNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/XCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiBJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgdXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgcnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/XCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/XCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIGxhbmUgPSBfaW5zdGFuY2UucHJvcHMgIT09IG5leHRQcm9wcztcbiAgICAgICAgdm9pZCAwICE9PSBfaW5zdGFuY2UucHJvcHMgJiZcbiAgICAgICAgICBsYW5lICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgdXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIF9pbnN0YW5jZS5kZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuXCIsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXMoQ29tcG9uZW50KSB8fFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKENvbXBvbmVudCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KVxuICAgICAgICAgICkpO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgKGxhbmUgPSBfaW5zdGFuY2Uuc3RhdGUpICYmXG4gICAgICAgICAgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBsYW5lIHx8IGlzQXJyYXlJbXBsKGxhbmUpKSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIlcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGxcIiwgc3RhdGUpO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICYmXG4gICAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gdXNlIGdldENoaWxkQ29udGV4dCgpLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIF9pbnN0YW5jZS5wcm9wcyA9IG5leHRQcm9wcztcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX2luc3RhbmNlLnJlZnMgPSB7fTtcbiAgICAgICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgc3RhdGUgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgICAgIF9pbnN0YW5jZS5jb250ZXh0ID1cbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygc3RhdGUgJiYgbnVsbCAhPT0gc3RhdGVcbiAgICAgICAgICAgID8gcmVhZENvbnRleHQoc3RhdGUpXG4gICAgICAgICAgICA6IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID09PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgICAoKHN0YXRlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKHN0YXRlKSB8fFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChzdGF0ZSksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gYXNzaWduIHByb3BzIGRpcmVjdGx5IHRvIHN0YXRlIGJlY2F1c2UgdXBkYXRlcyB0byBwcm9wcyB3b24ndCBiZSByZWZsZWN0ZWQgaW4gc3RhdGUuIEluIG1vc3QgY2FzZXMsIGl0IGlzIGJldHRlciB0byB1c2UgcHJvcHMgZGlyZWN0bHkuXCIsXG4gICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICApKSk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUgJiA4ICYmXG4gICAgICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIF9pbnN0YW5jZVxuICAgICAgICAgICk7XG4gICAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIF9pbnN0YW5jZVxuICAgICAgICApO1xuICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBzdGF0ZSA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHN0YXRlICYmXG4gICAgICAgICAgKGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICksXG4gICAgICAgICAgKF9pbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCkgfHxcbiAgICAgICAgICAoKHN0YXRlID0gX2luc3RhbmNlLnN0YXRlKSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCksXG4gICAgICAgICAgc3RhdGUgIT09IF9pbnN0YW5jZS5zdGF0ZSAmJlxuICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoXG4gICAgICAgICAgICAgIF9pbnN0YW5jZSxcbiAgICAgICAgICAgICAgX2luc3RhbmNlLnN0YXRlLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgX2luc3RhbmNlLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpLFxuICAgICAgICAgIChfaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KTtcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NzEwODg2NCk7XG4gICAgICAgIF9pbnN0YW5jZSA9ICEwO1xuICAgICAgfSBlbHNlIGlmIChudWxsID09PSBjdXJyZW50JGpzY29tcCQwKSB7XG4gICAgICAgIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIHVucmVzb2x2ZWRPbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAgIGxhbmUgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gICAgICAgIF9pbnN0YW5jZS5wcm9wcyA9IGxhbmU7XG4gICAgICAgIHZhciBvbGRDb250ZXh0ID0gX2luc3RhbmNlLmNvbnRleHQ7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgICAgIHN0YXRlID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZm91bmRXaWxsVXBkYXRlTmFtZSAmJlxuICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWUgJiZcbiAgICAgICAgICAoc3RhdGUgPSByZWFkQ29udGV4dChmb3VuZFdpbGxVcGRhdGVOYW1lKSk7XG4gICAgICAgIG5ld0FwaU5hbWUgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID1cbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdBcGlOYW1lIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlO1xuICAgICAgICB1bnJlc29sdmVkT2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgIT09IHVucmVzb2x2ZWRPbGRQcm9wcztcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSB8fFxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB8fFxuICAgICAgICAgICgodW5yZXNvbHZlZE9sZFByb3BzIHx8IG9sZENvbnRleHQgIT09IHN0YXRlKSAmJlxuICAgICAgICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBfaW5zdGFuY2UsXG4gICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICkpO1xuICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9ICExO1xuICAgICAgICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIF9pbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gICAgICAgIG9sZENvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICB1bnJlc29sdmVkT2xkUHJvcHMgfHwgb2xkU3RhdGUgIT09IG9sZENvbnRleHQgfHwgaGFzRm9yY2VVcGRhdGVcbiAgICAgICAgICA/IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdBcGlOYW1lICYmXG4gICAgICAgICAgICAgIChhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgbmV3QXBpTmFtZSxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKG9sZENvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSksXG4gICAgICAgICAgICAobGFuZSA9XG4gICAgICAgICAgICAgIGhhc0ZvcmNlVXBkYXRlIHx8XG4gICAgICAgICAgICAgIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBsYW5lLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSxcbiAgICAgICAgICAgICAgICBvbGRDb250ZXh0LFxuICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgID8gKGZvdW5kV2lsbFVwZGF0ZU5hbWUgfHxcbiAgICAgICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KSB8fFxuICAgICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpLFxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSksXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY3MTA4ODY0KSlcbiAgICAgICAgICAgICAgOiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY3MTA4ODY0KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBvbGRDb250ZXh0KSksXG4gICAgICAgICAgICAoX2luc3RhbmNlLnByb3BzID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2Uuc3RhdGUgPSBvbGRDb250ZXh0KSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UuY29udGV4dCA9IHN0YXRlKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UgPSBsYW5lKSlcbiAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQzMDgpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNjcxMDg4NjQpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZSA9ICExKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCRqc2NvbXAkMCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIHN0YXRlKTtcbiAgICAgICAgX2luc3RhbmNlLnByb3BzID0gZm91bmRXaWxsVXBkYXRlTmFtZTtcbiAgICAgICAgbmV3QXBpTmFtZSA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgb2xkU3RhdGUgPSBfaW5zdGFuY2UuY29udGV4dDtcbiAgICAgICAgb2xkQ29udGV4dCA9IENvbXBvbmVudC5jb250ZXh0VHlwZTtcbiAgICAgICAgbGFuZSA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9sZENvbnRleHQgJiZcbiAgICAgICAgICBudWxsICE9PSBvbGRDb250ZXh0ICYmXG4gICAgICAgICAgKGxhbmUgPSByZWFkQ29udGV4dChvbGRDb250ZXh0KSk7XG4gICAgICAgIHVucmVzb2x2ZWRPbGRQcm9wcyA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgICAgIChvbGRDb250ZXh0ID1cbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB1bnJlc29sdmVkT2xkUHJvcHMgfHxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUpIHx8XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHx8XG4gICAgICAgICAgKChzdGF0ZSAhPT0gbmV3QXBpTmFtZSB8fCBvbGRTdGF0ZSAhPT0gbGFuZSkgJiZcbiAgICAgICAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgX2luc3RhbmNlLFxuICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIGxhbmVcbiAgICAgICAgICAgICkpO1xuICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9ICExO1xuICAgICAgICBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9pbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgX2luc3RhbmNlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgc3RhdGUgIT09IG5ld0FwaU5hbWUgfHxcbiAgICAgICAgb2xkU3RhdGUgIT09IG5ld1N0YXRlIHx8XG4gICAgICAgIGhhc0ZvcmNlVXBkYXRlIHx8XG4gICAgICAgIChudWxsICE9PSBjdXJyZW50JGpzY29tcCQwICYmXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCRqc2NvbXAkMC5kZXBlbmRlbmNpZXMgJiZcbiAgICAgICAgICBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCRqc2NvbXAkMC5kZXBlbmRlbmNpZXMpKVxuICAgICAgICAgID8gKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVucmVzb2x2ZWRPbGRQcm9wcyAmJlxuICAgICAgICAgICAgICAoYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRPbGRQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpLFxuICAgICAgICAgICAgKGZvdW5kV2lsbFVwZGF0ZU5hbWUgPVxuICAgICAgICAgICAgICBoYXNGb3JjZVVwZGF0ZSB8fFxuICAgICAgICAgICAgICBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgbGFuZVxuICAgICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50JGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCRqc2NvbXAkMC5kZXBlbmRlbmNpZXMgJiZcbiAgICAgICAgICAgICAgICBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCRqc2NvbXAkMC5kZXBlbmRlbmNpZXMpKSlcbiAgICAgICAgICAgICAgPyAob2xkQ29udGV4dCB8fFxuICAgICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5ld1N0YXRlLCBsYW5lKSxcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIGxhbmVcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEwMjQpKVxuICAgICAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlIHx8XG4gICAgICAgICAgICAgICAgICAoc3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgKHN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgb2xkU3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZSkpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5wcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAoX2luc3RhbmNlLnN0YXRlID0gbmV3U3RhdGUpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5jb250ZXh0ID0gbGFuZSksXG4gICAgICAgICAgICAoX2luc3RhbmNlID0gZm91bmRXaWxsVXBkYXRlTmFtZSkpXG4gICAgICAgICAgOiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgICAgICAoc3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgIG9sZFN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgICAgICAoc3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgIG9sZFN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UgPSAhMSkpO1xuICAgICAgfVxuICAgICAgbGFuZSA9IF9pbnN0YW5jZTtcbiAgICAgIG1hcmtSZWYoY3VycmVudCRqc2NvbXAkMCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgc3RhdGUgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpO1xuICAgICAgaWYgKGxhbmUgfHwgc3RhdGUpIHtcbiAgICAgICAgbGFuZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID1cbiAgICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzcyA/IG51bGwgOiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2O1xuICAgICAgICBpc1JlbmRlcmluZyA9ICExO1xuICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIGlmIChzdGF0ZSAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKVxuICAgICAgICAgIChDb21wb25lbnQgPSBudWxsKSwgKHByb2ZpbGVyU3RhcnRUaW1lID0gLTEpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgQ29tcG9uZW50ID0gY2FsbFJlbmRlckluREVWKGxhbmUpO1xuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgOCkge1xuICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY2FsbFJlbmRlckluREVWKGxhbmUpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQkanNjb21wJDAgJiYgc3RhdGVcbiAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIGN1cnJlbnQkanNjb21wJDAuY2hpbGQsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSkpXG4gICAgICAgICAgOiByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBsYW5lLnN0YXRlO1xuICAgICAgICBjdXJyZW50JGpzY29tcCQwID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICB9IGVsc2VcbiAgICAgICAgY3VycmVudCRqc2NvbXAkMCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgY3VycmVudCRqc2NvbXAkMCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApO1xuICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBfaW5zdGFuY2UgJiZcbiAgICAgICAgcmVuZGVyTGFuZXMucHJvcHMgIT09IG5leHRQcm9wcyAmJlxuICAgICAgICAoZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkl0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIGNhbiBsZWFkIHRvIGNvbmZ1c2luZyBidWdzLlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgXCJhIGNvbXBvbmVudFwiXG4gICAgICAgICAgKSxcbiAgICAgICAgKGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSAhMCkpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQkanNjb21wJDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDI1NjtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpIHtcbiAgICAgIENvbXBvbmVudCAmJlxuICAgICAgICBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcImNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb24gY29tcG9uZW50LlxcbiAgJXMuY2hpbGRDb250ZXh0VHlwZXMgPSAuLi5cIixcbiAgICAgICAgICBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICApO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAoKHdvcmtJblByb2dyZXNzID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJVbmtub3duXCIpLFxuICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W3dvcmtJblByb2dyZXNzXSB8fFxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuXCIsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbd29ya0luUHJvZ3Jlc3NdID1cbiAgICAgICAgICAgICEwKSkpO1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIENvbXBvbmVudC5jb250ZXh0VHlwZSAmJlxuICAgICAgICBudWxsICE9PSBDb21wb25lbnQuY29udGV4dFR5cGUgJiZcbiAgICAgICAgKChDb21wb25lbnQgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIlVua25vd25cIiksXG4gICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtDb21wb25lbnRdIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLlwiLFxuICAgICAgICAgICAgQ29tcG9uZW50XG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W0NvbXBvbmVudF0gPSAhMCkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSB7XG4gICAgICByZXR1cm4geyBiYXNlTGFuZXM6IHJlbmRlckxhbmVzLCBjYWNoZVBvb2w6IGdldFN1c3BlbmRlZENhY2hlKCkgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gICAgICBjdXJyZW50LFxuICAgICAgcHJpbWFyeVRyZWVEaWREZWZlcixcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBjdXJyZW50ID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQuY2hpbGRMYW5lcyAmIH5yZW5kZXJMYW5lcyA6IDA7XG4gICAgICBwcmltYXJ5VHJlZURpZERlZmVyICYmIChjdXJyZW50IHw9IHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICBzaG91bGRTdXNwZW5kSW1wbCh3b3JrSW5Qcm9ncmVzcykgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCk7XG4gICAgICB2YXIgc2hvd0ZhbGxiYWNrID0gITEsXG4gICAgICAgIGRpZFN1c3BlbmQgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpLFxuICAgICAgICBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICAoSlNDb21waWxlcl90ZW1wID0gZGlkU3VzcGVuZCkgfHxcbiAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBudWxsID09PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgID8gITFcbiAgICAgICAgICAgIDogMCAhPT0gKHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCAmIEZvcmNlU3VzcGVuc2VGYWxsYmFjaykpO1xuICAgICAgSlNDb21waWxlcl90ZW1wICYmICgoc2hvd0ZhbGxiYWNrID0gITApLCAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTEyOSkpO1xuICAgICAgSlNDb21waWxlcl90ZW1wID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMzIpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTMzO1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgc2hvd0ZhbGxiYWNrXG4gICAgICAgICAgICA/IHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgIDogcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlLFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDA7XG4gICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gIW5leHRJbnN0YW5jZSkgfHxcbiAgICAgICAgICAgICAgKChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZShcbiAgICAgICAgICAgICAgICBuZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgPyAod2FybklmTm90SHlkcmF0aW5nKCksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGVoeWRyYXRlZDogSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICB0cmVlQ29udGV4dDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSB0cmVlQ29udGV4dFByb3ZpZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgaWQ6IHRyZWVDb250ZXh0SWQsIG92ZXJmbG93OiB0cmVlQ29udGV4dE92ZXJmbG93IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlMYW5lOiA1MzY4NzA5MTJcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgKGRpZFN1c3BlbmQgPSBjcmVhdGVGaWJlcigxOCwgbnVsbCwgbnVsbCwgTm9Nb2RlKSksXG4gICAgICAgICAgICAgICAgICAoZGlkU3VzcGVuZC5zdGF0ZU5vZGUgPSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDApLFxuICAgICAgICAgICAgICAgICAgKGRpZFN1c3BlbmQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gZGlkU3VzcGVuZCksXG4gICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9ICEwKSlcbiAgICAgICAgICAgICAgICA6IChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSAhMSksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSAhSlNDb21waWxlcl90ZW1wJGpzY29tcCQwKSk7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgKHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBuZXh0SW5zdGFuY2UpLFxuICAgICAgICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dEluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsICE9PSBuZXh0SW5zdGFuY2UgJiZcbiAgICAgICAgICAgICgobmV4dEluc3RhbmNlID0gbmV4dEluc3RhbmNlLmRlaHlkcmF0ZWQpLCBudWxsICE9PSBuZXh0SW5zdGFuY2UpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2sobmV4dEluc3RhbmNlKVxuICAgICAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzLmxhbmVzID0gMTYpXG4gICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSA1MzY4NzA5MTIpLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEluc3RhbmNlID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgICBuZXh0UHJvcHMgPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG4gICAgICAgIGlmIChzaG93RmFsbGJhY2spXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gd29ya0luUHJvZ3Jlc3MubW9kZSksXG4gICAgICAgICAgICAobmV4dEluc3RhbmNlID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKFxuICAgICAgICAgICAgICB7IG1vZGU6IFwiaGlkZGVuXCIsIGNoaWxkcmVuOiBuZXh0SW5zdGFuY2UgfSxcbiAgICAgICAgICAgICAgc2hvd0ZhbGxiYWNrXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICBzaG93RmFsbGJhY2ssXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChuZXh0SW5zdGFuY2UucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKG5leHRQcm9wcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAobmV4dEluc3RhbmNlLnNpYmxpbmcgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV4dEluc3RhbmNlKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICAgICAgICBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2suY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUiksXG4gICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICApO1xuICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwICYmXG4gICAgICAgICgobmV4dEluc3RhbmNlID0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLmRlaHlkcmF0ZWQpLFxuICAgICAgICBudWxsICE9PSBuZXh0SW5zdGFuY2UpXG4gICAgICApIHtcbiAgICAgICAgaWYgKGRpZFN1c3BlbmQpXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTZcbiAgICAgICAgICAgID8gKHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMjU3KSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgIDogbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICA/IChyZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IG51bGwpKVxuICAgICAgICAgICAgICA6IChyZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSBuZXh0UHJvcHMuZmFsbGJhY2spLFxuICAgICAgICAgICAgICAgIChuZXh0SW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKFxuICAgICAgICAgICAgICAgICAgeyBtb2RlOiBcInZpc2libGVcIiwgY2hpbGRyZW46IG5leHRQcm9wcy5jaGlsZHJlbiB9LFxuICAgICAgICAgICAgICAgICAgbmV4dEluc3RhbmNlXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICAgICAgc2hvd0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgbmV4dEluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHNob3dGYWxsYmFjay5mbGFncyB8PSAyKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAoc2hvd0ZhbGxiYWNrLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzLnNpYmxpbmcgPSBzaG93RmFsbGJhY2spLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY2hpbGQsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgKG5leHRQcm9wcy5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICAgICAgICAgIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBzaG93RmFsbGJhY2spKTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiV2Ugc2hvdWxkIG5vdCBiZSBoeWRyYXRpbmcgaGVyZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYSBidWcuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2sobmV4dEluc3RhbmNlKSlcbiAgICAgICAgKVxuICAgICAgICAgIChuZXh0SW5zdGFuY2UgPVxuICAgICAgICAgICAgZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzKG5leHRJbnN0YW5jZSkpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IG5leHRJbnN0YW5jZS5kaWdlc3QpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IG5leHRJbnN0YW5jZS5tZXNzYWdlKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMgPSBuZXh0SW5zdGFuY2Uuc3RhY2spLFxuICAgICAgICAgICAgKG5leHRJbnN0YW5jZSA9IG5leHRJbnN0YW5jZS5jb21wb25lbnRTdGFjayksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gc2hvd0ZhbGxiYWNrXG4gICAgICAgICAgICAgID8gRXJyb3Ioc2hvd0ZhbGxiYWNrKVxuICAgICAgICAgICAgICA6IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUaGUgc2VydmVyIGNvdWxkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeSwgbGlrZWx5IGR1ZSB0byBhbiBlcnJvciBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy4gU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjay5zdGFjayA9IG5leHRQcm9wcyB8fCBcIlwiKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2suZGlnZXN0ID0gSlNDb21waWxlcl90ZW1wKSxcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPSB2b2lkIDAgPT09IG5leHRJbnN0YW5jZSA/IG51bGwgOiBuZXh0SW5zdGFuY2UpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IHtcbiAgICAgICAgICAgICAgdmFsdWU6IHNob3dGYWxsYmFjayxcbiAgICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgICBzdGFjazogSlNDb21waWxlcl90ZW1wXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBKU0NvbXBpbGVyX3RlbXAgJiZcbiAgICAgICAgICAgICAgQ2FwdHVyZWRTdGFja3Muc2V0KHNob3dGYWxsYmFjaywgbmV4dFByb3BzKSxcbiAgICAgICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IobmV4dFByb3BzKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICkpO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAoZGlkUmVjZWl2ZVVwZGF0ZSB8fFxuICAgICAgICAgICAgcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IDAgIT09IChyZW5kZXJMYW5lcyAmIGN1cnJlbnQuY2hpbGRMYW5lcykpLFxuICAgICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgfHwgSlNDb21waWxlcl90ZW1wKVxuICAgICAgICApIHtcbiAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICAgICAgaWYgKG51bGwgIT09IEpTQ29tcGlsZXJfdGVtcCkge1xuICAgICAgICAgICAgbmV4dFByb3BzID0gcmVuZGVyTGFuZXMgJiAtcmVuZGVyTGFuZXM7XG4gICAgICAgICAgICBpZiAoMCAhPT0gKG5leHRQcm9wcyAmIDQyKSkgbmV4dFByb3BzID0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgc3dpdGNoIChuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMgPSAxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzID0gNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMgPSAxNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI4OlxuICAgICAgICAgICAgICAgIGNhc2UgMjU2OlxuICAgICAgICAgICAgICAgIGNhc2UgNTEyOlxuICAgICAgICAgICAgICAgIGNhc2UgMTAyNDpcbiAgICAgICAgICAgICAgICBjYXNlIDIwNDg6XG4gICAgICAgICAgICAgICAgY2FzZSA0MDk2OlxuICAgICAgICAgICAgICAgIGNhc2UgODE5MjpcbiAgICAgICAgICAgICAgICBjYXNlIDE2Mzg0OlxuICAgICAgICAgICAgICAgIGNhc2UgMzI3Njg6XG4gICAgICAgICAgICAgICAgY2FzZSA2NTUzNjpcbiAgICAgICAgICAgICAgICBjYXNlIDEzMTA3MjpcbiAgICAgICAgICAgICAgICBjYXNlIDI2MjE0NDpcbiAgICAgICAgICAgICAgICBjYXNlIDUyNDI4ODpcbiAgICAgICAgICAgICAgICBjYXNlIDEwNDg1NzY6XG4gICAgICAgICAgICAgICAgY2FzZSAyMDk3MTUyOlxuICAgICAgICAgICAgICAgIGNhc2UgNDE5NDMwNDpcbiAgICAgICAgICAgICAgICBjYXNlIDgzODg2MDg6XG4gICAgICAgICAgICAgICAgY2FzZSAxNjc3NzIxNjpcbiAgICAgICAgICAgICAgICBjYXNlIDMzNTU0NDMyOlxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzID0gNjQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI2ODQzNTQ1NjpcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyA9IDEzNDIxNzcyODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0UHJvcHMgPVxuICAgICAgICAgICAgICAwICE9PSAobmV4dFByb3BzICYgKEpTQ29tcGlsZXJfdGVtcC5zdXNwZW5kZWRMYW5lcyB8IHJlbmRlckxhbmVzKSlcbiAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICA6IG5leHRQcm9wcztcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgMCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgICAgICAgIG5leHRQcm9wcyAhPT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnJldHJ5TGFuZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICAgKChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAucmV0cnlMYW5lID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoY3VycmVudCwgbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoSlNDb21waWxlcl90ZW1wLCBjdXJyZW50LCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgIFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbilcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhuZXh0SW5zdGFuY2UpIHx8XG4gICAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhuZXh0SW5zdGFuY2UpXG4gICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkuYmluZChcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIHJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5KG5leHRJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBudWxsKSlcbiAgICAgICAgICAgIDogKChjdXJyZW50ID0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnRyZWVDb250ZXh0KSxcbiAgICAgICAgICAgICAgc3VwcG9ydHNIeWRyYXRpb24gJiZcbiAgICAgICAgICAgICAgICAoKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlKG5leHRJbnN0YW5jZSkpLFxuICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAoaXNIeWRyYXRpbmcgPSAhMCksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpLFxuICAgICAgICAgICAgICAgIChkaWRTdXNwZW5kT3JFcnJvckRFViA9ICExKSxcbiAgICAgICAgICAgICAgICAoaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAocm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICAod2FybklmTm90SHlkcmF0aW5nKCksXG4gICAgICAgICAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkKSxcbiAgICAgICAgICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3cpLFxuICAgICAgICAgICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlciksXG4gICAgICAgICAgICAgICAgICAodHJlZUNvbnRleHRJZCA9IGN1cnJlbnQuaWQpLFxuICAgICAgICAgICAgICAgICAgKHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBjdXJyZW50Lm92ZXJmbG93KSxcbiAgICAgICAgICAgICAgICAgICh0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3MpKSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDA5NikpO1xuICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB9XG4gICAgICBpZiAoc2hvd0ZhbGxiYWNrKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgKHNob3dGYWxsYmFjayA9IG5leHRQcm9wcy5mYWxsYmFjayksXG4gICAgICAgICAgKG5leHRJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICAgICAoZGlkU3VzcGVuZCA9IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5zaWJsaW5nKSxcbiAgICAgICAgICAobmV4dFByb3BzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLCB7XG4gICAgICAgICAgICBtb2RlOiBcImhpZGRlblwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IG5leHRQcm9wcy5jaGlsZHJlblxuICAgICAgICAgIH0pKSxcbiAgICAgICAgICAobmV4dFByb3BzLnN1YnRyZWVGbGFncyA9XG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAuc3VidHJlZUZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAgIG51bGwgIT09IGRpZFN1c3BlbmRcbiAgICAgICAgICAgID8gKHNob3dGYWxsYmFjayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGRpZFN1c3BlbmQsIHNob3dGYWxsYmFjaykpXG4gICAgICAgICAgICA6ICgoc2hvd0ZhbGxiYWNrID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgICAgc2hvd0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIG5leHRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoc2hvd0ZhbGxiYWNrLmZsYWdzIHw9IDIpKSxcbiAgICAgICAgICAoc2hvd0ZhbGxiYWNrLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAobmV4dFByb3BzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAobmV4dFByb3BzLnNpYmxpbmcgPSBzaG93RmFsbGJhY2spLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5leHRQcm9wcyksXG4gICAgICAgICAgKG5leHRQcm9wcyA9IHNob3dGYWxsYmFjayksXG4gICAgICAgICAgKHNob3dGYWxsYmFjayA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAobmV4dEluc3RhbmNlID0gY3VycmVudC5jaGlsZC5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICBudWxsID09PSBuZXh0SW5zdGFuY2VcbiAgICAgICAgICAgID8gKG5leHRJbnN0YW5jZSA9IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykpXG4gICAgICAgICAgICA6ICgoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gbmV4dEluc3RhbmNlLmNhY2hlUG9vbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgID8gKChkaWRTdXNwZW5kID0gaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgICAgICAgICAgICAgPyBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlMiksXG4gICAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnBhcmVudCAhPT0gZGlkU3VzcGVuZFxuICAgICAgICAgICAgICAgICAgICAgID8geyBwYXJlbnQ6IGRpZFN1c3BlbmQsIHBvb2w6IGRpZFN1c3BlbmQgfVxuICAgICAgICAgICAgICAgICAgICAgIDogSlNDb21waWxlcl90ZW1wJGpzY29tcCQwKSlcbiAgICAgICAgICAgICAgICA6IChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBnZXRTdXNwZW5kZWRDYWNoZSgpKSxcbiAgICAgICAgICAgICAgKG5leHRJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgICBiYXNlTGFuZXM6IG5leHRJbnN0YW5jZS5iYXNlTGFuZXMgfCByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICBjYWNoZVBvb2w6IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMFxuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgKHNob3dGYWxsYmFjay5tZW1vaXplZFN0YXRlID0gbmV4dEluc3RhbmNlKSxcbiAgICAgICAgICAoc2hvd0ZhbGxiYWNrLmNoaWxkTGFuZXMgPSBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICkpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUiksXG4gICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICk7XG4gICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmVuZGVyTGFuZXMgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgY3VycmVudCA9IHJlbmRlckxhbmVzLnNpYmxpbmc7XG4gICAgICByZW5kZXJMYW5lcyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHJlbmRlckxhbmVzLCB7XG4gICAgICAgIG1vZGU6IFwidmlzaWJsZVwiLFxuICAgICAgICBjaGlsZHJlbjogbmV4dFByb3BzLmNoaWxkcmVuXG4gICAgICB9KTtcbiAgICAgIHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgcmVuZGVyTGFuZXMuc2libGluZyA9IG51bGw7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICgoSlNDb21waWxlcl90ZW1wID0gd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zKSxcbiAgICAgICAgbnVsbCA9PT0gSlNDb21waWxlcl90ZW1wXG4gICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IFtjdXJyZW50XSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTYpKVxuICAgICAgICAgIDogSlNDb21waWxlcl90ZW1wLnB1c2goY3VycmVudCkpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJMYW5lcztcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIHJlbmRlckxhbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4pIHtcbiAgICAgIHByaW1hcnlDaGlsZHJlbiA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihcbiAgICAgICAgeyBtb2RlOiBcInZpc2libGVcIiwgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlbiB9LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlXG4gICAgICApO1xuICAgICAgcHJpbWFyeUNoaWxkcmVuLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgcmV0dXJuICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZHJlbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihvZmZzY3JlZW5Qcm9wcywgbW9kZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihvZmZzY3JlZW5Qcm9wcywgbW9kZSwgMCwgbnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gICAgICBjdXJyZW50ID0gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlblxuICAgICAgKTtcbiAgICAgIGN1cnJlbnQuZmxhZ3MgfD0gMjtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihmaWJlciwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCkge1xuICAgICAgZmliZXIubGFuZXMgfD0gcmVuZGVyTGFuZXM7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUubGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChcbiAgICAgICAgZmliZXIucmV0dXJuLFxuICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgcHJvcGFnYXRpb25Sb290XG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKGNoaWxkU2xvdCwgaW5kZXgpIHtcbiAgICAgIHZhciBpc0FuQXJyYXkgPSBpc0FycmF5SW1wbChjaGlsZFNsb3QpO1xuICAgICAgY2hpbGRTbG90ID0gIWlzQW5BcnJheSAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBnZXRJdGVyYXRvckZuKGNoaWxkU2xvdCk7XG4gICAgICByZXR1cm4gaXNBbkFycmF5IHx8IGNoaWxkU2xvdFxuICAgICAgICA/ICgoaXNBbkFycmF5ID0gaXNBbkFycmF5ID8gXCJhcnJheVwiIDogXCJpdGVyYWJsZVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJBIG5lc3RlZCAlcyB3YXMgcGFzc2VkIHRvIHJvdyAjJXMgaW4gPFN1c3BlbnNlTGlzdCAvPi4gV3JhcCBpdCBpbiBhbiBhZGRpdGlvbmFsIFN1c3BlbnNlTGlzdCB0byBjb25maWd1cmUgaXRzIHJldmVhbE9yZGVyOiA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj4gLi4uIDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPnslc308L1N1c3BlbnNlTGlzdD4gLi4uIDwvU3VzcGVuc2VMaXN0PlwiLFxuICAgICAgICAgICAgaXNBbkFycmF5LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBpc0FuQXJyYXlcbiAgICAgICAgICApLFxuICAgICAgICAgICExKVxuICAgICAgICA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGlzQmFja3dhcmRzLFxuICAgICAgdGFpbCxcbiAgICAgIGxhc3RDb250ZW50Um93LFxuICAgICAgdGFpbE1vZGVcbiAgICApIHtcbiAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICBudWxsID09PSByZW5kZXJTdGF0ZVxuICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICAgICAgaXNCYWNrd2FyZHM6IGlzQmFja3dhcmRzLFxuICAgICAgICAgICAgcmVuZGVyaW5nOiBudWxsLFxuICAgICAgICAgICAgcmVuZGVyaW5nU3RhcnRUaW1lOiAwLFxuICAgICAgICAgICAgbGFzdDogbGFzdENvbnRlbnRSb3csXG4gICAgICAgICAgICB0YWlsOiB0YWlsLFxuICAgICAgICAgICAgdGFpbE1vZGU6IHRhaWxNb2RlXG4gICAgICAgICAgfSlcbiAgICAgICAgOiAoKHJlbmRlclN0YXRlLmlzQmFja3dhcmRzID0gaXNCYWNrd2FyZHMpLFxuICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID0gMCksXG4gICAgICAgICAgKHJlbmRlclN0YXRlLmxhc3QgPSBsYXN0Q29udGVudFJvdyksXG4gICAgICAgICAgKHJlbmRlclN0YXRlLnRhaWwgPSB0YWlsKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUudGFpbE1vZGUgPSB0YWlsTW9kZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICByZXZlYWxPcmRlciA9IG5leHRQcm9wcy5yZXZlYWxPcmRlcixcbiAgICAgICAgdGFpbE1vZGUgPSBuZXh0UHJvcHMudGFpbDtcbiAgICAgIG5leHRQcm9wcyA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChcbiAgICAgICAgdm9pZCAwICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICBcImZvcndhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgIFwiYmFja3dhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgIFwidG9nZXRoZXJcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgIWRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXVxuICAgICAgKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl0gPSAhMCksXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHJldmVhbE9yZGVyKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChyZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwidG9nZXRoZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmb3J3YXJkc1wiOlxuICAgICAgICAgICAgY2FzZSBcImJhY2t3YXJkc1wiOlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIFVzZSBsb3dlcmNhc2UgXCIlc1wiIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlcixcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZvcndhcmRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJiYWNrd2FyZFwiOlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIFJlYWN0IHVzZXMgdGhlIC1zIHN1ZmZpeCBpbiB0aGUgc3BlbGxpbmcuIFVzZSBcIiVzc1wiIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlcixcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiBEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICclcyBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIERpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsXG4gICAgICAgICAgICByZXZlYWxPcmRlclxuICAgICAgICAgICk7XG4gICAgICB2b2lkIDAgPT09IHRhaWxNb2RlIHx8XG4gICAgICAgIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSB8fFxuICAgICAgICAoXCJjb2xsYXBzZWRcIiAhPT0gdGFpbE1vZGUgJiYgXCJoaWRkZW5cIiAhPT0gdGFpbE1vZGVcbiAgICAgICAgICA/ICgoZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHRhaWwgb24gPFN1c3BlbnNlTGlzdCAvPi4gRGlkIHlvdSBtZWFuIFwiY29sbGFwc2VkXCIgb3IgXCJoaWRkZW5cIj8nLFxuICAgICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICAgKSlcbiAgICAgICAgICA6IFwiZm9yd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgICAgIFwiYmFja3dhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgICAgICAoKGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICc8U3VzcGVuc2VMaXN0IHRhaWw9XCIlc1wiIC8+IGlzIG9ubHkgdmFsaWQgaWYgcmV2ZWFsT3JkZXIgaXMgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCIuIERpZCB5b3UgbWVhbiB0byBzcGVjaWZ5IHJldmVhbE9yZGVyPVwiZm9yd2FyZHNcIj8nLFxuICAgICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICAgKSkpO1xuICAgICAgYTogaWYgKFxuICAgICAgICAoXCJmb3J3YXJkc1wiID09PSByZXZlYWxPcmRlciB8fCBcImJhY2t3YXJkc1wiID09PSByZXZlYWxPcmRlcikgJiZcbiAgICAgICAgdm9pZCAwICE9PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgbnVsbCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgICExICE9PSBuZXh0UHJvcHNcbiAgICAgIClcbiAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5leHRQcm9wcykpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0UHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChuZXh0UHJvcHNbaV0sIGkpKSBicmVhayBhO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKChpID0gZ2V0SXRlcmF0b3JGbihuZXh0UHJvcHMpKSwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSkpIHtcbiAgICAgICAgICBpZiAoKGkgPSBpLmNhbGwobmV4dFByb3BzKSkpXG4gICAgICAgICAgICBmb3IgKHZhciBzdGVwID0gaS5uZXh0KCksIF9pID0gMDsgIXN0ZXAuZG9uZTsgc3RlcCA9IGkubmV4dCgpKSB7XG4gICAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChzdGVwLnZhbHVlLCBfaSkpIGJyZWFrIGE7XG4gICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQSBzaW5nbGUgcm93IHdhcyBwYXNzZWQgdG8gYSA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPVwiJXNcIiAvPi4gVGhpcyBpcyBub3QgdXNlZnVsIHNpbmNlIGl0IG5lZWRzIG11bHRpcGxlIHJvd3MuIERpZCB5b3UgbWVhbiB0byBwYXNzIG11bHRpcGxlIGNoaWxkcmVuIG9yIGFuIGFycmF5PycsXG4gICAgICAgICAgICByZXZlYWxPcmRlclxuICAgICAgICAgICk7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICBuZXh0UHJvcHMgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICBpZiAoMCAhPT0gKG5leHRQcm9wcyAmIEZvcmNlU3VzcGVuc2VGYWxsYmFjaykpXG4gICAgICAgIChuZXh0UHJvcHMgPVxuICAgICAgICAgIChuZXh0UHJvcHMgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaykgfCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KSlcbiAgICAgICAgICBhOiBmb3IgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDsgbnVsbCAhPT0gY3VycmVudDsgKSB7XG4gICAgICAgICAgICBpZiAoMTMgPT09IGN1cnJlbnQudGFnKVxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbHNlIGlmICgxOSA9PT0gY3VycmVudC50YWcpXG4gICAgICAgICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihjdXJyZW50LCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgZWxzZSBpZiAobnVsbCAhPT0gY3VycmVudC5jaGlsZCkge1xuICAgICAgICAgICAgICBjdXJyZW50LmNoaWxkLnJldHVybiA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB3b3JrSW5Qcm9ncmVzcykgYnJlYWsgYTtcbiAgICAgICAgICAgIGZvciAoOyBudWxsID09PSBjdXJyZW50LnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudC5yZXR1cm4gfHwgY3VycmVudC5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQuc2libGluZy5yZXR1cm4gPSBjdXJyZW50LnJldHVybjtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICBuZXh0UHJvcHMgJj0gU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2s7XG4gICAgICB9XG4gICAgICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIG5leHRQcm9wcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgc3dpdGNoIChyZXZlYWxPcmRlcikge1xuICAgICAgICBjYXNlIFwiZm9yd2FyZHNcIjpcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIGZvciAocmV2ZWFsT3JkZXIgPSBudWxsOyBudWxsICE9PSByZW5kZXJMYW5lczsgKVxuICAgICAgICAgICAgKGN1cnJlbnQgPSByZW5kZXJMYW5lcy5hbHRlcm5hdGUpLFxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnQpICYmXG4gICAgICAgICAgICAgICAgKHJldmVhbE9yZGVyID0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcy5zaWJsaW5nKTtcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IHJldmVhbE9yZGVyO1xuICAgICAgICAgIG51bGwgPT09IHJlbmRlckxhbmVzXG4gICAgICAgICAgICA/ICgocmV2ZWFsT3JkZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpKVxuICAgICAgICAgICAgOiAoKHJldmVhbE9yZGVyID0gcmVuZGVyTGFuZXMuc2libGluZyksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcy5zaWJsaW5nID0gbnVsbCkpO1xuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZShcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgITEsXG4gICAgICAgICAgICByZXZlYWxPcmRlcixcbiAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgdGFpbE1vZGVcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmFja3dhcmRzXCI6XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSBudWxsO1xuICAgICAgICAgIHJldmVhbE9yZGVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgZm9yICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7IG51bGwgIT09IHJldmVhbE9yZGVyOyApIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSByZXZlYWxPcmRlci5hbHRlcm5hdGU7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsID09PSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZXZlYWxPcmRlcjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gcmV2ZWFsT3JkZXIuc2libGluZztcbiAgICAgICAgICAgIHJldmVhbE9yZGVyLnNpYmxpbmcgPSByZW5kZXJMYW5lcztcbiAgICAgICAgICAgIHJlbmRlckxhbmVzID0gcmV2ZWFsT3JkZXI7XG4gICAgICAgICAgICByZXZlYWxPcmRlciA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZShcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgITAsXG4gICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b2dldGhlclwiOlxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgITEsIG51bGwsIG51bGwsIHZvaWQgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXMpO1xuICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcztcbiAgICAgIGlmICgwID09PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSlcbiAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAwID09PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHJldHVybiBudWxsO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IGN1cnJlbnQuY2hpbGQpXG4gICAgICAgIHRocm93IEVycm9yKFwiUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLlwiKTtcbiAgICAgIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCkge1xuICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgIHJlbmRlckxhbmVzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgY3VycmVudC5wZW5kaW5nUHJvcHMpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlckxhbmVzO1xuICAgICAgICBmb3IgKHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzOyBudWxsICE9PSBjdXJyZW50LnNpYmxpbmc7IClcbiAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQuc2libGluZyksXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcy5zaWJsaW5nID1cbiAgICAgICAgICAgICAgY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgY3VycmVudC5wZW5kaW5nUHJvcHMpKSxcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJlbmRlckxhbmVzLnNpYmxpbmcgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykge1xuICAgICAgaWYgKDAgIT09IChjdXJyZW50LmxhbmVzICYgcmVuZGVyTGFuZXMpKSByZXR1cm4gITA7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gY3VycmVudCAmJiBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCkgPyAhMCA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZShcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcHVzaEhvc3RDb250YWluZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwdXNoUHJvdmlkZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIENhY2hlQ29udGV4dCxcbiAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcHVzaFByb3ZpZGVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykgJiZcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4O1xuICAgICAgICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gLTA7XG4gICAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IC0wO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlTm9kZSkge1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlTm9kZS5kZWh5ZHJhdGVkKVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKDAgIT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkLmNoaWxkTGFuZXMpKVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQuc2libGluZyA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSAwICE9PSAoY3VycmVudC5mbGFncyAmIDEyOCk7XG4gICAgICAgICAgc3RhdGVOb2RlID0gMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG4gICAgICAgICAgc3RhdGVOb2RlIHx8XG4gICAgICAgICAgICAocHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoc3RhdGVOb2RlID0gMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykpKTtcbiAgICAgICAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpZFN1c3BlbmRCZWZvcmUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIG51bGwgIT09IGRpZFN1c3BlbmRCZWZvcmUgJiZcbiAgICAgICAgICAgICgoZGlkU3VzcGVuZEJlZm9yZS5yZW5kZXJpbmcgPSBudWxsKSxcbiAgICAgICAgICAgIChkaWRTdXNwZW5kQmVmb3JlLnRhaWwgPSBudWxsKSxcbiAgICAgICAgICAgIChkaWRTdXNwZW5kQmVmb3JlLmxhc3RFZmZlY3QgPSBudWxsKSk7XG4gICAgICAgICAgcHVzaChcbiAgICAgICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IsXG4gICAgICAgICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHN0YXRlTm9kZSkgYnJlYWs7XG4gICAgICAgICAgZWxzZSByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gMCksXG4gICAgICAgICAgICB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcHVzaFByb3ZpZGVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDYWNoZUNvbnRleHQsXG4gICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudCAmJiBudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgIHJlbmRlckxhbmVzID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Mua2V5LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciB8fCBudWxsLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXNcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgICAgICBpZiAobnVsbCA9PT0gcmV0dXJuRmliZXIpIHRocm93IEVycm9yKFwiQ2Fubm90IHN3YXAgdGhlIHJvb3QgZmliZXIuXCIpO1xuICAgICAgICBjdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICAgIHJlbmRlckxhbmVzLmluZGV4ID0gd29ya0luUHJvZ3Jlc3MuaW5kZXg7XG4gICAgICAgIHJlbmRlckxhbmVzLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nO1xuICAgICAgICByZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICAgIHJlbmRlckxhbmVzLnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgICAgcmVuZGVyTGFuZXMuX2RlYnVnSW5mbyA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0luZm87XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gcmV0dXJuRmliZXIuY2hpbGQpXG4gICAgICAgICAgcmV0dXJuRmliZXIuY2hpbGQgPSByZW5kZXJMYW5lcztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZTaWJsaW5nID0gcmV0dXJuRmliZXIuY2hpbGQ7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHByZXZTaWJsaW5nKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCBwYXJlbnQgdG8gaGF2ZSBhIGNoaWxkLlwiKTtcbiAgICAgICAgICBmb3IgKDsgcHJldlNpYmxpbmcuc2libGluZyAhPT0gd29ya0luUHJvZ3Jlc3M7IClcbiAgICAgICAgICAgIGlmICgoKHByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuc2libGluZyksIG51bGwgPT09IHByZXZTaWJsaW5nKSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCB0byBmaW5kIHRoZSBwcmV2aW91cyBzaWJsaW5nLlwiKTtcbiAgICAgICAgICBwcmV2U2libGluZy5zaWJsaW5nID0gcmVuZGVyTGFuZXM7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlci5kZWxldGlvbnM7XG4gICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgPyAoKHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjdXJyZW50XSksIChyZXR1cm5GaWJlci5mbGFncyB8PSAxNikpXG4gICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzcy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICByZW5kZXJMYW5lcy5mbGFncyB8PSAyO1xuICAgICAgICByZXR1cm4gcmVuZGVyTGFuZXM7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudClcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzIHx8XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gY3VycmVudC50eXBlXG4gICAgICAgIClcbiAgICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gITA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykgJiZcbiAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOClcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICExKSxcbiAgICAgICAgICAgICAgYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAwICE9PSAoY3VycmVudC5mbGFncyAmIDEzMTA3MikgPyAhMCA6ICExO1xuICAgICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9ICExO1xuICAgICAgICBpZiAoKHJldHVybkZpYmVyID0gaXNIeWRyYXRpbmcpKVxuICAgICAgICAgIHdhcm5JZk5vdEh5ZHJhdGluZygpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTA0ODU3NikpO1xuICAgICAgICByZXR1cm5GaWJlciAmJlxuICAgICAgICAgICgocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5pbmRleCksXG4gICAgICAgICAgd2FybklmTm90SHlkcmF0aW5nKCksXG4gICAgICAgICAgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgdHJlZUZvcmtDb3VudCwgcmV0dXJuRmliZXIpKTtcbiAgICAgIH1cbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gMDtcbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgYTogaWYgKFxuICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAoY3VycmVudCA9IGNhbGxMYXp5SW5pdEluREVWKHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY3VycmVudClcbiAgICAgICAgICApXG4gICAgICAgICAgICBzaG91bGRDb25zdHJ1Y3QoY3VycmVudClcbiAgICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudGFnID0gMSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50ID1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50KSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgICA6ICgod29ya0luUHJvZ3Jlc3MudGFnID0gMCksXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQgPVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQpKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSkpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50KVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChwcmV2U2libGluZyA9IGN1cnJlbnQuJCR0eXBlb2YpLFxuICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSAxMTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudCA9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZUZvcndhcmRSZWYoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2U2libGluZyA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gMTQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gXCJcIjtcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgY3VycmVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgICAgICAgXCIgRGlkIHlvdSB3cmFwIGEgY29tcG9uZW50IGluIFJlYWN0LmxhenkoKSBtb3JlIHRoYW4gb25jZT9cIik7XG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN1cnJlbnQpIHx8IGN1cnJlbnQ7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZC4gUmVjZWl2ZWQgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG86IFwiICtcbiAgICAgICAgICAgICAgICBjdXJyZW50ICtcbiAgICAgICAgICAgICAgICBcIi4gTGF6eSBlbGVtZW50IHR5cGUgbXVzdCByZXNvbHZlIHRvIGEgY2xhc3Mgb3IgZnVuY3Rpb24uXCIgK1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnR5cGUpLFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICBwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICByZXR1cm5GaWJlciA9IHByZXZTaWJsaW5nLmVsZW1lbnQ7XG4gICAgICAgICAgICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIG5leHRQcm9wcyA9IG5leHRTdGF0ZS5jYWNoZTtcbiAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgbmV4dFByb3BzICE9PSBwcmV2U2libGluZy5jYWNoZSAmJlxuICAgICAgICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBbQ2FjaGVDb250ZXh0XSxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICAgICAgICAgICAgbmV4dFByb3BzID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNIeWRyYXRpb24gJiYgcHJldlNpYmxpbmcuaXNEZWh5ZHJhdGVkKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChwcmV2U2libGluZyA9IHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIGlzRGVoeWRyYXRlZDogITEsXG4gICAgICAgICAgICAgICAgICBjYWNoZTogbmV4dFN0YXRlLmNhY2hlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRQcm9wcyAhPT0gcmV0dXJuRmliZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiVGhpcyByb290IHJlY2VpdmVkIGFuIGVhcmx5IHVwZGF0ZSwgYmVmb3JlIGFueXRoaW5nIHdhcyBhYmxlIGh5ZHJhdGUuIFN3aXRjaGVkIHRoZSBlbnRpcmUgcm9vdCB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IocmV0dXJuRmliZXIpO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIHN1cHBvcnRzSHlkcmF0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICgobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIChpc0h5ZHJhdGluZyA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAoZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMSksXG4gICAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAocm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICEwKSksXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBtb3VudENoaWxkRmliZXJzKFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQ7XG5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAoY3VycmVudC5mbGFncyA9IChjdXJyZW50LmZsYWdzICYgLTMpIHwgNDA5NiksXG4gICAgICAgICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgICAgIGlmIChuZXh0UHJvcHMgPT09IHJldHVybkZpYmVyKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICAgID8gKGN1cnJlbnQgPSBnZXRSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQpXG4gICAgICAgICAgICAgICAgICA6IGlzSHlkcmF0aW5nIHx8XG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVIb2lzdGFibGVJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gZ2V0UmVzb3VyY2UoXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgc3VwcG9ydHNTaW5nbGV0b25zICYmXG4gICAgICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0gcmVxdWlyZWRDb250ZXh0KFxuICAgICAgICAgICAgICAgICAgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgICAgIChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgfHxcbiAgICAgICAgICAgICAgICAgICgocmV0dXJuRmliZXIgPSBkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzKFxuICAgICAgICAgICAgICAgICAgICBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlciAmJlxuICAgICAgICAgICAgICAgICAgICAoYnVpbGRIeWRyYXRpb25EaWZmTm9kZSh3b3JrSW5Qcm9ncmVzcywgMCkuc2VydmVyUHJvcHMgPVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyKSksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITApLFxuICAgICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID1cbiAgICAgICAgICAgICAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHByZXZTaWJsaW5nKSkpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50IHx8IGlzSHlkcmF0aW5nXG4gICAgICAgICAgICAgICAgPyByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAgICAgICAoKG5leHRQcm9wcyA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB2YWxpZGF0ZUh5ZHJhdGFibGVJbnN0YW5jZShcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChwcmV2U2libGluZyA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpLFxuICAgICAgICAgICAgICAobmV4dFN0YXRlID0gIXByZXZTaWJsaW5nKSB8fFxuICAgICAgICAgICAgICAgICgobmV4dFN0YXRlID0gY2FuSHlkcmF0ZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRTdGF0ZVxuICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5leHRTdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGRpZFN1c3BlbmRPckVycm9yREVWIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKChuZXh0UHJvcHMgPSBkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUod29ya0luUHJvZ3Jlc3MsIDApLnNlcnZlclByb3BzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzKSksXG4gICAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgICAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRTdGF0ZSkpLFxuICAgICAgICAgICAgICAgICAgICAocm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExKSxcbiAgICAgICAgICAgICAgICAgICAgKG5leHRQcm9wcyA9ICEwKSlcbiAgICAgICAgICAgICAgICAgIDogKG5leHRQcm9wcyA9ICExKSxcbiAgICAgICAgICAgICAgICAobmV4dFN0YXRlID0gIW5leHRQcm9wcykpLFxuICAgICAgICAgICAgICBuZXh0U3RhdGUgJiZcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgICAgICAgIHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcmV2U2libGluZyksXG4gICAgICAgICAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKSkpLFxuICAgICAgICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLnR5cGUpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAobmV4dFN0YXRlID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGwpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbmV4dFByb3BzLmNoaWxkcmVuKSxcbiAgICAgICAgICAgIHNob3VsZFNldFRleHRDb250ZW50KHByZXZTaWJsaW5nLCBuZXh0UHJvcHMpXG4gICAgICAgICAgICAgID8gKHJldHVybkZpYmVyID0gbnVsbClcbiAgICAgICAgICAgICAgOiBudWxsICE9PSBuZXh0U3RhdGUgJiZcbiAgICAgICAgICAgICAgICBzaG91bGRTZXRUZXh0Q29udGVudChwcmV2U2libGluZywgbmV4dFN0YXRlKSAmJlxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAzMiksXG4gICAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgICgocHJldlNpYmxpbmcgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgICAgICAgICA/IChIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHByZXZTaWJsaW5nKVxuICAgICAgICAgICAgICAgIDogKEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlMiA9IHByZXZTaWJsaW5nKSksXG4gICAgICAgICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgICAgKChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAgIChjdXJyZW50ID0gdmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlKGN1cnJlbnQsIHJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSAhcmVuZGVyTGFuZXMpIHx8XG4gICAgICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSAhMCkpXG4gICAgICAgICAgICAgICAgICA6IChyZXR1cm5GaWJlciA9ICExKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSAhcmV0dXJuRmliZXIpKSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgICAgICAoY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpKSksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwdXNoSG9zdENvbnRhaW5lcihcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA6IHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4KSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIuZWZmZWN0RHVyYXRpb24gPSAtMCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gLTApLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgICAgIChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAobmV4dFByb3BzID0gcHJldlNpYmxpbmcudmFsdWUpLFxuICAgICAgICAgICAgXCJ2YWx1ZVwiIGluIHByZXZTaWJsaW5nIHx8XG4gICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyIHx8XG4gICAgICAgICAgICAgICgoaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaGUgYHZhbHVlYCBwcm9wIGlzIHJlcXVpcmVkIGZvciB0aGUgYDxDb250ZXh0LlByb3ZpZGVyPmAuIERpZCB5b3UgbWlzc3BlbGwgaXQgb3IgZm9yZ2V0IHRvIHBhc3MgaXQ/XCJcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIHJldHVybkZpYmVyLCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBwcmV2U2libGluZy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkEgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCB0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIHRoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSBpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LlwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAocHJldlNpYmxpbmcgPSByZWFkQ29udGV4dChwcmV2U2libGluZykpLFxuICAgICAgICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gY2FsbENvbXBvbmVudEluREVWKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEpLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW9Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHJldHVybiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVhZENvbnRleHQoQ2FjaGVDb250ZXh0KSksXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gKChwcmV2U2libGluZyA9IHBlZWtDYWNoZUZyb21Qb29sKCkpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHByZXZTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3NSb290KSxcbiAgICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVDYWNoZSgpKSxcbiAgICAgICAgICAgICAgICAgIChwcmV2U2libGluZy5wb29sZWRDYWNoZSA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgICByZXRhaW5DYWNoZShuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgIChwcmV2U2libGluZy5wb29sZWRDYWNoZUxhbmVzIHw9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAgIChwcmV2U2libGluZyA9IG5leHRQcm9wcykpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgcGFyZW50OiByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIGNhY2hlOiBwcmV2U2libGluZ1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHByZXZTaWJsaW5nKSlcbiAgICAgICAgICAgICAgOiAoMCAhPT0gKGN1cnJlbnQubGFuZXMgJiByZW5kZXJMYW5lcykgJiZcbiAgICAgICAgICAgICAgICAgIChjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbnVsbCwgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpKSxcbiAgICAgICAgICAgICAgICAocHJldlNpYmxpbmcgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgICAgICBwcmV2U2libGluZy5wYXJlbnQgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICA/ICgocHJldlNpYmxpbmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcHJldlNpYmxpbmcpLFxuICAgICAgICAgICAgICAgICAgICAwID09PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHJldHVybkZpYmVyKSlcbiAgICAgICAgICAgICAgICAgIDogKChyZXR1cm5GaWJlciA9IG5leHRQcm9wcy5jYWNoZSksXG4gICAgICAgICAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyICE9PSBwcmV2U2libGluZy5jYWNoZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBbQ2FjaGVDb250ZXh0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICAgICAgICApKSksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgdGhyb3cgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnICtcbiAgICAgICAgICBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpIHtcbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbDtcbiAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFByb3ZpZGVyKHByb3ZpZGVyRmliZXIsIGNvbnRleHQsIG5leHRWYWx1ZSkge1xuICAgICAgaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgPyAocHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlLCBwcm92aWRlckZpYmVyKSxcbiAgICAgICAgICAoY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dFZhbHVlKSxcbiAgICAgICAgICBwdXNoKHJlbmRlcmVyQ3Vyc29yREVWLCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIHZvaWQgMCAhPT0gY29udGV4dC5fY3VycmVudFJlbmRlcmVyICYmXG4gICAgICAgICAgICBudWxsICE9PSBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgJiZcbiAgICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbCkpXG4gICAgICAgIDogKHB1c2godmFsdWVDdXJzb3IsIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dFZhbHVlKSxcbiAgICAgICAgICBwdXNoKHJlbmRlcmVyMkN1cnNvckRFViwgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiwgcHJvdmlkZXJGaWJlciksXG4gICAgICAgICAgdm9pZCAwICE9PSBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICYmXG4gICAgICAgICAgICBudWxsICE9PSBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICYmXG4gICAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSByZW5kZXJlclNpZ2lsICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkRldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSBzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BQcm92aWRlcihjb250ZXh0LCBwcm92aWRlckZpYmVyKSB7XG4gICAgICB2YXIgY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcbiAgICAgIGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgID8gKChjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBjdXJyZW50VmFsdWUpLFxuICAgICAgICAgIChjdXJyZW50VmFsdWUgPSByZW5kZXJlckN1cnNvckRFVi5jdXJyZW50KSxcbiAgICAgICAgICBwb3AocmVuZGVyZXJDdXJzb3JERVYsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBjdXJyZW50VmFsdWUpKVxuICAgICAgICA6ICgoY29udGV4dC5fY3VycmVudFZhbHVlMiA9IGN1cnJlbnRWYWx1ZSksXG4gICAgICAgICAgKGN1cnJlbnRWYWx1ZSA9IHJlbmRlcmVyMkN1cnNvckRFVi5jdXJyZW50KSxcbiAgICAgICAgICBwb3AocmVuZGVyZXIyQ3Vyc29yREVWLCBwcm92aWRlckZpYmVyKSxcbiAgICAgICAgICAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IGN1cnJlbnRWYWx1ZSkpO1xuICAgICAgcG9wKHZhbHVlQ3Vyc29yLCBwcm92aWRlckZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChcbiAgICAgIHBhcmVudCxcbiAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgcHJvcGFnYXRpb25Sb290XG4gICAgKSB7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gcGFyZW50OyApIHtcbiAgICAgICAgdmFyIGFsdGVybmF0ZSA9IHBhcmVudC5hbHRlcm5hdGU7XG4gICAgICAgIChwYXJlbnQuY2hpbGRMYW5lcyAmIHJlbmRlckxhbmVzKSAhPT0gcmVuZGVyTGFuZXNcbiAgICAgICAgICA/ICgocGFyZW50LmNoaWxkTGFuZXMgfD0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSByZW5kZXJMYW5lcykpXG4gICAgICAgICAgOiBudWxsICE9PSBhbHRlcm5hdGUgJiZcbiAgICAgICAgICAgIChhbHRlcm5hdGUuY2hpbGRMYW5lcyAmIHJlbmRlckxhbmVzKSAhPT0gcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHByb3BhZ2F0aW9uUm9vdCkgYnJlYWs7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG4gICAgICBwYXJlbnQgIT09IHByb3BhZ2F0aW9uUm9vdCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gZmluZCB0aGUgcHJvcGFnYXRpb24gcm9vdCB3aGVuIHNjaGVkdWxpbmcgY29udGV4dCB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjb250ZXh0cyxcbiAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlXG4gICAgKSB7XG4gICAgICB2YXIgZmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgIG51bGwgIT09IGZpYmVyICYmIChmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gZmliZXI7ICkge1xuICAgICAgICB2YXIgbGlzdCA9IGZpYmVyLmRlcGVuZGVuY2llcztcbiAgICAgICAgaWYgKG51bGwgIT09IGxpc3QpIHtcbiAgICAgICAgICB2YXIgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICAgICAgbGlzdCA9IGxpc3QuZmlyc3RDb250ZXh0O1xuICAgICAgICAgIGE6IGZvciAoOyBudWxsICE9PSBsaXN0OyApIHtcbiAgICAgICAgICAgIHZhciBkZXBlbmRlbmN5ID0gbGlzdDtcbiAgICAgICAgICAgIGxpc3QgPSBmaWJlcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGV4dHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5LmNvbnRleHQgPT09IGNvbnRleHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5sYW5lcyB8PSByZW5kZXJMYW5lcztcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5ID0gbGlzdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gZGVwZW5kZW5jeSAmJiAoZGVwZW5kZW5jeS5sYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChcbiAgICAgICAgICAgICAgICAgIGxpc3QucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlIHx8IChuZXh0RmliZXIgPSBudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0ID0gZGVwZW5kZW5jeS5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgxOCA9PT0gZmliZXIudGFnKSB7XG4gICAgICAgICAgbmV4dEZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgICAgICAgIGlmIChudWxsID09PSBuZXh0RmliZXIpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJXZSBqdXN0IGNhbWUgZnJvbSBhIHBhcmVudCBzbyB3ZSBtdXN0IGhhdmUgaGFkIGEgcGFyZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIG5leHRGaWJlci5sYW5lcyB8PSByZW5kZXJMYW5lcztcbiAgICAgICAgICBsaXN0ID0gbmV4dEZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBudWxsICE9PSBsaXN0ICYmIChsaXN0LmxhbmVzIHw9IHJlbmRlckxhbmVzKTtcbiAgICAgICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKFxuICAgICAgICAgICAgbmV4dEZpYmVyLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICk7XG4gICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuICAgICAgICBpZiAobnVsbCAhPT0gbmV4dEZpYmVyKSBuZXh0RmliZXIucmV0dXJuID0gZmliZXI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKG5leHRGaWJlciA9IGZpYmVyOyBudWxsICE9PSBuZXh0RmliZXI7ICkge1xuICAgICAgICAgICAgaWYgKG5leHRGaWJlciA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWJlciA9IG5leHRGaWJlci5zaWJsaW5nO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGZpYmVyKSB7XG4gICAgICAgICAgICAgIGZpYmVyLnJldHVybiA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICAgICAgICAgIG5leHRGaWJlciA9IGZpYmVyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRGaWJlciA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICBmaWJlciA9IG5leHRGaWJlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICByZW5kZXJMYW5lcyxcbiAgICAgIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZVxuICAgICkge1xuICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgcGFyZW50ID0gd29ya0luUHJvZ3Jlc3MsIGlzSW5zaWRlUHJvcGFnYXRpb25CYWlsb3V0ID0gITE7XG4gICAgICAgIG51bGwgIT09IHBhcmVudDtcblxuICAgICAgKSB7XG4gICAgICAgIGlmICghaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQpXG4gICAgICAgICAgaWYgKDAgIT09IChwYXJlbnQuZmxhZ3MgJiA1MjQyODgpKSBpc0luc2lkZVByb3BhZ2F0aW9uQmFpbG91dCA9ICEwO1xuICAgICAgICAgIGVsc2UgaWYgKDAgIT09IChwYXJlbnQuZmxhZ3MgJiAyNjIxNDQpKSBicmVhaztcbiAgICAgICAgaWYgKDEwID09PSBwYXJlbnQudGFnKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50UGFyZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gcGFyZW50LnR5cGU7XG4gICAgICAgICAgICBvYmplY3RJcyhwYXJlbnQucGVuZGluZ1Byb3BzLnZhbHVlLCBjdXJyZW50UGFyZW50LnZhbHVlKSB8fFxuICAgICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudFxuICAgICAgICAgICAgICAgID8gY3VycmVudC5wdXNoKGNvbnRleHQpXG4gICAgICAgICAgICAgICAgOiAoY3VycmVudCA9IFtjb250ZXh0XSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQgPT09IGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IuY3VycmVudCkge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50UGFyZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQubWVtb2l6ZWRTdGF0ZS5tZW1vaXplZFN0YXRlICE9PVxuICAgICAgICAgICAgcGFyZW50Lm1lbW9pemVkU3RhdGUubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyBjdXJyZW50LnB1c2goSG9zdFRyYW5zaXRpb25Db250ZXh0KVxuICAgICAgICAgICAgICA6IChjdXJyZW50ID0gW0hvc3RUcmFuc2l0aW9uQ29udGV4dF0pKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgICAgfVxuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZVxuICAgICAgICApO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjYyMTQ0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudERlcGVuZGVuY2llcykge1xuICAgICAgZm9yIChcbiAgICAgICAgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0O1xuICAgICAgICBudWxsICE9PSBjdXJyZW50RGVwZW5kZW5jaWVzO1xuXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjdXJyZW50RGVwZW5kZW5jaWVzLmNvbnRleHQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhb2JqZWN0SXMoXG4gICAgICAgICAgICBpc1ByaW1hcnlSZW5kZXJlciA/IGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA6IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsXG4gICAgICAgICAgICBjdXJyZW50RGVwZW5kZW5jaWVzLm1lbW9pemVkVmFsdWVcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzO1xuICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MgJiYgKHdvcmtJblByb2dyZXNzLmZpcnN0Q29udGV4dCA9IG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0KSB7XG4gICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiBJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0Rm9yQ29uc3VtZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIsIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKGNvbnN1bWVyLCBjb250ZXh0KSB7XG4gICAgICBudWxsID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciAmJiBwcmVwYXJlVG9SZWFkQ29udGV4dChjb25zdW1lcik7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHRGb3JDb25zdW1lcihjb25zdW1lciwgY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDb250ZXh0Rm9yQ29uc3VtZXIoY29uc3VtZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgID8gY29udGV4dC5fY3VycmVudFZhbHVlXG4gICAgICAgIDogY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgIGNvbnRleHQgPSB7IGNvbnRleHQ6IGNvbnRleHQsIG1lbW9pemVkVmFsdWU6IHZhbHVlLCBuZXh0OiBudWxsIH07XG4gICAgICBpZiAobnVsbCA9PT0gbGFzdENvbnRleHREZXBlbmRlbmN5KSB7XG4gICAgICAgIGlmIChudWxsID09PSBjb25zdW1lcilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICAgICApO1xuICAgICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjb250ZXh0O1xuICAgICAgICBjb25zdW1lci5kZXBlbmRlbmNpZXMgPSB7XG4gICAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgICAgZmlyc3RDb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgIF9kZWJ1Z1RoZW5hYmxlU3RhdGU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3VtZXIuZmxhZ3MgfD0gNTI0Mjg4O1xuICAgICAgfSBlbHNlIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeS5uZXh0ID0gY29udGV4dDtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250cm9sbGVyOiBuZXcgQWJvcnRDb250cm9sbGVyTG9jYWwoKSxcbiAgICAgICAgZGF0YTogbmV3IE1hcCgpLFxuICAgICAgICByZWZDb3VudDogMFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0YWluQ2FjaGUoY2FjaGUpIHtcbiAgICAgIGNhY2hlLmNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiQSBjYWNoZSBpbnN0YW5jZSB3YXMgcmV0YWluZWQgYWZ0ZXIgaXQgd2FzIGFscmVhZHkgZnJlZWQuIFRoaXMgbGlrZWx5IGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgY2FjaGUucmVmQ291bnQrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsZWFzZUNhY2hlKGNhY2hlKSB7XG4gICAgICBjYWNoZS5yZWZDb3VudC0tO1xuICAgICAgMCA+IGNhY2hlLnJlZkNvdW50ICYmXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIkEgY2FjaGUgaW5zdGFuY2Ugd2FzIHJlbGVhc2VkIGFmdGVyIGl0IHdhcyBhbHJlYWR5IGZyZWVkLiBUaGlzIGxpa2VseSBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIDAgPT09IGNhY2hlLnJlZkNvdW50ICYmXG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2skMShOb3JtYWxQcmlvcml0eSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhY2hlLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZWtDYWNoZUZyb21Qb29sKCkge1xuICAgICAgdmFyIGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlciA9IHJlc3VtZWRDYWNoZS5jdXJyZW50O1xuICAgICAgcmV0dXJuIG51bGwgIT09IGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlclxuICAgICAgICA/IGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlclxuICAgICAgICA6IHdvcmtJblByb2dyZXNzUm9vdC5wb29sZWRDYWNoZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRyYW5zaXRpb24ob2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MsIHByZXZDYWNoZVBvb2wpIHtcbiAgICAgIG51bGwgPT09IHByZXZDYWNoZVBvb2xcbiAgICAgICAgPyBwdXNoKHJlc3VtZWRDYWNoZSwgcmVzdW1lZENhY2hlLmN1cnJlbnQsIG9mZnNjcmVlbldvcmtJblByb2dyZXNzKVxuICAgICAgICA6IHB1c2gocmVzdW1lZENhY2hlLCBwcmV2Q2FjaGVQb29sLnBvb2wsIG9mZnNjcmVlbldvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3VzcGVuZGVkQ2FjaGUoKSB7XG4gICAgICB2YXIgY2FjaGVGcm9tUG9vbCA9IHBlZWtDYWNoZUZyb21Qb29sKCk7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gY2FjaGVGcm9tUG9vbFxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiB7XG4gICAgICAgICAgICBwYXJlbnQ6IGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgICAgICAgID8gQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWVcbiAgICAgICAgICAgICAgOiBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsXG4gICAgICAgICAgICBwb29sOiBjYWNoZUZyb21Qb29sXG4gICAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZG9lc1JlcXVpcmVDbG9uZShjdXJyZW50LCBjb21wbGV0ZWRXb3JrKSB7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBjdXJyZW50LmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkKSByZXR1cm4gITE7XG4gICAgICBpZiAoMCAhPT0gKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiAxNikpIHJldHVybiAhMDtcbiAgICAgIGZvciAoY3VycmVudCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7IG51bGwgIT09IGN1cnJlbnQ7ICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMzg3OCkgfHxcbiAgICAgICAgICAwICE9PSAoY3VycmVudC5zdWJ0cmVlRmxhZ3MgJiAxMzg3OClcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4oXG4gICAgICBwYXJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSxcbiAgICAgIGlzSGlkZGVuXG4gICAgKSB7XG4gICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbilcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICBudWxsICE9PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGU7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgNSA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnRhZyB8fFxuICAgICAgICAgICAgNiA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnRhZ1xuICAgICAgICAgIClcbiAgICAgICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgNCA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnRhZyB8fFxuICAgICAgICAgICAgICAoc3VwcG9ydHNTaW5nbGV0b25zICYmIDI3ID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUudGFnKVxuICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLmNoaWxkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUuY2hpbGQucmV0dXJuID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlO1xuICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLmNoaWxkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUgPT09IHdvcmtJblByb2dyZXNzKSBicmVhaztcbiAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBudWxsID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUucmV0dXJuIHx8XG4gICAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSA9IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5zaWJsaW5nLnJldHVybiA9IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5yZXR1cm47XG4gICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpXG4gICAgICAgIGZvciAodmFyIF9ub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7IG51bGwgIT09IF9ub2RlOyApIHtcbiAgICAgICAgICBpZiAoNSA9PT0gX25vZGUudGFnKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBfbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiZcbiAgICAgICAgICAgICAgaXNIaWRkZW4gJiZcbiAgICAgICAgICAgICAgKGluc3RhbmNlID0gY2xvbmVIaWRkZW5JbnN0YW5jZShcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBfbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIF9ub2RlLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICg2ID09PSBfbm9kZS50YWcpXG4gICAgICAgICAgICAoaW5zdGFuY2UgPSBfbm9kZS5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiZcbiAgICAgICAgICAgICAgICBpc0hpZGRlbiAmJlxuICAgICAgICAgICAgICAgIChpbnN0YW5jZSA9IGNsb25lSGlkZGVuVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICBfbm9kZS5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICBlbHNlIGlmICg0ICE9PSBfbm9kZS50YWcpXG4gICAgICAgICAgICBpZiAoMjIgPT09IF9ub2RlLnRhZyAmJiBudWxsICE9PSBfbm9kZS5tZW1vaXplZFN0YXRlKVxuICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBfbm9kZS5jaGlsZCksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5zdGFuY2UgJiYgKGluc3RhbmNlLnJldHVybiA9IF9ub2RlKSxcbiAgICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIF9ub2RlLCAhMCwgITApO1xuICAgICAgICAgICAgZWxzZSBpZiAobnVsbCAhPT0gX25vZGUuY2hpbGQpIHtcbiAgICAgICAgICAgICAgX25vZGUuY2hpbGQucmV0dXJuID0gX25vZGU7XG4gICAgICAgICAgICAgIF9ub2RlID0gX25vZGUuY2hpbGQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChfbm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIGJyZWFrO1xuICAgICAgICAgIGZvciAoOyBudWxsID09PSBfbm9kZS5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBfbm9kZS5yZXR1cm4gfHwgX25vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgX25vZGUgPSBfbm9kZS5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIF9ub2RlLnNpYmxpbmcucmV0dXJuID0gX25vZGUucmV0dXJuO1xuICAgICAgICAgIF9ub2RlID0gX25vZGUuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKFxuICAgICAgY29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSxcbiAgICAgIGlzSGlkZGVuXG4gICAgKSB7XG4gICAgICBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSlcbiAgICAgICAgZm9yICh2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSBub2RlOyApIHtcbiAgICAgICAgICBpZiAoNSA9PT0gbm9kZS50YWcpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmXG4gICAgICAgICAgICAgIGlzSGlkZGVuICYmXG4gICAgICAgICAgICAgIChpbnN0YW5jZSA9IGNsb25lSGlkZGVuSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIG5vZGUubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgaW5zdGFuY2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoNiA9PT0gbm9kZS50YWcpXG4gICAgICAgICAgICAoaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJlxuICAgICAgICAgICAgICAgIGlzSGlkZGVuICYmXG4gICAgICAgICAgICAgICAgKGluc3RhbmNlID0gY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIG5vZGUubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIGluc3RhbmNlKTtcbiAgICAgICAgICBlbHNlIGlmICg0ICE9PSBub2RlLnRhZylcbiAgICAgICAgICAgIGlmICgyMiA9PT0gbm9kZS50YWcgJiYgbnVsbCAhPT0gbm9kZS5tZW1vaXplZFN0YXRlKVxuICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBub2RlLmNoaWxkKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBpbnN0YW5jZSAmJiAoaW5zdGFuY2UucmV0dXJuID0gbm9kZSksXG4gICAgICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihcbiAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5vZGUubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICBcIm1hbnVhbFwiID09PSBub2RlLm1lbW9pemVkUHJvcHMubW9kZVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG51bGwgIT09IG5vZGUuY2hpbGQpIHtcbiAgICAgICAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSBicmVhaztcbiAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gbm9kZS5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBub2RlLnJldHVybiB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHJldHVybjtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlSG9zdENvbnRhaW5lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UgJiYgZG9lc1JlcXVpcmVDbG9uZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGN1cnJlbnQuY29udGFpbmVySW5mbyxcbiAgICAgICAgICBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KCk7XG4gICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzLCAhMSwgITEpO1xuICAgICAgICBjdXJyZW50LnBlbmRpbmdDaGlsZHJlbiA9IG5ld0NoaWxkU2V0O1xuICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbihjb250YWluZXIsIG5ld0NoaWxkU2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMpIHtcbiAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKVxuICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IG5ld1Byb3BzICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgICAgICB2YXIgY3VycmVudEluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGUsXG4gICAgICAgICAgX29sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKGN1cnJlbnQgPSBkb2VzUmVxdWlyZUNsb25lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSkgfHxcbiAgICAgICAgICBfb2xkUHJvcHMgIT09IG5ld1Byb3BzXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgIF9vbGRQcm9wcyA9IGNsb25lSW5zdGFuY2UoXG4gICAgICAgICAgICBjdXJyZW50SW5zdGFuY2UsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgX29sZFByb3BzLFxuICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAhY3VycmVudCxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICAgIF9vbGRQcm9wcyA9PT0gY3VycmVudEluc3RhbmNlXG4gICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2UpXG4gICAgICAgICAgICA6IChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihcbiAgICAgICAgICAgICAgICBfb2xkUHJvcHMsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50SG9zdENvbnRleHRcbiAgICAgICAgICAgICAgKSAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9vbGRQcm9wcyksXG4gICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICAgICA/IGFwcGVuZEFsbENoaWxkcmVuKF9vbGRQcm9wcywgd29ya0luUHJvZ3Jlc3MsICExLCAhMSlcbiAgICAgICAgICAgICAgICA6IG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgICAgfSBlbHNlIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCB0eXBlLCBwcm9wcykge1xuICAgICAgaWYgKG1heVN1c3BlbmRDb21taXQodHlwZSwgcHJvcHMpKSB7XG4gICAgICAgIGlmICgoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE2Nzc3MjE2KSwgIXByZWxvYWRJbnN0YW5jZSh0eXBlLCBwcm9wcykpKVxuICAgICAgICAgIGlmIChzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuKCkpIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTI7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAoKHN1c3BlbmRlZFRoZW5hYmxlID0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlKSxcbiAgICAgICAgICAgICAgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uKVxuICAgICAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTY3NzcyMTc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgcmVzb3VyY2UpIHtcbiAgICAgIGlmIChtYXlSZXNvdXJjZVN1c3BlbmRDb21taXQocmVzb3VyY2UpKSB7XG4gICAgICAgIGlmICgoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE2Nzc3MjE2KSwgIXByZWxvYWRSZXNvdXJjZShyZXNvdXJjZSkpKVxuICAgICAgICAgIGlmIChzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuKCkpIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTI7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAoKHN1c3BlbmRlZFRoZW5hYmxlID0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlKSxcbiAgICAgICAgICAgICAgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uKVxuICAgICAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTY3NzcyMTc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIHJldHJ5UXVldWUpIHtcbiAgICAgIG51bGwgIT09IHJldHJ5UXVldWUgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxNjM4NCAmJlxuICAgICAgICAoKHJldHJ5UXVldWUgPVxuICAgICAgICAgIDIyICE9PSB3b3JrSW5Qcm9ncmVzcy50YWcgPyBjbGFpbU5leHRSZXRyeUxhbmUoKSA6IDUzNjg3MDkxMiksXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyB8PSByZXRyeVF1ZXVlKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyB8PSByZXRyeVF1ZXVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSB7XG4gICAgICBpZiAoIWlzSHlkcmF0aW5nKVxuICAgICAgICBzd2l0Y2ggKHJlbmRlclN0YXRlLnRhaWxNb2RlKSB7XG4gICAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICAgICAgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgICAgIGZvciAodmFyIGxhc3RUYWlsTm9kZSA9IG51bGw7IG51bGwgIT09IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjazsgKVxuICAgICAgICAgICAgICBudWxsICE9PSBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2suYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgKGxhc3RUYWlsTm9kZSA9IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayksXG4gICAgICAgICAgICAgICAgKGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayA9IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjay5zaWJsaW5nKTtcbiAgICAgICAgICAgIG51bGwgPT09IGxhc3RUYWlsTm9kZVxuICAgICAgICAgICAgICA/IChyZW5kZXJTdGF0ZS50YWlsID0gbnVsbClcbiAgICAgICAgICAgICAgOiAobGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjb2xsYXBzZWRcIjpcbiAgICAgICAgICAgIGxhc3RUYWlsTm9kZSA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGFzdFRhaWxOb2RlID0gbnVsbDsgbnVsbCAhPT0gbGFzdFRhaWxOb2RlOyApXG4gICAgICAgICAgICAgIG51bGwgIT09IGxhc3RUYWlsTm9kZS5hbHRlcm5hdGUgJiYgKF9sYXN0VGFpbE5vZGUgPSBsYXN0VGFpbE5vZGUpLFxuICAgICAgICAgICAgICAgIChsYXN0VGFpbE5vZGUgPSBsYXN0VGFpbE5vZGUuc2libGluZyk7XG4gICAgICAgICAgICBudWxsID09PSBfbGFzdFRhaWxOb2RlXG4gICAgICAgICAgICAgID8gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrIHx8IG51bGwgPT09IHJlbmRlclN0YXRlLnRhaWxcbiAgICAgICAgICAgICAgICA/IChyZW5kZXJTdGF0ZS50YWlsID0gbnVsbClcbiAgICAgICAgICAgICAgICA6IChyZW5kZXJTdGF0ZS50YWlsLnNpYmxpbmcgPSBudWxsKVxuICAgICAgICAgICAgICA6IChfbGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBidWJibGVQcm9wZXJ0aWVzKGNvbXBsZXRlZFdvcmspIHtcbiAgICAgIHZhciBkaWRCYWlsb3V0ID1cbiAgICAgICAgICBudWxsICE9PSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZSAmJlxuICAgICAgICAgIGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlLmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkLFxuICAgICAgICBuZXdDaGlsZExhbmVzID0gMCxcbiAgICAgICAgc3VidHJlZUZsYWdzID0gMDtcbiAgICAgIGlmIChkaWRCYWlsb3V0KVxuICAgICAgICBpZiAoKGNvbXBsZXRlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgdmFyIF90cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uLFxuICAgICAgICAgICAgICBfY2hpbGQyID0gY29tcGxldGVkV29yay5jaGlsZDtcbiAgICAgICAgICAgIG51bGwgIT09IF9jaGlsZDI7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICAobmV3Q2hpbGRMYW5lcyB8PSBfY2hpbGQyLmxhbmVzIHwgX2NoaWxkMi5jaGlsZExhbmVzKSxcbiAgICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLnN1YnRyZWVGbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLmZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24gKz0gX2NoaWxkMi50cmVlQmFzZUR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgKF9jaGlsZDIgPSBfY2hpbGQyLnNpYmxpbmcpO1xuICAgICAgICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IF90cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuICAgICAgICAgICAgbnVsbCAhPT0gX3RyZWVCYXNlRHVyYXRpb247XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICAobmV3Q2hpbGRMYW5lcyB8PVxuICAgICAgICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbi5sYW5lcyB8IF90cmVlQmFzZUR1cmF0aW9uLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF90cmVlQmFzZUR1cmF0aW9uLnN1YnRyZWVGbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfdHJlZUJhc2VEdXJhdGlvbi5mbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uLnJldHVybiA9IGNvbXBsZXRlZFdvcmspLFxuICAgICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbi5zaWJsaW5nKTtcbiAgICAgIGVsc2UgaWYgKChjb21wbGV0ZWRXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgIF90cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgX2NoaWxkMiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgICAgZm9yICh2YXIgY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkOyBudWxsICE9PSBjaGlsZDsgKVxuICAgICAgICAgIChuZXdDaGlsZExhbmVzIHw9IGNoaWxkLmxhbmVzIHwgY2hpbGQuY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IGNoaWxkLnN1YnRyZWVGbGFncyksXG4gICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IGNoaWxkLmZsYWdzKSxcbiAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbiksXG4gICAgICAgICAgICAoX2NoaWxkMiArPSBjaGlsZC50cmVlQmFzZUR1cmF0aW9uKSxcbiAgICAgICAgICAgIChjaGlsZCA9IGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uID0gX3RyZWVCYXNlRHVyYXRpb247XG4gICAgICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IF9jaGlsZDI7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG4gICAgICAgICAgbnVsbCAhPT0gX3RyZWVCYXNlRHVyYXRpb247XG5cbiAgICAgICAgKVxuICAgICAgICAgIChuZXdDaGlsZExhbmVzIHw9XG4gICAgICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbi5sYW5lcyB8IF90cmVlQmFzZUR1cmF0aW9uLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfdHJlZUJhc2VEdXJhdGlvbi5zdWJ0cmVlRmxhZ3MpLFxuICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfdHJlZUJhc2VEdXJhdGlvbi5mbGFncyksXG4gICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24ucmV0dXJuID0gY29tcGxldGVkV29yayksXG4gICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbi5zaWJsaW5nKTtcbiAgICAgIGNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzIHw9IHN1YnRyZWVGbGFncztcbiAgICAgIGNvbXBsZXRlZFdvcmsuY2hpbGRMYW5lcyA9IG5ld0NoaWxkTGFuZXM7XG4gICAgICByZXR1cm4gZGlkQmFpbG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIChuZXdQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZSAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4KTtcbiAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZW5kZXJMYW5lcy5wZW5kaW5nQ29udGV4dCAmJlxuICAgICAgICAgICAgKChyZW5kZXJMYW5lcy5jb250ZXh0ID0gcmVuZGVyTGFuZXMucGVuZGluZ0NvbnRleHQpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzLnBlbmRpbmdDb250ZXh0ID0gbnVsbCkpO1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50IHx8IG51bGwgPT09IGN1cnJlbnQuY2hpbGQpXG4gICAgICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgPyAoZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncygpLCBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSlcbiAgICAgICAgICAgICAgOiBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgICAgKGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NikpIHx8XG4gICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBoeWRyYXRpb25FcnJvcnMgJiZcbiAgICAgICAgICAgICAgICAgIChxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGh5ZHJhdGlvbkVycm9ycyksXG4gICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uRXJyb3JzID0gbnVsbCkpKTtcbiAgICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICAgIHZhciBuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICA/IChtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2VcbiAgICAgICAgICAgICAgICAgID8gKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQoXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlXG4gICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICA6IChidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgICA6IG5leHRSZXNvdXJjZVxuICAgICAgICAgICAgICAgID8gbmV4dFJlc291cmNlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgICAgID8gKG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZVxuICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgOiAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTY3NzcyMTcpKVxuICAgICAgICAgICAgICAgIDogKHN1cHBvcnRzTXV0YXRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IG5ld1Byb3BzICYmXG4gICAgICAgICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgOiB1cGRhdGVIb3N0Q29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgIHByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZChcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb25cbiAgICAgICAgICAgICAgICA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgOiB1cGRhdGVIb3N0Q29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgID8gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3VycmVudClcbiAgICAgICAgICAgICAgICA6ICgoY3VycmVudCA9IHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCBuZXdQcm9wcyk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA/IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpXG4gICAgICAgICAgICAgIDogKChuZXh0UmVzb3VyY2UgPSByZXF1aXJlZENvbnRleHQoXG4gICAgICAgICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKG5leHRSZXNvdXJjZSA9IGNyZWF0ZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5leHRSZXNvdXJjZSwgd29ya0luUHJvZ3Jlc3MsICExLCAhMSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5leHRSZXNvdXJjZSksXG4gICAgICAgICAgICAgICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgICAgICkgJiYgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgaWYgKGN1cnJlbnQgJiYgbnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICAgICBzdXBwb3J0c011dGF0aW9uXG4gICAgICAgICAgICAgICAgPyByZW5kZXJMYW5lcyAhPT0gbmV3UHJvcHMgJiYgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgICA6IHN1cHBvcnRzUGVyc2lzdGVuY2UgJiZcbiAgICAgICAgICAgICAgICAgIChyZW5kZXJMYW5lcyAhPT0gbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgPyAoKGN1cnJlbnQgPSByZXF1aXJlZENvbnRleHQoXG4gICAgICAgICAgICAgICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSlcbiAgICAgICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGUpKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG5ld1Byb3BzICYmXG4gICAgICAgICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgICAgICAgICByZW5kZXJMYW5lcyA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICBpZiAocG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgIGlmICghc3VwcG9ydHNIeWRyYXRpb24pXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSAhZGlkU3VzcGVuZE9yRXJyb3JERVY7XG4gICAgICAgICAgICAgIG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSByZXR1cm5GaWJlcilcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoKG5leHRSZXNvdXJjZSA9IGRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFJlc291cmNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVpbGRIeWRyYXRpb25EaWZmTm9kZSh3b3JrSW5Qcm9ncmVzcywgMCkuc2VydmVyUHJvcHMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAobmV3UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzKSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICgobmV4dFJlc291cmNlID0gZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFJlc291cmNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKS5zZXJ2ZXJQcm9wcyA9IG5leHRSZXNvdXJjZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaHlkcmF0ZVRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICkgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuZGVoeWRyYXRlZClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBuZXdQcm9wcyAmJiBudWxsICE9PSBuZXdQcm9wcy5kZWh5ZHJhdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0UmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJBIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50IHdhcyBjb21wbGV0ZWQgd2l0aG91dCBhIGh5ZHJhdGVkIG5vZGUuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbilcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UgPyBuZXh0UmVzb3VyY2UuZGVoeWRyYXRlZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0UmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UobmV4dFJlc291cmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgKChuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT1cbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UudHJlZUJhc2VEdXJhdGlvbikpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzKCksXG4gICAgICAgICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCksXG4gICAgICAgICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpICYmXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICAoKG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFJlc291cmNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZS50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9ICExO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG51bGwgIT09IGh5ZHJhdGlvbkVycm9ycyAmJlxuICAgICAgICAgICAgICAgIChxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGh5ZHJhdGlvbkVycm9ycyksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpKSxcbiAgICAgICAgICAgICAgICAobmV4dFJlc291cmNlID0gITApO1xuICAgICAgICAgICAgaWYgKCFuZXh0UmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMjU2KVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLCB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgaWYgKDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCkpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IG51bGwgIT09IG5ld1Byb3BzO1xuICAgICAgICAgIGN1cnJlbnQgPSBudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgKChuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgIChuZXh0UmVzb3VyY2UgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAgICAgKG5leHRSZXNvdXJjZSA9IG5ld1Byb3BzLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBuZXdQcm9wcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgICAgIHJldHVybkZpYmVyICE9PSBuZXh0UmVzb3VyY2UgJiYgKG5ld1Byb3BzLmZsYWdzIHw9IDIwNDgpKTtcbiAgICAgICAgICByZW5kZXJMYW5lcyAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZC5mbGFncyB8PSA4MTkyKTtcbiAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSk7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgKChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb24pKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBwcmVwYXJlUG9ydGFsTW91bnQod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pLFxuICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcG9wUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5leHRSZXNvdXJjZSlcbiAgICAgICAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgICBuZXdQcm9wcyA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCk7XG4gICAgICAgICAgcmV0dXJuRmliZXIgPSBuZXh0UmVzb3VyY2UucmVuZGVyaW5nO1xuICAgICAgICAgIGlmIChudWxsID09PSByZXR1cm5GaWJlcilcbiAgICAgICAgICAgIGlmIChuZXdQcm9wcykgY3V0T2ZmVGFpbElmTmVlZGVkKG5leHRSZXNvdXJjZSwgITEpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICE9PSBSb290SW5Qcm9ncmVzcyB8fFxuICAgICAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ICYmIDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGZvciAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSBjdXJyZW50OyApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHJldHVybkZpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKG5leHRSZXNvdXJjZSwgITEpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gcmV0dXJuRmliZXIudXBkYXRlUXVldWU7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSByZW5kZXJMYW5lcztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJlbmRlckxhbmVzO1xuXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzKHJlbmRlckxhbmVzLCBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzLnNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICBwdXNoKFxuICAgICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IsXG4gICAgICAgICAgICAgICAgICAgICAgKHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCAmXG4gICAgICAgICAgICAgICAgICAgICAgICBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaykgfFxuICAgICAgICAgICAgICAgICAgICAgICAgRm9yY2VTdXNwZW5zZUZhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UudGFpbCAmJlxuICAgICAgICAgICAgICAgIG5vdyQxKCkgPiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lICYmXG4gICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAgIChuZXdQcm9wcyA9ICEwKSxcbiAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQobmV4dFJlc291cmNlLCAhMSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gNDE5NDMwNCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICgoY3VycmVudCA9IGZpbmRGaXJzdFN1c3BlbmRlZChyZXR1cm5GaWJlcikpLCBudWxsICE9PSBjdXJyZW50KVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgICAobmV3UHJvcHMgPSAhMCksXG4gICAgICAgICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudCksXG4gICAgICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChuZXh0UmVzb3VyY2UsICEwKSxcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IG5leHRSZXNvdXJjZS50YWlsICYmXG4gICAgICAgICAgICAgICAgICAgIFwiaGlkZGVuXCIgPT09IG5leHRSZXNvdXJjZS50YWlsTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAhcmV0dXJuRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgICAgICFpc0h5ZHJhdGluZylcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICByZXR1cm4gYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIDIgKiBub3ckMSgpIC0gbmV4dFJlc291cmNlLnJlbmRlcmluZ1N0YXJ0VGltZSA+XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lICYmXG4gICAgICAgICAgICAgICAgICA1MzY4NzA5MTIgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgICAobmV3UHJvcHMgPSAhMCksXG4gICAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQobmV4dFJlc291cmNlLCAhMSksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSA0MTk0MzA0KSk7XG4gICAgICAgICAgICBuZXh0UmVzb3VyY2UuaXNCYWNrd2FyZHNcbiAgICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmV0dXJuRmliZXIpKVxuICAgICAgICAgICAgICA6ICgoY3VycmVudCA9IG5leHRSZXNvdXJjZS5sYXN0KSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50XG4gICAgICAgICAgICAgICAgICA/IChjdXJyZW50LnNpYmxpbmcgPSByZXR1cm5GaWJlcilcbiAgICAgICAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChuZXh0UmVzb3VyY2UubGFzdCA9IHJldHVybkZpYmVyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChudWxsICE9PSBuZXh0UmVzb3VyY2UudGFpbClcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChjdXJyZW50ID0gbmV4dFJlc291cmNlLnRhaWwpLFxuICAgICAgICAgICAgICAobmV4dFJlc291cmNlLnJlbmRlcmluZyA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgICAobmV4dFJlc291cmNlLnRhaWwgPSBjdXJyZW50LnNpYmxpbmcpLFxuICAgICAgICAgICAgICAobmV4dFJlc291cmNlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IG5vdyQxKCkpLFxuICAgICAgICAgICAgICAoY3VycmVudC5zaWJsaW5nID0gbnVsbCksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgPyAocmVuZGVyTGFuZXMgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaykgfFxuICAgICAgICAgICAgICAgICAgRm9yY2VTdXNwZW5zZUZhbGxiYWNrXG4gICAgICAgICAgICAgICAgOiByZW5kZXJMYW5lcyAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrKSxcbiAgICAgICAgICAgICAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcG9wSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAobmV3UHJvcHMgPSBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyAobnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MilcbiAgICAgICAgICAgICAgOiBuZXdQcm9wcyAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MiksXG4gICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICA/IDAgIT09IChyZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikgJiZcbiAgICAgICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpICYmXG4gICAgICAgICAgICAgICAgKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyAmIDYgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKSlcbiAgICAgICAgICAgICAgOiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgIG51bGwgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLnJldHJ5UXVldWUpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICAobmV3UHJvcHMgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAgICAgKG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICBuZXdQcm9wcyAhPT0gcmVuZGVyTGFuZXMgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDgpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBwb3AocmVzdW1lZENhY2hlLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlICE9PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgK1xuICAgICAgICAgIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW53aW5kV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzKSxcbiAgICAgICAgICAgIGN1cnJlbnQgJiA2NTUzNlxuICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3MpLFxuICAgICAgICAgICAgMCAhPT0gKGN1cnJlbnQgJiA2NTUzNikgJiYgMCA9PT0gKGN1cnJlbnQgJiAxMjgpXG4gICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IChjdXJyZW50ICYgLTY1NTM3KSB8IDEyOCksXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5kZWh5ZHJhdGVkKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlRocmV3IGluIG5ld2x5IG1vdW50ZWQgZGVoeWRyYXRlZCBjb21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnQgJiA2NTUzNlxuICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwb3BIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyksXG4gICAgICAgICAgICBjdXJyZW50ICYgNjU1MzZcbiAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJldHVybiBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIGludGVycnVwdGVkV29yaykge1xuICAgICAgcG9wVHJlZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IsIGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcG9wUHJvdmlkZXIoaW50ZXJydXB0ZWRXb3JrLnR5cGUsIGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgcG9wSGlkZGVuQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSwgaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIGludGVycnVwdGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFByb2ZpbGUoY3VycmVudCkge1xuICAgICAgcmV0dXJuIChjdXJyZW50Lm1vZGUgJiAyKSAhPT0gTm9Nb2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIGhvb2tGbGFncykge1xuICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgaG9va0ZsYWdzXG4gICAgKSB7XG4gICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgICAgICAgIGhvb2tGbGFncyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgIDogY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgaG9va0ZsYWdzLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoZmxhZ3MsIGZpbmlzaGVkV29yaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlLFxuICAgICAgICAgIGxhc3RFZmZlY3QgPSBudWxsICE9PSB1cGRhdGVRdWV1ZSA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCAhPT0gbGFzdEVmZmVjdCkge1xuICAgICAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA9IGZpcnN0RWZmZWN0O1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKHVwZGF0ZVF1ZXVlLnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzXG4gICAgICAgICAgICAgICAgPyBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkICYmXG4gICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZCAmJlxuICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChsYXN0RWZmZWN0ID0gdm9pZCAwKSxcbiAgICAgICAgICAgICAgKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMCksXG4gICAgICAgICAgICAgIChsYXN0RWZmZWN0ID0gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNhbGxDcmVhdGVJbkRFVixcbiAgICAgICAgICAgICAgICB1cGRhdGVRdWV1ZVxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMSksXG4gICAgICAgICAgICAgIChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzXG4gICAgICAgICAgICAgICAgPyBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkICYmXG4gICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKClcbiAgICAgICAgICAgICAgICA6IChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCAmJlxuICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCksXG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gbGFzdEVmZmVjdCAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBsYXN0RWZmZWN0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBob29rTmFtZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgaG9va05hbWUgPVxuICAgICAgICAgICAgICAgIDAgIT09ICh1cGRhdGVRdWV1ZS50YWcgJiBMYXlvdXQpXG4gICAgICAgICAgICAgICAgICA/IFwidXNlTGF5b3V0RWZmZWN0XCJcbiAgICAgICAgICAgICAgICAgIDogMCAhPT0gKHVwZGF0ZVF1ZXVlLnRhZyAmIEluc2VydGlvbilcbiAgICAgICAgICAgICAgICAgICAgPyBcInVzZUluc2VydGlvbkVmZmVjdFwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgICAgICAgdmFyIGFkZGVuZHVtID0gdm9pZCAwO1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9XG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gbGFzdEVmZmVjdFxuICAgICAgICAgICAgICAgICAgPyBcIiBZb3UgcmV0dXJuZWQgbnVsbC4gSWYgeW91ciBlZmZlY3QgZG9lcyBub3QgcmVxdWlyZSBjbGVhbiB1cCwgcmV0dXJuIHVuZGVmaW5lZCAob3Igbm90aGluZykuXCJcbiAgICAgICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbGFzdEVmZmVjdC50aGVuXG4gICAgICAgICAgICAgICAgICAgID8gXCJcXG5cXG5JdCBsb29rcyBsaWtlIHlvdSB3cm90ZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgaG9va05hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiKGFzeW5jICgpID0+IC4uLikgb3IgcmV0dXJuZWQgYSBQcm9taXNlLiBJbnN0ZWFkLCB3cml0ZSB0aGUgYXN5bmMgZnVuY3Rpb24gaW5zaWRlIHlvdXIgZWZmZWN0IGFuZCBjYWxsIGl0IGltbWVkaWF0ZWx5OlxcblxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBob29rTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgXCIoKCkgPT4ge1xcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKCkge1xcbiAgICAvLyBZb3UgY2FuIGF3YWl0IGhlcmVcXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBNeUFQSS5nZXREYXRhKHNvbWVJZCk7XFxuICAgIC8vIC4uLlxcbiAgfVxcbiAgZmV0Y2hEYXRhKCk7XFxufSwgW3NvbWVJZF0pOyAvLyBPciBbXSBpZiBlZmZlY3QgZG9lc24ndCBuZWVkIHByb3BzIG9yIHN0YXRlXFxuXFxuTGVhcm4gbW9yZSBhYm91dCBkYXRhIGZldGNoaW5nIHdpdGggSG9va3M6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaG9va3MtZGF0YS1mZXRjaGluZ1wiXG4gICAgICAgICAgICAgICAgICAgIDogXCIgWW91IHJldHVybmVkOiBcIiArIGxhc3RFZmZlY3Q7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAobiwgYSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCIlcyBtdXN0IG5vdCByZXR1cm4gYW55dGhpbmcgYmVzaWRlcyBhIGZ1bmN0aW9uLCB3aGljaCBpcyB1c2VkIGZvciBjbGVhbi11cC4lc1wiLFxuICAgICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgICBhXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaG9va05hbWUsXG4gICAgICAgICAgICAgICAgYWRkZW5kdW1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWUubmV4dDtcbiAgICAgICAgICB9IHdoaWxlICh1cGRhdGVRdWV1ZSAhPT0gZmlyc3RFZmZlY3QpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgZmxhZ3MsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUsXG4gICAgICAgICAgbGFzdEVmZmVjdCA9IG51bGwgIT09IHVwZGF0ZVF1ZXVlID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG4gICAgICAgIGlmIChudWxsICE9PSBsYXN0RWZmZWN0KSB7XG4gICAgICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlID0gZmlyc3RFZmZlY3Q7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKCh1cGRhdGVRdWV1ZS50YWcgJiBmbGFncykgPT09IGZsYWdzKSB7XG4gICAgICAgICAgICAgIHZhciBpbnN0ID0gdXBkYXRlUXVldWUuaW5zdCxcbiAgICAgICAgICAgICAgICBkZXN0cm95ID0gaW5zdC5kZXN0cm95O1xuICAgICAgICAgICAgICB2b2lkIDAgIT09IGRlc3Ryb3kgJiZcbiAgICAgICAgICAgICAgICAoKGluc3QuZGVzdHJveSA9IHZvaWQgMCksXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3NcbiAgICAgICAgICAgICAgICAgID8gbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZCAmJlxuICAgICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgKGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICEwKSxcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNhbGxEZXN0cm95SW5ERVYsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgICAgZGVzdHJveVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgKGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICExKSxcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFnc1xuICAgICAgICAgICAgICAgICAgPyBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkICYmXG4gICAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCgpXG4gICAgICAgICAgICAgICAgICA6IChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkICYmXG4gICAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZS5uZXh0O1xuICAgICAgICAgIH0gd2hpbGUgKHVwZGF0ZVF1ZXVlICE9PSBmaXJzdEVmZmVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIGhvb2tGbGFncykge1xuICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzKFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGhvb2tGbGFnc1xuICAgICkge1xuICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICBob29rRmxhZ3MsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgICAgICAgIGhvb2tGbGFncyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgIGlmIChudWxsICE9PSB1cGRhdGVRdWV1ZSkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICBmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgfHxcbiAgICAgICAgICBcInJlZlwiIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAgIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlIHByb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgcHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0Q2FsbGJhY2tzLFxuICAgICAgICAgICAgdXBkYXRlUXVldWUsXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbEdldFNuYXBzaG90QmVmb3JlVXBkYXRlcyhpbnN0YW5jZSwgcHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdENsYXNzU25hcHNob3QoZmluaXNoZWRXb3JrLCBjdXJyZW50KSB7XG4gICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzLFxuICAgICAgICBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIGZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyB8fFxuICAgICAgICBcInJlZlwiIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgKGN1cnJlbnQucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgKSxcbiAgICAgICAgY3VycmVudC5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICApKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXNvbHZlZFByZXZQcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKFxuICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgPT09IGZpbmlzaGVkV29yay50eXBlXG4gICAgICAgICk7XG4gICAgICAgIHZhciBzbmFwc2hvdCA9IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjYWxsR2V0U25hcHNob3RCZWZvcmVVcGRhdGVzLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgcmVzb2x2ZWRQcmV2UHJvcHMsXG4gICAgICAgICAgcHJldlN0YXRlXG4gICAgICAgICk7XG4gICAgICAgIHByZXZQcm9wcyA9IGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlO1xuICAgICAgICB2b2lkIDAgIT09IHNuYXBzaG90IHx8XG4gICAgICAgICAgcHJldlByb3BzLmhhcyhmaW5pc2hlZFdvcmsudHlwZSkgfHxcbiAgICAgICAgICAocHJldlByb3BzLmFkZChmaW5pc2hlZFdvcmsudHlwZSksXG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmluaXNoZWRXb3JrLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCk6IEEgc25hcHNob3QgdmFsdWUgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgY3VycmVudC5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHNuYXBzaG90O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgaW5zdGFuY2VcbiAgICApIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgIGN1cnJlbnQudHlwZSxcbiAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzXG4gICAgICApO1xuICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICBzaG91bGRQcm9maWxlKGN1cnJlbnQpXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRJbkRFVixcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50SW5ERVYsXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gICAgICBpZiAobnVsbCAhPT0gcmVmKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBpbnN0YW5jZSA9IGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmKVxuICAgICAgICAgIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdGFydEVmZmVjdFRpbWVyKCksIChmaW5pc2hlZFdvcmsucmVmQ2xlYW51cCA9IHJlZihpbnN0YW5jZSkpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGZpbmlzaGVkV29yay5yZWZDbGVhbnVwID0gcmVmKGluc3RhbmNlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiByZWZcbiAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcIlN0cmluZyByZWZzIGFyZSBubyBsb25nZXIgc3VwcG9ydGVkLlwiKVxuICAgICAgICAgICAgOiByZWYuaGFzT3duUHJvcGVydHkoXCJjdXJyZW50XCIpIHx8XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiBVc2UgZWl0aGVyIGEgcmVmLXNldHRlciBmdW5jdGlvbiBvciBSZWFjdC5jcmVhdGVSZWYoKS5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChyZWYuY3VycmVudCA9IGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZWx5QXR0YWNoUmVmKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGN1cnJlbnQsIGNvbW1pdEF0dGFjaFJlZiwgY3VycmVudCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gICAgICB2YXIgcmVmID0gY3VycmVudC5yZWYsXG4gICAgICAgIHJlZkNsZWFudXAgPSBjdXJyZW50LnJlZkNsZWFudXA7XG4gICAgICBpZiAobnVsbCAhPT0gcmVmKVxuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmQ2xlYW51cClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoY3VycmVudCkpXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhcnRFZmZlY3RUaW1lcigpLCBydW5XaXRoRmliZXJJbkRFVihjdXJyZW50LCByZWZDbGVhbnVwKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbihjdXJyZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBydW5XaXRoRmliZXJJbkRFVihjdXJyZW50LCByZWZDbGVhbnVwKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAoY3VycmVudC5yZWZDbGVhbnVwID0gbnVsbCksXG4gICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5hbHRlcm5hdGUpLFxuICAgICAgICAgICAgICBudWxsICE9IGN1cnJlbnQgJiYgKGN1cnJlbnQucmVmQ2xlYW51cCA9IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkUHJvZmlsZShjdXJyZW50KSlcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGFydEVmZmVjdFRpbWVyKCksIHJ1bldpdGhGaWJlckluREVWKGN1cnJlbnQsIHJlZiwgbnVsbCk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oY3VycmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgcnVuV2l0aEZpYmVySW5ERVYoY3VycmVudCwgcmVmLCBudWxsKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvciQzKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvciQzKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRQcm9maWxlcihcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICBlZmZlY3REdXJhdGlvblxuICAgICkge1xuICAgICAgdmFyIF9maW5pc2hlZFdvcmskbWVtb2l6ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICBpZCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5pZCxcbiAgICAgICAgb25Db21taXQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUub25Db21taXQ7XG4gICAgICBfZmluaXNoZWRXb3JrJG1lbW9pemUgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUub25SZW5kZXI7XG4gICAgICBjdXJyZW50ID0gbnVsbCA9PT0gY3VycmVudCA/IFwibW91bnRcIiA6IFwidXBkYXRlXCI7XG4gICAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgJiYgKGN1cnJlbnQgPSBcIm5lc3RlZC11cGRhdGVcIik7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfZmluaXNoZWRXb3JrJG1lbW9pemUgJiZcbiAgICAgICAgX2ZpbmlzaGVkV29yayRtZW1vaXplKFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uLFxuICAgICAgICAgIGZpbmlzaGVkV29yay50cmVlQmFzZUR1cmF0aW9uLFxuICAgICAgICAgIGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsXG4gICAgICAgICAgY29tbWl0U3RhcnRUaW1lXG4gICAgICAgICk7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvbkNvbW1pdCAmJlxuICAgICAgICBvbkNvbW1pdChcbiAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIGVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRQcm9maWxlclBvc3RDb21taXRJbXBsKFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgY3VycmVudCxcbiAgICAgIGNvbW1pdFN0YXJ0VGltZSxcbiAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvblxuICAgICkge1xuICAgICAgdmFyIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgIGZpbmlzaGVkV29yayA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIuaWQ7XG4gICAgICBfZmluaXNoZWRXb3JrJG1lbW9pemUyID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vblBvc3RDb21taXQ7XG4gICAgICBjdXJyZW50ID0gbnVsbCA9PT0gY3VycmVudCA/IFwibW91bnRcIiA6IFwidXBkYXRlXCI7XG4gICAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgJiYgKGN1cnJlbnQgPSBcIm5lc3RlZC11cGRhdGVcIik7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfZmluaXNoZWRXb3JrJG1lbW9pemUyICYmXG4gICAgICAgIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb3N0TW91bnQoZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICB0cnkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY29tbWl0TW91bnQsXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb3N0VXBkYXRlKGZpbmlzaGVkV29yaywgbmV3UHJvcHMsIG9sZFByb3BzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY29tbWl0VXBkYXRlLFxuICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgb2xkUHJvcHMsXG4gICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNIb3N0UGFyZW50KGZpYmVyKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA1ID09PSBmaWJlci50YWcgfHxcbiAgICAgICAgMyA9PT0gZmliZXIudGFnIHx8XG4gICAgICAgIChzdXBwb3J0c1Jlc291cmNlcyA/IDI2ID09PSBmaWJlci50YWcgOiAhMSkgfHxcbiAgICAgICAgKHN1cHBvcnRzU2luZ2xldG9ucyA/IDI3ID09PSBmaWJlci50YWcgOiAhMSkgfHxcbiAgICAgICAgNCA9PT0gZmliZXIudGFnXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcikge1xuICAgICAgYTogZm9yICg7Oykge1xuICAgICAgICBmb3IgKDsgbnVsbCA9PT0gZmliZXIuc2libGluZzsgKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGZpYmVyLnJldHVybiB8fCBpc0hvc3RQYXJlbnQoZmliZXIucmV0dXJuKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmliZXIuc2libGluZy5yZXR1cm4gPSBmaWJlci5yZXR1cm47XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgZmliZXIgPSBmaWJlci5zaWJsaW5nO1xuICAgICAgICAgIDUgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAgIDYgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAgIChzdXBwb3J0c1NpbmdsZXRvbnMgPyAyNyAhPT0gZmliZXIudGFnIDogMSkgJiZcbiAgICAgICAgICAxOCAhPT0gZmliZXIudGFnO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChmaWJlci5mbGFncyAmIDIpIGNvbnRpbnVlIGE7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGZpYmVyLmNoaWxkIHx8IDQgPT09IGZpYmVyLnRhZykgY29udGludWUgYTtcbiAgICAgICAgICBlbHNlIChmaWJlci5jaGlsZC5yZXR1cm4gPSBmaWJlciksIChmaWJlciA9IGZpYmVyLmNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShmaWJlci5mbGFncyAmIDIpKSByZXR1cm4gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICBpZiAoNSA9PT0gdGFnIHx8IDYgPT09IHRhZylcbiAgICAgICAgKG5vZGUgPSBub2RlLnN0YXRlTm9kZSksXG4gICAgICAgICAgYmVmb3JlXG4gICAgICAgICAgICA/IGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgbm9kZSwgYmVmb3JlKVxuICAgICAgICAgICAgOiBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZSk7XG4gICAgICBlbHNlIGlmIChcbiAgICAgICAgISg0ID09PSB0YWcgfHwgKHN1cHBvcnRzU2luZ2xldG9ucyAmJiAyNyA9PT0gdGFnKSkgJiZcbiAgICAgICAgKChub2RlID0gbm9kZS5jaGlsZCksIG51bGwgIT09IG5vZGUpXG4gICAgICApXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCksXG4gICAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICAgIG51bGwgIT09IG5vZGU7XG5cbiAgICAgICAgKVxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpLFxuICAgICAgICAgICAgKG5vZGUgPSBub2RlLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICAgIGlmICg1ID09PSB0YWcgfHwgNiA9PT0gdGFnKVxuICAgICAgICAobm9kZSA9IG5vZGUuc3RhdGVOb2RlKSxcbiAgICAgICAgICBiZWZvcmVcbiAgICAgICAgICAgID8gaW5zZXJ0QmVmb3JlKHBhcmVudCwgbm9kZSwgYmVmb3JlKVxuICAgICAgICAgICAgOiBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUpO1xuICAgICAgZWxzZSBpZiAoXG4gICAgICAgICEoNCA9PT0gdGFnIHx8IChzdXBwb3J0c1NpbmdsZXRvbnMgJiYgMjcgPT09IHRhZykpICYmXG4gICAgICAgICgobm9kZSA9IG5vZGUuY2hpbGQpLCBudWxsICE9PSBub2RlKVxuICAgICAgKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCksXG4gICAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICAgIG51bGwgIT09IG5vZGU7XG5cbiAgICAgICAgKVxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCksXG4gICAgICAgICAgICAobm9kZSA9IG5vZGUuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgICAgIGlmIChcbiAgICAgICAgc3VwcG9ydHNNdXRhdGlvbiAmJlxuICAgICAgICAoIXN1cHBvcnRzU2luZ2xldG9ucyB8fCAyNyAhPT0gZmluaXNoZWRXb3JrLnRhZylcbiAgICAgICkge1xuICAgICAgICBhOiB7XG4gICAgICAgICAgZm9yICh2YXIgcGFyZW50ID0gZmluaXNoZWRXb3JrLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApIHtcbiAgICAgICAgICAgIGlmIChpc0hvc3RQYXJlbnQocGFyZW50KSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50RmliZXIgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgcGFyZW50RmliZXIgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBwYXJlbnRGaWJlciwgcGFyZW50KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgcGFyZW50RmliZXIuZmxhZ3MgJiAzMiAmJlxuICAgICAgICAgICAgICAocmVzZXRUZXh0Q29udGVudChwYXJlbnQpLCAocGFyZW50RmliZXIuZmxhZ3MgJj0gLTMzKSk7XG4gICAgICAgICAgICBwYXJlbnRGaWJlciA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBwYXJlbnRGaWJlciwgcGFyZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHBhcmVudEZpYmVyID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgICAgIHBhcmVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvc3RQb3J0YWxDb250YWluZXJDaGlsZHJlbihcbiAgICAgIHBvcnRhbCxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIHBlbmRpbmdDaGlsZHJlblxuICAgICkge1xuICAgICAgcG9ydGFsID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG4gICAgICB0cnkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuLFxuICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICBwZW5kaW5nQ2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmlyc3RDaGlsZCkge1xuICAgICAgcHJlcGFyZUZvckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgZm9yIChuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChyb290ID0gbmV4dEVmZmVjdCksXG4gICAgICAgICAgKGZpcnN0Q2hpbGQgPSByb290LmNoaWxkKSxcbiAgICAgICAgICAwICE9PSAocm9vdC5zdWJ0cmVlRmxhZ3MgJiAxMDI4KSAmJiBudWxsICE9PSBmaXJzdENoaWxkKVxuICAgICAgICApXG4gICAgICAgICAgKGZpcnN0Q2hpbGQucmV0dXJuID0gcm9vdCksIChuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKSB7XG4gICAgICAgICAgICBmaXJzdENoaWxkID0gcm9vdCA9IG5leHRFZmZlY3Q7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IGZpcnN0Q2hpbGQuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICBmbGFncyA9IGZpcnN0Q2hpbGQuZmxhZ3M7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpcnN0Q2hpbGQudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIDAgIT09IChmbGFncyAmIDEwMjQpICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICBjb21taXRDbGFzc1NuYXBzaG90KGZpcnN0Q2hpbGQsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgMCAhPT0gKGZsYWdzICYgMTAyNCkgJiZcbiAgICAgICAgICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb24gJiZcbiAgICAgICAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyKGZpcnN0Q2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICgwICE9PSAoZmxhZ3MgJiAxMDI0KSlcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlRoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3RDaGlsZCA9IHJvb3Quc2libGluZztcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBmaXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgIGZpcnN0Q2hpbGQucmV0dXJuID0gcm9vdC5yZXR1cm47XG4gICAgICAgICAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRFZmZlY3QgPSByb290LnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICByb290ID0gc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyO1xuICAgICAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gITE7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIExheW91dCB8IEhhc0VmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKGZsYWdzICYgNClcbiAgICAgICAgICAgIGlmICgoKGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpLCBudWxsID09PSBjdXJyZW50KSlcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzIHx8XG4gICAgICAgICAgICAgICAgXCJyZWZcIiBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgICAgICAgICAoZmluaXNoZWRSb290LnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgY29tcG9uZW50RGlkTW91bnQuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3Quc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSBjb21wb25lbnREaWRNb3VudC4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgICAgICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyB8fFxuICAgICAgICAgICAgICAgIFwicmVmXCIgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgICAgICAgICAgKGZpbmlzaGVkUm9vdC5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlIGNvbXBvbmVudERpZFVwZGF0ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlIGNvbXBvbmVudERpZFVwZGF0ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgICAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICAgICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZmxhZ3MgJiA2NCAmJiBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY3VycmVudCA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZmxhZ3MgJiA2NCAmJlxuICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksIG51bGwgIT09IGZsYWdzKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJldlByb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBmaW5pc2hlZFdvcmsuY2hpbGQpXG4gICAgICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLmNoaWxkLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgcHJldlByb3BzID0gZ2V0UHVibGljSW5zdGFuY2UoZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICBwcmV2UHJvcHMgPSBmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0Q2FsbGJhY2tzLFxuICAgICAgICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmlzaGVkUm9vdC5lZmZlY3REdXJhdGlvbiArPSBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMoY3VycmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBmbGFncyAmIDUxMiAmJiBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmIGZsYWdzICYgNCAmJiBjb21taXRIb3N0TW91bnQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJiBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0KSB7XG4gICAgICAgICAgICBmbGFncyA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QuZWZmZWN0RHVyYXRpb24gKz0gYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKGZsYWdzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRQcm9maWxlcixcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LmVmZmVjdER1cmF0aW9uXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBwcmV2UHJvcHMgPVxuICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgfHwgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICAgICAgICBjdXJyZW50ID1cbiAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4sXG4gICAgICAgICAgICAgIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZQcm9wcztcbiAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gY3VycmVudCkgJiZcbiAgICAgICAgICAgICFwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlblxuICAgICAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAwICE9PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDg3NzIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgICAgICAoXCJtYW51YWxcIiA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMubW9kZVxuICAgICAgICAgICAgICA/IHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pXG4gICAgICAgICAgICAgIDogc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiZcbiAgICAgICAgKChmaWJlci5hbHRlcm5hdGUgPSBudWxsKSwgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoYWx0ZXJuYXRlKSk7XG4gICAgICBmaWJlci5jaGlsZCA9IG51bGw7XG4gICAgICBmaWJlci5kZWxldGlvbnMgPSBudWxsO1xuICAgICAgZmliZXIuc2libGluZyA9IG51bGw7XG4gICAgICA1ID09PSBmaWJlci50YWcgJiZcbiAgICAgICAgKChhbHRlcm5hdGUgPSBmaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgZGV0YWNoRGVsZXRlZEluc3RhbmNlKGFsdGVybmF0ZSkpO1xuICAgICAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDtcbiAgICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICAgIGZpYmVyLnJldHVybiA9IG51bGw7XG4gICAgICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsO1xuICAgICAgZmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIHBhcmVudFxuICAgICkge1xuICAgICAgZm9yIChwYXJlbnQgPSBwYXJlbnQuY2hpbGQ7IG51bGwgIT09IHBhcmVudDsgKVxuICAgICAgICBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgIHBhcmVudFxuICAgICAgICApLFxuICAgICAgICAgIChwYXJlbnQgPSBwYXJlbnQuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgZGVsZXRlZEZpYmVyXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGluamVjdGVkSG9vayAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnRcbiAgICAgIClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgfHxcbiAgICAgICAgICAgICgoaGFzTG9nZ2VkRXJyb3IgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXNcIixcbiAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgc3dpdGNoIChkZWxldGVkRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICA/IHJlbGVhc2VSZXNvdXJjZShkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZSlcbiAgICAgICAgICAgICAgOiBkZWxldGVkRmliZXIuc3RhdGVOb2RlICYmXG4gICAgICAgICAgICAgICAgdW5tb3VudEhvaXN0YWJsZShkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICAgICAgdmFyIHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudCxcbiAgICAgICAgICAgICAgcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UoZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICBob3N0UGFyZW50ID0gcHJldkhvc3RQYXJlbnQ7XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyID0gaG9zdFBhcmVudElzQ29udGFpbmVyKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnQgPSBudWxsKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaG9zdFBhcmVudClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgaWYgKGhvc3RQYXJlbnRJc0NvbnRhaW5lcilcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICBob3N0UGFyZW50LFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIuc3RhdGVOb2RlXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGQsXG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb24gJiZcbiAgICAgICAgICAgIG51bGwgIT09IGhvc3RQYXJlbnQgJiZcbiAgICAgICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXJcbiAgICAgICAgICAgICAgPyBjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyKFxuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudCxcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KGhvc3RQYXJlbnQsIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb25cbiAgICAgICAgICAgID8gKChwcmV2SG9zdFBhcmVudCA9IGhvc3RQYXJlbnQpLFxuICAgICAgICAgICAgICAocHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGhvc3RQYXJlbnRJc0NvbnRhaW5lciksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50ID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICEwKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyKSlcbiAgICAgICAgICAgIDogKHN1cHBvcnRzUGVyc2lzdGVuY2UgJiZcbiAgICAgICAgICAgICAgICBjb21taXRIb3N0UG9ydGFsQ29udGFpbmVyQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIuc3RhdGVOb2RlLFxuICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgICBJbnNlcnRpb24sXG4gICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICBjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgTGF5b3V0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgIChzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSxcbiAgICAgICAgICAgIChwcmV2SG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJldkhvc3RQYXJlbnQuY29tcG9uZW50V2lsbFVubW91bnQgJiZcbiAgICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KFxuICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgIHByZXZIb3N0UGFyZW50XG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9XG4gICAgICAgICAgICAocHJldkhvc3RQYXJlbnQgPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB8fFxuICAgICAgICAgICAgbnVsbCAhPT0gZGVsZXRlZEZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2SG9zdFBhcmVudDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHN1cHBvcnRzSHlkcmF0aW9uICYmXG4gICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICgoZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSksXG4gICAgICAgIG51bGwgIT09IGZpbmlzaGVkUm9vdCAmJlxuICAgICAgICAgICgoZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkUm9vdCAmJlxuICAgICAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QuZGVoeWRyYXRlZCksIG51bGwgIT09IGZpbmlzaGVkUm9vdCkpKVxuICAgICAgKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgICAgICAgZmluaXNoZWRSb290XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZXRyeUNhY2hlKGZpbmlzaGVkV29yaykge1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIG51bGwgPT09IHJldHJ5Q2FjaGUgJiZcbiAgICAgICAgICAgIChyZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IG5ldyBQb3NzaWJseVdlYWtTZXQoKSk7XG4gICAgICAgICAgcmV0dXJuIHJldHJ5Q2FjaGU7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgIChyZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLl9yZXRyeUNhY2hlKSxcbiAgICAgICAgICAgIG51bGwgPT09IHJldHJ5Q2FjaGUgJiZcbiAgICAgICAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuX3JldHJ5Q2FjaGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCkpLFxuICAgICAgICAgICAgcmV0cnlDYWNoZVxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgU3VzcGVuc2UgaGFuZGxlciB0YWcgKFwiICtcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnRhZyArXG4gICAgICAgICAgICAgIFwiKS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCB3YWtlYWJsZXMpIHtcbiAgICAgIHZhciByZXRyeUNhY2hlID0gZ2V0UmV0cnlDYWNoZShmaW5pc2hlZFdvcmspO1xuICAgICAgd2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHdha2VhYmxlKSB7XG4gICAgICAgIHZhciByZXRyeSA9IHJlc29sdmVSZXRyeVdha2VhYmxlLmJpbmQobnVsbCwgZmluaXNoZWRXb3JrLCB3YWtlYWJsZSk7XG4gICAgICAgIGlmICghcmV0cnlDYWNoZS5oYXMod2FrZWFibGUpKSB7XG4gICAgICAgICAgcmV0cnlDYWNoZS5hZGQod2FrZWFibGUpO1xuICAgICAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudClcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBpblByb2dyZXNzTGFuZXMgJiYgbnVsbCAhPT0gaW5Qcm9ncmVzc1Jvb3QpXG4gICAgICAgICAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMoaW5Qcm9ncmVzc1Jvb3QsIGluUHJvZ3Jlc3NMYW5lcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgZmluaXNoZWQgcm9vdCBhbmQgbGFuZXMgdG8gYmUgc2V0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgd2FrZWFibGUudGhlbihyZXRyeSwgcmV0cnkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMpIHtcbiAgICAgIGluUHJvZ3Jlc3NMYW5lcyA9IGNvbW1pdHRlZExhbmVzO1xuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICAgICAgY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QpO1xuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QkanNjb21wJDAsIHBhcmVudEZpYmVyKSB7XG4gICAgICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuICAgICAgaWYgKG51bGwgIT09IGRlbGV0aW9ucylcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IHJvb3QkanNjb21wJDAsXG4gICAgICAgICAgICByZXR1cm5GaWJlciA9IHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyID0gZGVsZXRpb25zW2ldO1xuICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICBhOiBmb3IgKDsgbnVsbCAhPT0gcGFyZW50OyApIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudWxsID09PSBob3N0UGFyZW50KVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihyb290LCByZXR1cm5GaWJlciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITE7XG4gICAgICAgICAgfSBlbHNlIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIocm9vdCwgcmV0dXJuRmliZXIsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgcm9vdCA9IGRlbGV0ZWRGaWJlcjtcbiAgICAgICAgICByZXR1cm5GaWJlciA9IHJvb3QuYWx0ZXJuYXRlO1xuICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyICYmIChyZXR1cm5GaWJlci5yZXR1cm4gPSBudWxsKTtcbiAgICAgICAgICByb290LnJldHVybiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMzg3OClcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIocGFyZW50RmliZXIsIHJvb3QkanNjb21wJDApLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290KSB7XG4gICAgICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAoY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgICBJbnNlcnRpb24gfCBIYXNFZmZlY3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVyblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgY29tbWl0SG9va0xheW91dFVubW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgIExheW91dCB8IEhhc0VmZmVjdFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICAgICAgZmxhZ3MgJiA2NCAmJlxuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuICYmXG4gICAgICAgICAgICAoKGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsgJiZcbiAgICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay5jYWxsYmFja3MpLFxuICAgICAgICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICAgICAgICgoY3VycmVudCA9IGZpbmlzaGVkV29yay5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzKSxcbiAgICAgICAgICAgICAgICAoZmluaXNoZWRXb3JrLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MgPVxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCA/IGZsYWdzIDogY3VycmVudC5jb25jYXQoZmxhZ3MpKSkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIHZhciBob2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybikpO1xuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAgICgoZmxhZ3MgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbCksXG4gICAgICAgICAgICAgIChyb290ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgICAgPyBudWxsID09PSByb290XG4gICAgICAgICAgICAgICAgICA/IG51bGwgPT09IGZpbmlzaGVkV29yay5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICAgPyAoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IGh5ZHJhdGVIb2lzdGFibGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgIDogbW91bnRIb2lzdGFibGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiAoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IGFjcXVpcmVSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICA6IGZsYWdzICE9PSByb290XG4gICAgICAgICAgICAgICAgICA/IChudWxsID09PSBmbGFnc1xuICAgICAgICAgICAgICAgICAgICAgID8gbnVsbCAhPT0gY3VycmVudC5zdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVubW91bnRIb2lzdGFibGUoY3VycmVudC5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgOiByZWxlYXNlUmVzb3VyY2UoZmxhZ3MpLFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSByb290XG4gICAgICAgICAgICAgICAgICAgICAgPyBtb3VudEhvaXN0YWJsZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICA6IGFjcXVpcmVSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICA6IG51bGwgPT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBjb21taXRIb3N0VXBkYXRlKFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgc3VwcG9ydHNTaW5nbGV0b25zICYmXG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjbGVhclNpbmdsZXRvbihob2lzdGFibGVSb290KSxcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIDMyKSB7XG4gICAgICAgICAgICAgIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpbmlzaGVkV29yaywgcmVzZXRUZXh0Q29udGVudCwgcm9vdCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICYmXG4gICAgICAgICAgICAgICgocm9vdCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSxcbiAgICAgICAgICAgICAgY29tbWl0SG9zdFVwZGF0ZShcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogcm9vdFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGZsYWdzICYgMTAyNCAmJlxuICAgICAgICAgICAgICAoKG5lZWRzRm9ybVJlc2V0ID0gITApLFxuICAgICAgICAgICAgICBcImZvcm1cIiAhPT0gZmluaXNoZWRXb3JrLnR5cGUgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIGhvc3QgY29tcG9uZW50IHR5cGUuIEV4cGVjdGVkIGEgZm9ybS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0ICYmIHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBjdXJyZW50ID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IGZsYWdzO1xuICAgICAgICAgICAgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSxcbiAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgZmxhZ3NcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGhvaXN0YWJsZVJvb3QgPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgc3VwcG9ydHNSZXNvdXJjZXNcbiAgICAgICAgICAgID8gKHByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXMoKSxcbiAgICAgICAgICAgICAgKHByb3BzID0gY3VycmVudEhvaXN0YWJsZVJvb3QpLFxuICAgICAgICAgICAgICAoY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KHJvb3QuY29udGFpbmVySW5mbykpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICAgIChjdXJyZW50SG9pc3RhYmxlUm9vdCA9IHByb3BzKSlcbiAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGlmIChmbGFncyAmIDQpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgc3VwcG9ydHNNdXRhdGlvbiAmJlxuICAgICAgICAgICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgcm9vdC5jb250YWluZXJJbmZvXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICAgIGZsYWdzID0gcm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICBjdXJyZW50ID0gcm9vdC5wZW5kaW5nQ2hpbGRyZW47XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICBmbGFncyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuZWVkc0Zvcm1SZXNldCAmJlxuICAgICAgICAgICAgKChuZWVkc0Zvcm1SZXNldCA9ICExKSwgcmVjdXJzaXZlbHlSZXNldEZvcm1zKGZpbmlzaGVkV29yaykpO1xuICAgICAgICAgIHJvb3QuZWZmZWN0RHVyYXRpb24gKz0gcG9wTmVzdGVkRWZmZWN0RHVyYXRpb25zKGhvaXN0YWJsZVJvb3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc3VwcG9ydHNSZXNvdXJjZXNcbiAgICAgICAgICAgID8gKChjdXJyZW50ID0gY3VycmVudEhvaXN0YWJsZVJvb3QpLFxuICAgICAgICAgICAgICAoY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRIb2lzdGFibGVSb290ID0gY3VycmVudCkpXG4gICAgICAgICAgICA6IChyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIHN1cHBvcnRzUGVyc2lzdGVuY2UgJiZcbiAgICAgICAgICAgIGNvbW1pdEhvc3RQb3J0YWxDb250YWluZXJDaGlsZHJlbihcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLnBlbmRpbmdDaGlsZHJlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBmbGFncyA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiArPVxuICAgICAgICAgICAgYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKGZsYWdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLmNoaWxkLmZsYWdzICYgODE5MiAmJlxuICAgICAgICAgICAgKG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSAhPT1cbiAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSAmJlxuICAgICAgICAgICAgKGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSBub3ckMSgpKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIGZsYWdzKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgICAgICAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybikpO1xuICAgICAgICAgIGhvaXN0YWJsZVJvb3QgPSBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgd2FzSGlkZGVuID0gbnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuLFxuICAgICAgICAgICAgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9XG4gICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIHx8IGhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9XG4gICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fCB3YXNIaWRkZW47XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIHJvb3QuX2N1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgICAgcm9vdC5fdmlzaWJpbGl0eSAmPSAtMztcbiAgICAgICAgICByb290Ll92aXNpYmlsaXR5IHw9IHJvb3QuX3BlbmRpbmdWaXNpYmlsaXR5ICYgMjtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmbGFncyAmIDgxOTIgJiZcbiAgICAgICAgICAgICgocm9vdC5fdmlzaWJpbGl0eSA9IGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgPyByb290Ll92aXNpYmlsaXR5ICYgLTJcbiAgICAgICAgICAgICAgOiByb290Ll92aXNpYmlsaXR5IHwgMSksXG4gICAgICAgICAgICBob2lzdGFibGVSb290ICYmXG4gICAgICAgICAgICAgICgocm9vdCA9IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiB8fCBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICAgIHdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgICAgIHJvb3QgfHxcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspKSxcbiAgICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb24gJiZcbiAgICAgICAgICAgICAgKG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgICAgICAgICAgXCJtYW51YWxcIiAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMubW9kZSkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYTogaWYgKCgoY3VycmVudCA9IG51bGwpLCBzdXBwb3J0c011dGF0aW9uKSlcbiAgICAgICAgICAgICAgZm9yIChyb290ID0gZmluaXNoZWRXb3JrOyA7ICkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIDUgPT09IHJvb3QudGFnIHx8XG4gICAgICAgICAgICAgICAgICAoc3VwcG9ydHNSZXNvdXJjZXMgJiYgMjYgPT09IHJvb3QudGFnKSB8fFxuICAgICAgICAgICAgICAgICAgKHN1cHBvcnRzU2luZ2xldG9ucyAmJiAyNyA9PT0gcm9vdC50YWcpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4gPSBjdXJyZW50ID0gcm9vdDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAocHJvcHMgPSB3YXNIaWRkZW4uc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBydW5XaXRoRmliZXJJbkRFVih3YXNIaWRkZW4sIGhpZGVJbnN0YW5jZSwgcHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhpZGVJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4ubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4ucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICg2ID09PSByb290LnRhZykge1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuID0gcm9vdDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB3YXNIaWRkZW4uc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5oaWRlVGV4dEluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4ucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICgoMjIgIT09IHJvb3QudGFnICYmIDIzICE9PSByb290LnRhZykgfHxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcm9vdC5tZW1vaXplZFN0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPT09IGZpbmlzaGVkV29yaykgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJvb3QuY2hpbGRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJvb3QuY2hpbGQucmV0dXJuID0gcm9vdDtcbiAgICAgICAgICAgICAgICAgIHJvb3QgPSByb290LmNoaWxkO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290ID09PSBmaW5pc2hlZFdvcmspIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgZm9yICg7IG51bGwgPT09IHJvb3Quc2libGluZzsgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gcm9vdC5yZXR1cm4gfHwgcm9vdC5yZXR1cm4gPT09IGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPT09IHJvb3QgJiYgKGN1cnJlbnQgPSBudWxsKTtcbiAgICAgICAgICAgICAgICAgIHJvb3QgPSByb290LnJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9PT0gcm9vdCAmJiAoY3VycmVudCA9IG51bGwpO1xuICAgICAgICAgICAgICAgIHJvb3Quc2libGluZy5yZXR1cm4gPSByb290LnJldHVybjtcbiAgICAgICAgICAgICAgICByb290ID0gcm9vdC5zaWJsaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAoKGZsYWdzID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgICAgICgoY3VycmVudCA9IGZsYWdzLnJldHJ5UXVldWUpLFxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgKChmbGFncy5yZXRyeVF1ZXVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIGN1cnJlbnQpKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIGZsYWdzKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBpZiAoZmxhZ3MgJiAyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmluaXNoZWRXb3JrLCBjb21taXRQbGFjZW1lbnQsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IC0zO1xuICAgICAgfVxuICAgICAgZmxhZ3MgJiA0MDk2ICYmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gLTQwOTcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVJlc2V0Rm9ybXMocGFyZW50RmliZXIpIHtcbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI0KVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICAgICAgICB2YXIgZmliZXIgPSBwYXJlbnRGaWJlcjtcbiAgICAgICAgICByZWN1cnNpdmVseVJlc2V0Rm9ybXMoZmliZXIpO1xuICAgICAgICAgIDUgPT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAgICAgZmliZXIuZmxhZ3MgJiAxMDI0ICYmXG4gICAgICAgICAgICByZXNldEZvcm1JbnN0YW5jZShmaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcbiAgICAgIGluUHJvZ3Jlc3NMYW5lcyA9IGNvbW1pdHRlZExhbmVzO1xuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICAgICAgY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihyb290LCBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLCBmaW5pc2hlZFdvcmspO1xuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhyb290LCBwYXJlbnRGaWJlcikge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDg3NzIpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgICBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKHJvb3QsIHBhcmVudEZpYmVyLmFsdGVybmF0ZSwgcGFyZW50RmliZXIpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKSB7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNvbW1pdEhvb2tMYXlvdXRVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICBMYXlvdXRcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ICYmXG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhwYXJlbnRGaWJlciksXG4gICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIExheW91dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgY3VycmVudCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY3VycmVudC5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZE1vdW50SW5ERVYsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdEhpZGRlbkNhbGxiYWNrcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgNjQgJiZcbiAgICAgICAgICAgIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRIb3N0TW91bnQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBpZiAoaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiBmbGFncyAmIDQpIHtcbiAgICAgICAgICAgIGZsYWdzID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMuZWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgICAgYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKGZsYWdzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRQcm9maWxlcixcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cy5lZmZlY3REdXJhdGlvblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICkge1xuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyA9XG4gICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgMCAhPT0gKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDg3NzIpO1xuICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICByZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIHBhcmVudEZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgICBwYXJlbnRGaWJlcixcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICksXG4gICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgcHJldmlvdXNDYWNoZSA9IG51bGw7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgIChwcmV2aW91c0NhY2hlID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKTtcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgIChjdXJyZW50ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpO1xuICAgICAgY3VycmVudCAhPT0gcHJldmlvdXNDYWNoZSAmJlxuICAgICAgICAobnVsbCAhPSBjdXJyZW50ICYmIHJldGFpbkNhY2hlKGN1cnJlbnQpLFxuICAgICAgICBudWxsICE9IHByZXZpb3VzQ2FjaGUgJiYgcmVsZWFzZUNhY2hlKHByZXZpb3VzQ2FjaGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgJiZcbiAgICAgICAgKGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICAgICAgZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gICAgICBmaW5pc2hlZFdvcmsgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgKHJldGFpbkNhY2hlKGZpbmlzaGVkV29yayksIG51bGwgIT0gY3VycmVudCAmJiByZWxlYXNlQ2FjaGUoY3VycmVudCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgIHJvb3QsXG4gICAgICBwYXJlbnRGaWJlcixcbiAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICApIHtcbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBQYXNzaXZlIHwgSGFzRWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZhciBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgICgoY29tbWl0dGVkTGFuZXMgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgKGNvbW1pdHRlZExhbmVzID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgICAgIChmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZSksXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsgIT09IGNvbW1pdHRlZExhbmVzICYmXG4gICAgICAgICAgICAgIChyZXRhaW5DYWNoZShmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgICBudWxsICE9IGNvbW1pdHRlZExhbmVzICYmIHJlbGVhc2VDYWNoZShjb21taXR0ZWRMYW5lcykpKTtcbiAgICAgICAgICBmaW5pc2hlZFJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBpZiAoZmxhZ3MgJiAyMDQ4KSB7XG4gICAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICAgIGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdFByb2ZpbGVyUG9zdENvbW1pdEltcGwsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgICAgY29tbWl0U3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb25cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcHJldkVmZmVjdER1cmF0aW9uID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyBwcmV2RWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJiA0XG4gICAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogcHJldkVmZmVjdER1cmF0aW9uLl92aXNpYmlsaXR5ICYgNFxuICAgICAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiAoKHByZXZFZmZlY3REdXJhdGlvbi5fdmlzaWJpbGl0eSB8PSA0KSxcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoZmluaXNoZWRXb3JrLmFsdGVybmF0ZSwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBwYXJlbnRGaWJlcixcbiAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID1cbiAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAwICE9PSAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNTYpO1xuICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICApLFxuICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIFBhc3NpdmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyBfaW5zdGFuY2UyLl92aXNpYmlsaXR5ICYgNFxuICAgICAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogKChfaW5zdGFuY2UyLl92aXNpYmlsaXR5IHw9IDQpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGZpbmlzaGVkV29yay5hbHRlcm5hdGUsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QkanNjb21wJDAsXG4gICAgICBwYXJlbnRGaWJlclxuICAgICkge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICAgICAgICB2YXIgZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290JGpzY29tcCQwLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrID0gcGFyZW50RmliZXIsXG4gICAgICAgICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQocGFyZW50RmliZXIpIHtcbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnKVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgICAgYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIocGFyZW50RmliZXIpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyKGZpYmVyKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgZmliZXIuZmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnICYmXG4gICAgICAgICAgICAobnVsbCAhPT0gZmliZXIubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICA/IHN1c3BlbmRSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgZmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogc3VzcGVuZEluc3RhbmNlKGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgZmliZXIuZmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnICYmXG4gICAgICAgICAgICBzdXNwZW5kSW5zdGFuY2UoZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KFxuICAgICAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IHByZXZpb3VzSG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICB9IGVsc2UgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBudWxsID09PSBmaWJlci5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAoKHByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IGZpYmVyLmFsdGVybmF0ZSksXG4gICAgICAgICAgICBudWxsICE9PSBwcmV2aW91c0hvaXN0YWJsZVJvb3QgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHByZXZpb3VzSG9pc3RhYmxlUm9vdC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgID8gKChwcmV2aW91c0hvaXN0YWJsZVJvb3QgPSBzdXNwZW5zZXlDb21taXRGbGFnKSxcbiAgICAgICAgICAgICAgICAoc3VzcGVuc2V5Q29tbWl0RmxhZyA9IDE2Nzc3MjE2KSxcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpLFxuICAgICAgICAgICAgICAgIChzdXNwZW5zZXlDb21taXRGbGFnID0gcHJldmlvdXNIb2lzdGFibGVSb290KSlcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcikge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBwYXJlbnRGaWJlci5hbHRlcm5hdGU7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IHByZXZpb3VzRmliZXIgJiZcbiAgICAgICAgKChwYXJlbnRGaWJlciA9IHByZXZpb3VzRmliZXIuY2hpbGQpLCBudWxsICE9PSBwYXJlbnRGaWJlcilcbiAgICAgICkge1xuICAgICAgICBwcmV2aW91c0ZpYmVyLmNoaWxkID0gbnVsbDtcbiAgICAgICAgZG9cbiAgICAgICAgICAocHJldmlvdXNGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyLnNpYmxpbmcgPSBudWxsKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlciA9IHByZXZpb3VzRmliZXIpO1xuICAgICAgICB3aGlsZSAobnVsbCAhPT0gcGFyZW50RmliZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKHBhcmVudEZpYmVyKSB7XG4gICAgICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuICAgICAgaWYgKDAgIT09IChwYXJlbnRGaWJlci5mbGFncyAmIDE2KSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gZGVsZXRpb25zKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXTtcbiAgICAgICAgICAgIG5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihcbiAgICAgICAgICAgICAgY2hpbGRUb0RlbGV0ZSxcbiAgICAgICAgICAgICAgcGFyZW50RmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcik7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNTYpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIocGFyZW50RmliZXIpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihmaW5pc2hlZFdvcmspIHtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZpbmlzaGVkV29yay5mbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgUGFzc2l2ZSB8IEhhc0VmZmVjdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZhciBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICBidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgcHJldkVmZmVjdER1cmF0aW9uLl92aXNpYmlsaXR5ICYgNCAmJlxuICAgICAgICAgIChudWxsID09PSBmaW5pc2hlZFdvcmsucmV0dXJuIHx8IDEzICE9PSBmaW5pc2hlZFdvcmsucmV0dXJuLnRhZylcbiAgICAgICAgICAgID8gKChwcmV2RWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJj0gLTUpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yaykpXG4gICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG4gICAgICBpZiAoMCAhPT0gKHBhcmVudEZpYmVyLmZsYWdzICYgMTYpKSB7XG4gICAgICAgIGlmIChudWxsICE9PSBkZWxldGlvbnMpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldO1xuICAgICAgICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKFxuICAgICAgICAgICAgICBjaGlsZFRvRGVsZXRlLFxuICAgICAgICAgICAgICBwYXJlbnRGaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKTtcbiAgICAgIH1cbiAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgZGlzY29ubmVjdFBhc3NpdmVFZmZlY3QocGFyZW50RmliZXIpLFxuICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChmaW5pc2hlZFdvcmspIHtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICBQYXNzaXZlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpbnN0YW5jZS5fdmlzaWJpbGl0eSAmIDQgJiZcbiAgICAgICAgICAgICgoaW5zdGFuY2UuX3Zpc2liaWxpdHkgJj0gLTUpLFxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oXG4gICAgICBkZWxldGVkU3VidHJlZVJvb3QsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgKSB7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKSB7XG4gICAgICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3QsXG4gICAgICAgICAgY3VycmVudCA9IGZpYmVyO1xuICAgICAgICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIFBhc3NpdmVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLFxuICAgICAgICAgICAgICBudWxsICE9IGN1cnJlbnQgJiYgcmV0YWluQ2FjaGUoY3VycmVudCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgIHJlbGVhc2VDYWNoZShjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIChjdXJyZW50LnJldHVybiA9IGZpYmVyKSwgKG5leHRFZmZlY3QgPSBjdXJyZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGE6IGZvciAoZmliZXIgPSBkZWxldGVkU3VidHJlZVJvb3Q7IG51bGwgIT09IG5leHRFZmZlY3Q7ICkge1xuICAgICAgICAgICAgY3VycmVudCA9IG5leHRFZmZlY3Q7XG4gICAgICAgICAgICB2YXIgc2libGluZyA9IGN1cnJlbnQuc2libGluZyxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBjdXJyZW50LnJldHVybjtcbiAgICAgICAgICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IGZpYmVyKSB7XG4gICAgICAgICAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bGwgIT09IHNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgc2libGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0RWZmZWN0ID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpIHtcbiAgICAgIHZhciBtYXliZUZpYmVyID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShob3N0Um9vdCk7XG4gICAgICBpZiAobnVsbCAhPSBtYXliZUZpYmVyKSB7XG4gICAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2YgbWF5YmVGaWJlci5tZW1vaXplZFByb3BzW1wiZGF0YS10ZXN0bmFtZVwiXSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCBob3N0IHJvb3Qgc3BlY2lmaWVkLiBTaG91bGQgYmUgZWl0aGVyIGEgUmVhY3QgY29udGFpbmVyIG9yIGEgbm9kZSB3aXRoIGEgdGVzdG5hbWUgYXR0cmlidXRlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG1heWJlRmliZXI7XG4gICAgICB9XG4gICAgICBob3N0Um9vdCA9IGZpbmRGaWJlclJvb3QoaG9zdFJvb3QpO1xuICAgICAgaWYgKG51bGwgPT09IGhvc3RSb290KVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkNvdWxkIG5vdCBmaW5kIFJlYWN0IGNvbnRhaW5lciB3aXRoaW4gc3BlY2lmaWVkIGhvc3Qgc3VidHJlZS5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGhvc3RSb290LnN0YXRlTm9kZS5jdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXRjaFNlbGVjdG9yKGZpYmVyJGpzY29tcCQwLCBzZWxlY3Rvcikge1xuICAgICAgdmFyIHRhZyA9IGZpYmVyJGpzY29tcCQwLnRhZztcbiAgICAgIHN3aXRjaCAoc2VsZWN0b3IuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBDT01QT05FTlRfVFlQRTpcbiAgICAgICAgICBpZiAoZmliZXIkanNjb21wJDAudHlwZSA9PT0gc2VsZWN0b3IudmFsdWUpIHJldHVybiAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIQVNfUFNFVURPX0NMQVNTX1RZUEU6XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci52YWx1ZTtcbiAgICAgICAgICAgIGZpYmVyJGpzY29tcCQwID0gW2ZpYmVyJGpzY29tcCQwLCAwXTtcbiAgICAgICAgICAgIGZvciAodGFnID0gMDsgdGFnIDwgZmliZXIkanNjb21wJDAubGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgdmFyIGZpYmVyID0gZmliZXIkanNjb21wJDBbdGFnKytdLFxuICAgICAgICAgICAgICAgIHRhZyRqc2NvbXAkMCA9IGZpYmVyLnRhZyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvckluZGV4ID0gZmliZXIkanNjb21wJDBbdGFnKytdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yJGpzY29tcCQwID0gc2VsZWN0b3Jbc2VsZWN0b3JJbmRleF07XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoNSAhPT0gdGFnJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICAyNiAhPT0gdGFnJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICAyNyAhPT0gdGFnJGpzY29tcCQwKSB8fFxuICAgICAgICAgICAgICAgICFpc0hpZGRlblN1YnRyZWUoZmliZXIpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICBudWxsICE9IHNlbGVjdG9yJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICBtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvciRqc2NvbXAkMCk7XG5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBzZWxlY3RvckluZGV4KyssXG4gICAgICAgICAgICAgICAgICAgIChzZWxlY3RvciRqc2NvbXAkMCA9IHNlbGVjdG9yW3NlbGVjdG9ySW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3IubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIGZvciAoZmliZXIgPSBmaWJlci5jaGlsZDsgbnVsbCAhPT0gZmliZXI7IClcbiAgICAgICAgICAgICAgICAgICAgZmliZXIkanNjb21wJDAucHVzaChmaWJlciwgc2VsZWN0b3JJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgKGZpYmVyID0gZmliZXIuc2libGluZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdG9yID0gITE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgICAgY2FzZSBST0xFX1RZUEU6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKDUgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcpICYmXG4gICAgICAgICAgICBtYXRjaEFjY2Vzc2liaWxpdHlSb2xlKGZpYmVyJGpzY29tcCQwLnN0YXRlTm9kZSwgc2VsZWN0b3IudmFsdWUpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRFWFRfVFlQRTpcbiAgICAgICAgICBpZiAoNSA9PT0gdGFnIHx8IDYgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcpXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgoZmliZXIkanNjb21wJDAgPSBnZXRUZXh0Q29udGVudChmaWJlciRqc2NvbXAkMCkpLFxuICAgICAgICAgICAgICBudWxsICE9PSBmaWJlciRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgIDAgPD0gZmliZXIkanNjb21wJDAuaW5kZXhPZihzZWxlY3Rvci52YWx1ZSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBURVNUX05BTUVfVFlQRTpcbiAgICAgICAgICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChmaWJlciRqc2NvbXAkMCA9IGZpYmVyJGpzY29tcCQwLm1lbW9pemVkUHJvcHNbXCJkYXRhLXRlc3RuYW1lXCJdKSxcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGZpYmVyJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgZmliZXIkanNjb21wJDAudG9Mb3dlckNhc2UoKSA9PT0gc2VsZWN0b3IudmFsdWUudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciB0eXBlIHNwZWNpZmllZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpIHtcbiAgICAgIHN3aXRjaCAoc2VsZWN0b3IuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBDT01QT05FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHNlbGVjdG9yLnZhbHVlKSB8fCBcIlVua25vd25cIikgKyBcIj5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSEFTX1BTRVVET19DTEFTU19UWVBFOlxuICAgICAgICAgIHJldHVybiBcIjpoYXMoXCIgKyAoc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcikgfHwgXCJcIikgKyBcIilcIjtcbiAgICAgICAgY2FzZSBST0xFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuICdbcm9sZT1cIicgKyBzZWxlY3Rvci52YWx1ZSArICdcIl0nO1xuICAgICAgICBjYXNlIFRFWFRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ1wiJyArIHNlbGVjdG9yLnZhbHVlICsgJ1wiJztcbiAgICAgICAgY2FzZSBURVNUX05BTUVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ1tkYXRhLXRlc3RuYW1lPVwiJyArIHNlbGVjdG9yLnZhbHVlICsgJ1wiXSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZFBhdGhzKHJvb3QsIHNlbGVjdG9ycykge1xuICAgICAgdmFyIG1hdGNoaW5nRmliZXJzID0gW107XG4gICAgICByb290ID0gW3Jvb3QsIDBdO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHJvb3QubGVuZ3RoOyApIHtcbiAgICAgICAgdmFyIGZpYmVyID0gcm9vdFtpbmRleCsrXSxcbiAgICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgICAgc2VsZWN0b3JJbmRleCA9IHJvb3RbaW5kZXgrK10sXG4gICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoNSAhPT0gdGFnICYmIDI2ICE9PSB0YWcgJiYgMjcgIT09IHRhZykgfHxcbiAgICAgICAgICAhaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKVxuICAgICAgICApIHtcbiAgICAgICAgICBmb3IgKDsgbnVsbCAhPSBzZWxlY3RvciAmJiBtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3Rvcik7IClcbiAgICAgICAgICAgIHNlbGVjdG9ySW5kZXgrKywgKHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdKTtcbiAgICAgICAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3JzLmxlbmd0aCkgbWF0Y2hpbmdGaWJlcnMucHVzaChmaWJlcik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChmaWJlciA9IGZpYmVyLmNoaWxkOyBudWxsICE9PSBmaWJlcjsgKVxuICAgICAgICAgICAgICByb290LnB1c2goZmliZXIsIHNlbGVjdG9ySW5kZXgpLCAoZmliZXIgPSBmaWJlci5zaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoaW5nRmliZXJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICAgICAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpXG4gICAgICAgIHRocm93IEVycm9yKFwiVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLlwiKTtcbiAgICAgIGhvc3RSb290ID0gZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KTtcbiAgICAgIGhvc3RSb290ID0gZmluZFBhdGhzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuICAgICAgc2VsZWN0b3JzID0gW107XG4gICAgICBob3N0Um9vdCA9IEFycmF5LmZyb20oaG9zdFJvb3QpO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGhvc3RSb290Lmxlbmd0aDsgKSB7XG4gICAgICAgIHZhciBub2RlID0gaG9zdFJvb3RbaW5kZXgrK10sXG4gICAgICAgICAgdGFnID0gbm9kZS50YWc7XG4gICAgICAgIGlmICg1ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnKVxuICAgICAgICAgIGlzSGlkZGVuU3VidHJlZShub2RlKSB8fCBzZWxlY3RvcnMucHVzaChub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKG5vZGUgPSBub2RlLmNoaWxkOyBudWxsICE9PSBub2RlOyApXG4gICAgICAgICAgICBob3N0Um9vdC5wdXNoKG5vZGUpLCAobm9kZSA9IG5vZGUuc2libGluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0b3JzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkNvbW1pdFJvb3QoKSB7XG4gICAgICBzdXBwb3J0c1Rlc3RTZWxlY3RvcnMgJiZcbiAgICAgICAgY29tbWl0SG9va3MuZm9yRWFjaChmdW5jdGlvbiAoY29tbWl0SG9vaykge1xuICAgICAgICAgIHJldHVybiBjb21taXRIb29rKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpIHtcbiAgICAgIHZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgPVxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UXG4gICAgICAgICAgPyBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlRcbiAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCB8fFxuICAgICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSB8fFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIGN1cnJlbnQgdGVzdGluZyBlbnZpcm9ubWVudCBpcyBub3QgY29uZmlndXJlZCB0byBzdXBwb3J0IGFjdCguLi4pXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dCAmJlxuICAgICAgICAwICE9PSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgKVxuICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiAtd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gdHJhbnNpdGlvblxuICAgICAgICA/ICh0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzIHx8ICh0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpKSxcbiAgICAgICAgICB0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmFkZChmaWJlciksXG4gICAgICAgICAgKGZpYmVyID0gY3VycmVudEVudGFuZ2xlZExhbmUpLFxuICAgICAgICAgIDAgIT09IGZpYmVyID8gZmliZXIgOiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKSlcbiAgICAgICAgOiByZXNvbHZlVXBkYXRlUHJpb3JpdHkoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdERlZmVycmVkTGFuZSgpIHtcbiAgICAgIDAgPT09IHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9XG4gICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNTM2ODcwOTEyKSB8fCBpc0h5ZHJhdGluZ1xuICAgICAgICAgICAgPyBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpXG4gICAgICAgICAgICA6IDUzNjg3MDkxMik7XG4gICAgICB2YXIgc3VzcGVuc2VIYW5kbGVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgIG51bGwgIT09IHN1c3BlbnNlSGFuZGxlciAmJiAoc3VzcGVuc2VIYW5kbGVyLmZsYWdzIHw9IDMyKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKSB7XG4gICAgICBpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcInVzZUluc2VydGlvbkVmZmVjdCBtdXN0IG5vdCBzY2hlZHVsZSB1cGRhdGVzLlwiKTtcbiAgICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyAmJiAoZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9ICEwKTtcbiAgICAgIGlmIChcbiAgICAgICAgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGEpIHx8XG4gICAgICAgIG51bGwgIT09IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdFxuICAgICAgKVxuICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKSxcbiAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgITFcbiAgICAgICAgICApO1xuICAgICAgbWFya1Jvb3RVcGRhdGVkJDEocm9vdCwgbGFuZSk7XG4gICAgICBpZiAoXG4gICAgICAgIDAgIT09IChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgJiZcbiAgICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290XG4gICAgICApIHtcbiAgICAgICAgaWYgKGlzUmVuZGVyaW5nKVxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgcm9vdCA9XG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzICYmIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpKSB8fFxuICAgICAgICAgICAgICAgIFwiVW5rbm93blwiO1xuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQuaGFzKHJvb3QpIHx8XG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5hZGQocm9vdCksXG4gICAgICAgICAgICAgICAgKGZpYmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJVbmtub3duXCIpLFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNhbm5vdCB1cGRhdGUgYSBjb21wb25lbnQgKGAlc2ApIHdoaWxlIHJlbmRlcmluZyBhIGRpZmZlcmVudCBjb21wb25lbnQgKGAlc2ApLiBUbyBsb2NhdGUgdGhlIGJhZCBzZXRTdGF0ZSgpIGNhbGwgaW5zaWRlIGAlc2AsIGZvbGxvdyB0aGUgc3RhY2sgdHJhY2UgYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc2V0c3RhdGUtaW4tcmVuZGVyXCIsXG4gICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICByb290XG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciB8fFxuICAgICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiBgcmVuZGVyYCkuIFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLlwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgPSAhMCkpO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgZmliZXIsIGxhbmUpLFxuICAgICAgICAgIHdhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFVihmaWJlciksXG4gICAgICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmXG4gICAgICAgICAgICAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0ICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyB8PSBsYW5lKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgJiZcbiAgICAgICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGxhbmVzLCBmb3JjZVN5bmMpIHtcbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpXG4gICAgICAgIHRocm93IEVycm9yKFwiU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuXCIpO1xuICAgICAgdmFyIHNob3VsZFRpbWVTbGljZSA9XG4gICAgICAgICAgKCFmb3JjZVN5bmMgJiZcbiAgICAgICAgICAgIDAgPT09IChsYW5lcyAmIDYwKSAmJlxuICAgICAgICAgICAgMCA9PT0gKGxhbmVzICYgcm9vdC5leHBpcmVkTGFuZXMpKSB8fFxuICAgICAgICAgIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgbGFuZXMpLFxuICAgICAgICBleGl0U3RhdHVzID0gc2hvdWxkVGltZVNsaWNlXG4gICAgICAgICAgPyByZW5kZXJSb290Q29uY3VycmVudChyb290LCBsYW5lcylcbiAgICAgICAgICA6IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzLCAhMCksXG4gICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSBzaG91bGRUaW1lU2xpY2U7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcykge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nICYmXG4gICAgICAgICAgICAhc2hvdWxkVGltZVNsaWNlICYmXG4gICAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgMCwgITEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3REaWROb3RDb21wbGV0ZSlcbiAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAhd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yY2VTeW5jID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ICYmXG4gICAgICAgICAgICAhaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZvcmNlU3luYylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcywgITEpO1xuICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9ICExO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9IGxhbmVzO1xuICAgICAgICAgICAgaWYgKHJvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgJiByZW5kZXJXYXNDb25jdXJyZW50KVxuICAgICAgICAgICAgICB2YXIgZXJyb3JSZXRyeUxhbmVzID0gMDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgKGVycm9yUmV0cnlMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzICYgLTUzNjg3MDkxMyksXG4gICAgICAgICAgICAgICAgKGVycm9yUmV0cnlMYW5lcyA9XG4gICAgICAgICAgICAgICAgICAwICE9PSBlcnJvclJldHJ5TGFuZXNcbiAgICAgICAgICAgICAgICAgICAgPyBlcnJvclJldHJ5TGFuZXNcbiAgICAgICAgICAgICAgICAgICAgOiBlcnJvclJldHJ5TGFuZXMgJiA1MzY4NzA5MTJcbiAgICAgICAgICAgICAgICAgICAgICA/IDUzNjg3MDkxMlxuICAgICAgICAgICAgICAgICAgICAgIDogMCk7XG4gICAgICAgICAgICBpZiAoMCAhPT0gZXJyb3JSZXRyeUxhbmVzKSB7XG4gICAgICAgICAgICAgIGxhbmVzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgZXhpdFN0YXR1cyA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMCA9IGVycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgICAgICBlcnJvclJldHJ5TGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzO1xuICAgICAgICAgICAgICAgIHZhciB3YXNSb290RGVoeWRyYXRlZCA9XG4gICAgICAgICAgICAgICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cy5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkO1xuICAgICAgICAgICAgICAgIHdhc1Jvb3REZWh5ZHJhdGVkICYmXG4gICAgICAgICAgICAgICAgICAocHJlcGFyZUZyZXNoU3RhY2soXG4gICAgICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgKS5mbGFncyB8PSAyNTYpO1xuICAgICAgICAgICAgICAgIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMCA9IHJlbmRlclJvb3RTeW5jKFxuICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwICE9PSBSb290RXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgIXdhc1Jvb3REZWh5ZHJhdGVkXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cy5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyB8PVxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIHw9XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBleGl0U3RhdHVzID0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGVycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGV4aXRTdGF0dXMgJiYgcXVldWVSZWNvdmVyYWJsZUVycm9ycyhleGl0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhpdFN0YXR1cyA9IGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gITE7XG4gICAgICAgICAgICAgIGlmIChleGl0U3RhdHVzICE9PSBSb290RXJyb3JlZCkgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RmF0YWxFcnJvcmVkKSB7XG4gICAgICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKTtcbiAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCAwLCAhMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlID0gcm9vdDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXhpdFN0YXR1cykge1xuICAgICAgICAgICAgICBjYXNlIFJvb3RJblByb2dyZXNzOlxuICAgICAgICAgICAgICBjYXNlIFJvb3RGYXRhbEVycm9yZWQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJSb290IGRpZCBub3QgY29tcGxldGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgICAgICAgICBjYXNlIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk6XG4gICAgICAgICAgICAgICAgaWYgKChsYW5lcyAmIDQxOTQxNzYpID09PSBsYW5lcykge1xuICAgICAgICAgICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgICAgICAhd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgUm9vdEVycm9yZWQ6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFJvb3RTdXNwZW5kZWQ6XG4gICAgICAgICAgICAgIGNhc2UgUm9vdENvbXBsZXRlZDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gcm9vdCBleGl0IHN0YXR1cy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UuZmluaXNoZWRXb3JrID0gZm9yY2VTeW5jO1xuICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSlcbiAgICAgICAgICAgICAgY29tbWl0Um9vdChcbiAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgICAgICBJTU1FRElBVEVfQ09NTUlULFxuICAgICAgICAgICAgICAgIC0wLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGxhbmVzICYgNjI5MTQ1NjApID09PSBsYW5lcyAmJlxuICAgICAgICAgICAgICAgICgoZXhpdFN0YXR1cyA9XG4gICAgICAgICAgICAgICAgICBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lICtcbiAgICAgICAgICAgICAgICAgIEZBTExCQUNLX1RIUk9UVExFX01TIC1cbiAgICAgICAgICAgICAgICAgIG5vdyQxKCkpLFxuICAgICAgICAgICAgICAgIDEwIDwgZXhpdFN0YXR1cylcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgICAgIXdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKDAgIT09IGdldE5leHRMYW5lcyhzaG91bGRUaW1lU2xpY2UsIDApKSBicmVhayBhO1xuICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZS50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgY29tbWl0Um9vdFdoZW5SZWFkeS5iaW5kKFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlU3luYyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzLFxuICAgICAgICAgICAgICAgICAgICBUSFJPVFRMRURfQ09NTUlULFxuICAgICAgICAgICAgICAgICAgICAtMCxcbiAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIGV4aXRTdGF0dXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29tbWl0Um9vdFdoZW5SZWFkeShcbiAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgZm9yY2VTeW5jLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzLFxuICAgICAgICAgICAgICAgIElNTUVESUFURV9DT01NSVQsXG4gICAgICAgICAgICAgICAgLTAsXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGVycm9ycykge1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnNcbiAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBlcnJvcnMpXG4gICAgICAgIDogd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMucHVzaC5hcHBseShcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Um9vdFdoZW5SZWFkeShcbiAgICAgIHJvb3QsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgbGFuZXMsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICBkaWRTa2lwU3VzcGVuZGVkU2libGluZ3MsXG4gICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgKSB7XG4gICAgICB2YXIgc3VidHJlZUZsYWdzID0gZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncztcbiAgICAgIGlmIChzdWJ0cmVlRmxhZ3MgJiA4MTkyIHx8IDE2Nzg1NDA4ID09PSAoc3VidHJlZUZsYWdzICYgMTY3ODU0MDgpKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKHN0YXJ0U3VzcGVuZGluZ0NvbW1pdCgpLFxuICAgICAgICAgIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyKGZpbmlzaGVkV29yayksXG4gICAgICAgICAgKGZpbmlzaGVkV29yayA9IHdhaXRGb3JDb21taXRUb0JlUmVhZHkoKSksXG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrKVxuICAgICAgICApIHtcbiAgICAgICAgICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBmaW5pc2hlZFdvcmsoXG4gICAgICAgICAgICBjb21taXRSb290LmJpbmQoXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgICB0cmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgICAgICBTVVNQRU5ERURfQ09NTUlULFxuICAgICAgICAgICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICAgICAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgc3Bhd25lZExhbmUsXG4gICAgICAgICAgICAhZGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNvbW1pdFJvb3QoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICB0cmFuc2l0aW9ucyxcbiAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgICAgIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZpbmlzaGVkV29yaykge1xuICAgICAgZm9yICh2YXIgbm9kZSA9IGZpbmlzaGVkV29yazsgOyApIHtcbiAgICAgICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKDAgPT09IHRhZyB8fCAxMSA9PT0gdGFnIHx8IDE1ID09PSB0YWcpICYmXG4gICAgICAgICAgbm9kZS5mbGFncyAmIDE2Mzg0ICYmXG4gICAgICAgICAgKCh0YWcgPSBub2RlLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICBudWxsICE9PSB0YWcgJiYgKCh0YWcgPSB0YWcuc3RvcmVzKSwgbnVsbCAhPT0gdGFnKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hlY2sgPSB0YWdbaV0sXG4gICAgICAgICAgICAgIGdldFNuYXBzaG90ID0gY2hlY2suZ2V0U25hcHNob3Q7XG4gICAgICAgICAgICBjaGVjayA9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFvYmplY3RJcyhnZXRTbmFwc2hvdCgpLCBjaGVjaykpIHJldHVybiAhMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIHRhZyA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGlmIChub2RlLnN1YnRyZWVGbGFncyAmIDE2Mzg0ICYmIG51bGwgIT09IHRhZylcbiAgICAgICAgICAodGFnLnJldHVybiA9IG5vZGUpLCAobm9kZSA9IHRhZyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIGJyZWFrO1xuICAgICAgICAgIGZvciAoOyBudWxsID09PSBub2RlLnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IG5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBmaW5pc2hlZFdvcmspIHJldHVybiAhMDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICByb290LFxuICAgICAgc3VzcGVuZGVkTGFuZXMsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIGRpZEF0dGVtcHRFbnRpcmVUcmVlXG4gICAgKSB7XG4gICAgICBzdXNwZW5kZWRMYW5lcyAmPSB+d29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXM7XG4gICAgICBzdXNwZW5kZWRMYW5lcyAmPSB+d29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXM7XG4gICAgICByb290LnN1c3BlbmRlZExhbmVzIHw9IHN1c3BlbmRlZExhbmVzO1xuICAgICAgcm9vdC5waW5nZWRMYW5lcyAmPSB+c3VzcGVuZGVkTGFuZXM7XG4gICAgICBkaWRBdHRlbXB0RW50aXJlVHJlZSAmJiAocm9vdC53YXJtTGFuZXMgfD0gc3VzcGVuZGVkTGFuZXMpO1xuICAgICAgZGlkQXR0ZW1wdEVudGlyZVRyZWUgPSByb290LmV4cGlyYXRpb25UaW1lcztcbiAgICAgIGZvciAodmFyIGxhbmVzID0gc3VzcGVuZGVkTGFuZXM7IDAgPCBsYW5lczsgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICBkaWRBdHRlbXB0RW50aXJlVHJlZVtpbmRleF0gPSAtMTtcbiAgICAgICAgbGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgICAwICE9PSBzcGF3bmVkTGFuZSAmJlxuICAgICAgICBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgc3VzcGVuZGVkTGFuZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN5bmNXb3JrKCkge1xuICAgICAgcmV0dXJuIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dFxuICAgICAgICA/IChmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSksICExKVxuICAgICAgICA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKSB7XG4gICAgICBpZiAobnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBOb3RTdXNwZW5kZWQpXG4gICAgICAgICAgdmFyIGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIChpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKSxcbiAgICAgICAgICAgIHJlc2V0SG9va3NPblVud2luZChpbnRlcnJ1cHRlZFdvcmspLFxuICAgICAgICAgICAgKHRoZW5hYmxlU3RhdGUkMSA9IG51bGwpLFxuICAgICAgICAgICAgKHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwKSxcbiAgICAgICAgICAgIChpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGZvciAoOyBudWxsICE9PSBpbnRlcnJ1cHRlZFdvcms7IClcbiAgICAgICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrLmFsdGVybmF0ZSwgaW50ZXJydXB0ZWRXb3JrKSxcbiAgICAgICAgICAgIChpbnRlcnJ1cHRlZFdvcmsgPSBpbnRlcnJ1cHRlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcykge1xuICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgcm9vdC5maW5pc2hlZExhbmVzID0gMDtcbiAgICAgIHZhciB0aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuICAgICAgdGltZW91dEhhbmRsZSAhPT0gbm9UaW1lb3V0ICYmXG4gICAgICAgICgocm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0KSwgY2FuY2VsVGltZW91dCh0aW1lb3V0SGFuZGxlKSk7XG4gICAgICB0aW1lb3V0SGFuZGxlID0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0O1xuICAgICAgbnVsbCAhPT0gdGltZW91dEhhbmRsZSAmJlxuICAgICAgICAoKHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCA9IG51bGwpLCB0aW1lb3V0SGFuZGxlKCkpO1xuICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB0aW1lb3V0SGFuZGxlID0gY3JlYXRlV29ya0luUHJvZ3Jlc3Mocm9vdC5jdXJyZW50LCBudWxsKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gbGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyA9IGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgbGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3M7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPVxuICAgICAgICAgIDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPVxuICAgICAgICBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSA9ICExO1xuICAgICAgMCAhPT0gKGxhbmVzICYgOCkgJiYgKGxhbmVzIHw9IGxhbmVzICYgMzIpO1xuICAgICAgdmFyIGFsbEVudGFuZ2xlZExhbmVzID0gcm9vdC5lbnRhbmdsZWRMYW5lcztcbiAgICAgIGlmICgwICE9PSBhbGxFbnRhbmdsZWRMYW5lcylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICByb290ID0gcm9vdC5lbnRhbmdsZW1lbnRzLCBhbGxFbnRhbmdsZWRMYW5lcyAmPSBsYW5lcztcbiAgICAgICAgICAwIDwgYWxsRW50YW5nbGVkTGFuZXM7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihhbGxFbnRhbmdsZWRMYW5lcyksXG4gICAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgICAgICBsYW5lcyB8PSByb290W2luZGV4XTtcbiAgICAgICAgICBhbGxFbnRhbmdsZWRMYW5lcyAmPSB+bGFuZTtcbiAgICAgICAgfVxuICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSBsYW5lcztcbiAgICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmRpc2NhcmRQZW5kaW5nV2FybmluZ3MoKTtcbiAgICAgIHJldHVybiB0aW1lb3V0SGFuZGxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSkge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcbiAgICAgIGlzUmVuZGVyaW5nID0gITE7XG4gICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgIHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICA/ICgodGhyb3duVmFsdWUgPSBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBTdXNwZW5kZWRPbkltbWVkaWF0ZSkpXG4gICAgICAgIDogdGhyb3duVmFsdWUgPT09IFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvblxuICAgICAgICAgID8gKCh0aHJvd25WYWx1ZSA9IGdldFN1c3BlbmRlZFRoZW5hYmxlKCkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkT25JbnN0YW5jZSkpXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPVxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgPyBTdXNwZW5kZWRPbkh5ZHJhdGlvblxuICAgICAgICAgICAgICAgIDogbnVsbCAhPT0gdGhyb3duVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHRocm93blZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHRocm93blZhbHVlLnRoZW5cbiAgICAgICAgICAgICAgICAgID8gU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlXG4gICAgICAgICAgICAgICAgICA6IFN1c3BlbmRlZE9uRXJyb3IpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IHRocm93blZhbHVlO1xuICAgICAgdmFyIGVycm9yZWRXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBpZiAobnVsbCA9PT0gZXJyb3JlZFdvcmspXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZCksXG4gICAgICAgICAgbG9nVW5jYXVnaHRFcnJvcihcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih0aHJvd25WYWx1ZSwgcm9vdC5jdXJyZW50KVxuICAgICAgICAgICk7XG4gICAgICBlbHNlXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKGVycm9yZWRXb3JrLm1vZGUgJiAyICYmXG4gICAgICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZER1cmF0aW9uKGVycm9yZWRXb3JrKSxcbiAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRXJyb3I6XG4gICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50RXJyb3JlZCAmJlxuICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkKFxuICAgICAgICAgICAgICAgIGVycm9yZWRXb3JrLFxuICAgICAgICAgICAgICAgIHRocm93blZhbHVlLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGF0YTpcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW1tZWRpYXRlOlxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlOlxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlOlxuICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFN1c3BlbmRlZCAmJlxuICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQoXG4gICAgICAgICAgICAgICAgZXJyb3JlZFdvcmssXG4gICAgICAgICAgICAgICAgdGhyb3duVmFsdWUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuKCkge1xuICAgICAgdmFyIGhhbmRsZXIgPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50O1xuICAgICAgcmV0dXJuIG51bGwgPT09IGhhbmRsZXJcbiAgICAgICAgPyAhMFxuICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDQxOTQxNzYpID09PVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICA/IG51bGwgPT09IHNoZWxsQm91bmRhcnlcbiAgICAgICAgICAgID8gITBcbiAgICAgICAgICAgIDogITFcbiAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDYyOTE0NTYwKSA9PT1cbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyB8fFxuICAgICAgICAgICAgICAwICE9PSAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpXG4gICAgICAgICAgICA/IGhhbmRsZXIgPT09IHNoZWxsQm91bmRhcnlcbiAgICAgICAgICAgIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hEaXNwYXRjaGVyKCkge1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gcHJldkRpc3BhdGNoZXIgPyBDb250ZXh0T25seURpc3BhdGNoZXIgOiBwcmV2RGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEFzeW5jRGlzcGF0Y2hlcigpIHtcbiAgICAgIHZhciBwcmV2QXN5bmNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyO1xuICAgICAgcmV0dXJuIHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyB8fFxuICAgICAgICAoKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNDE5NDE3NikgIT09XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICBudWxsICE9PSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50KSB8fFxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSAhMCk7XG4gICAgICAoMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyAmIDEzNDIxNzcyNykgJiZcbiAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzICYgMTM0MjE3NzI3KSkgfHxcbiAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290IHx8XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcywgc2hvdWxkWWllbGRGb3JQcmVyZW5kZXJpbmcpIHtcbiAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpLFxuICAgICAgICBwcmV2QXN5bmNEaXNwYXRjaGVyID0gcHVzaEFzeW5jRGlzcGF0Y2hlcigpO1xuICAgICAgaWYgKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICAgICAgMCA8IG1lbW9pemVkVXBkYXRlcnMuc2l6ZSAmJlxuICAgICAgICAgICAgKHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpKTtcbiAgICAgICAgICBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsO1xuICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gICAgICB9XG4gICAgICBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gICAgICBsYW5lcyA9ICExO1xuICAgICAgbWVtb2l6ZWRVcGRhdGVycyA9IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG4gICAgICBhOiBkb1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uICE9PSBOb3RTdXNwZW5kZWQgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgdW5pdE9mV29yayA9IHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9IHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSB7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25IeWRyYXRpb246XG4gICAgICAgICAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW1tZWRpYXRlOlxuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGF0YTpcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2U6XG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCAmJiAobGFuZXMgPSAhMCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgc2hvdWxkWWllbGRGb3JQcmVyZW5kZXJpbmcgJiZcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gUm9vdEluUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAocmVhc29uID0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlLCByZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrTG9vcFN5bmMoKTtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUkNCkge1xuICAgICAgICAgIGhhbmRsZVRocm93KHJvb3QsIHRocm93blZhbHVlJDQpO1xuICAgICAgICB9XG4gICAgICB3aGlsZSAoMSk7XG4gICAgICBsYW5lcyAmJiByb290LnNoZWxsU3VzcGVuZENvdW50ZXIrKztcbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gICAgICBtYXJrUmVuZGVyU3RvcHBlZCgpO1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCksXG4gICAgICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSk7XG4gICAgICByZXR1cm4gbWVtb2l6ZWRVcGRhdGVycztcbiAgICB9XG4gICAgZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuICAgICAgZm9yICg7IG51bGwgIT09IHdvcmtJblByb2dyZXNzOyApIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpIHtcbiAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpLFxuICAgICAgICBwcmV2QXN5bmNEaXNwYXRjaGVyID0gcHVzaEFzeW5jRGlzcGF0Y2hlcigpO1xuICAgICAgaWYgKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICAgICAgMCA8IG1lbW9pemVkVXBkYXRlcnMuc2l6ZSAmJlxuICAgICAgICAgICAgKHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpKTtcbiAgICAgICAgICBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gbm93JDEoKSArIFJFTkRFUl9USU1FT1VUX01TO1xuICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKFxuICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgbGFuZXNcbiAgICAgICAgKTtcbiAgICAgIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgICAgIGE6IGRvXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gIT09IE5vdFN1c3BlbmRlZCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApXG4gICAgICAgICAgICBiOiBzd2l0Y2ggKFxuICAgICAgICAgICAgICAoKGxhbmVzID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAobWVtb2l6ZWRVcGRhdGVycyA9IHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRXJyb3I6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICBTdXNwZW5kZWRPbkVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRhdGE6XG4gICAgICAgICAgICAgICAgaWYgKGlzVGhlbmFibGVSZXNvbHZlZChtZW1vaXplZFVwZGF0ZXJzKSkge1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsobGFuZXMpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID1cbiAgICAgICAgICAgICAgICAgICAgICBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWUpO1xuICAgICAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy50aGVuKGxhbmVzLCBsYW5lcyk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkltbWVkaWF0ZTpcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW5zdGFuY2U6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPVxuICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTpcbiAgICAgICAgICAgICAgICBpc1RoZW5hYmxlUmVzb2x2ZWQobWVtb2l6ZWRVcGRhdGVycylcbiAgICAgICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZCksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsobGFuZXMpKVxuICAgICAgICAgICAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWU6XG4gICAgICAgICAgICAgICAgdmFyIHJlc291cmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RGaWJlciA9IHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBob3N0RmliZXIudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IGhvc3RGaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwcmVsb2FkUmVzb3VyY2UocmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHByZWxvYWRJbnN0YW5jZSh0eXBlLCBwcm9wcylcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSBob3N0RmliZXIuc2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gc2libGluZykgd29ya0luUHJvZ3Jlc3MgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaG9zdEZpYmVyLnJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVVuaXRPZldvcmsocmV0dXJuRmliZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcyA9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgdHlwZSBvZiBmaWJlciB0cmlnZ2VyZWQgYSBzdXNwZW5zZXkgY29tbWl0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3AoXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLFxuICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlOlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3AoXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLFxuICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkh5ZHJhdGlvbjpcbiAgICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdERpZE5vdENvbXBsZXRlO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgU3VzcGVuZGVkUmVhc29uLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZVxuICAgICAgICAgICAgPyB3b3JrTG9vcFN5bmMoKVxuICAgICAgICAgICAgOiB3b3JrTG9vcENvbmN1cnJlbnQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUkNSkge1xuICAgICAgICAgIGhhbmRsZVRocm93KHJvb3QsIHRocm93blZhbHVlJDUpO1xuICAgICAgICB9XG4gICAgICB3aGlsZSAoMSk7XG4gICAgICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBwcmV2QXN5bmNEaXNwYXRjaGVyO1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICAgICAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlcllpZWxkZWQgJiZcbiAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlcllpZWxkZWQoKSxcbiAgICAgICAgICBSb290SW5Qcm9ncmVzc1xuICAgICAgICApO1xuICAgICAgbWFya1JlbmRlclN0b3BwZWQoKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IDA7XG4gICAgICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgICB9XG4gICAgZnVuY3Rpb24gd29ya0xvb3BDb25jdXJyZW50KCkge1xuICAgICAgZm9yICg7IG51bGwgIT09IHdvcmtJblByb2dyZXNzICYmICFzaG91bGRZaWVsZCgpOyApXG4gICAgICAgIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAgICAgdmFyIGN1cnJlbnQgPSB1bml0T2ZXb3JrLmFsdGVybmF0ZTtcbiAgICAgICh1bml0T2ZXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlXG4gICAgICAgID8gKHN0YXJ0UHJvZmlsZXJUaW1lcih1bml0T2ZXb3JrKSxcbiAgICAgICAgICAoY3VycmVudCA9IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIGJlZ2luV29yayxcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXNcbiAgICAgICAgICApKSxcbiAgICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZER1cmF0aW9uKHVuaXRPZldvcmspKVxuICAgICAgICA6IChjdXJyZW50ID0gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgYmVnaW5Xb3JrLFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lc1xuICAgICAgICAgICkpO1xuICAgICAgdW5pdE9mV29yay5tZW1vaXplZFByb3BzID0gdW5pdE9mV29yay5wZW5kaW5nUHJvcHM7XG4gICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgID8gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspXG4gICAgICAgIDogKHdvcmtJblByb2dyZXNzID0gY3VycmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAgICAgdmFyIG5leHQgPSBydW5XaXRoRmliZXJJbkRFVih1bml0T2ZXb3JrLCByZXBsYXlCZWdpbldvcmssIHVuaXRPZldvcmspO1xuICAgICAgdW5pdE9mV29yay5tZW1vaXplZFByb3BzID0gdW5pdE9mV29yay5wZW5kaW5nUHJvcHM7XG4gICAgICBudWxsID09PSBuZXh0ID8gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIDogKHdvcmtJblByb2dyZXNzID0gbmV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxheUJlZ2luV29yayh1bml0T2ZXb3JrKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHVuaXRPZldvcmsuYWx0ZXJuYXRlLFxuICAgICAgICBpc1Byb2ZpbGluZ01vZGUgPSAodW5pdE9mV29yay5tb2RlICYgMikgIT09IE5vTW9kZTtcbiAgICAgIGlzUHJvZmlsaW5nTW9kZSAmJiBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgICBzd2l0Y2ggKHVuaXRPZldvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjdXJyZW50ID0gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIHVuaXRPZldvcmsucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgdW5pdE9mV29yay50eXBlLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGN1cnJlbnQgPSByZXBsYXlGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgdW5pdE9mV29yay5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLnR5cGUucmVuZGVyLFxuICAgICAgICAgICAgdW5pdE9mV29yay5yZWYsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXNldEhvb2tzT25VbndpbmQodW5pdE9mV29yayk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIHVuaXRPZldvcmspLFxuICAgICAgICAgICAgKHVuaXRPZldvcmsgPSB3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3ModW5pdE9mV29yaywgZW50YW5nbGVkUmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgIChjdXJyZW50ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHVuaXRPZldvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKSk7XG4gICAgICB9XG4gICAgICBpc1Byb2ZpbGluZ01vZGUgJiZcbiAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREdXJhdGlvbih1bml0T2ZXb3JrKTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0FuZFVud2luZFdvcmtMb29wKFxuICAgICAgcm9vdCxcbiAgICAgIHVuaXRPZldvcmssXG4gICAgICB0aHJvd25WYWx1ZSxcbiAgICAgIHN1c3BlbmRlZFJlYXNvblxuICAgICkge1xuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICByZXNldEhvb2tzT25VbndpbmQodW5pdE9mV29yayk7XG4gICAgICB0aGVuYWJsZVN0YXRlJDEgPSBudWxsO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDA7XG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSB1bml0T2ZXb3JrLnJldHVybjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aHJvd0V4Y2VwdGlvbihcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICB0aHJvd25WYWx1ZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZDtcbiAgICAgICAgICBsb2dVbmNhdWdodEVycm9yKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHRocm93blZhbHVlLCByb290LmN1cnJlbnQpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAobnVsbCAhPT0gcmV0dXJuRmliZXIpIHRocm93ICgod29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlciksIGVycm9yKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQ7XG4gICAgICAgIGxvZ1VuY2F1Z2h0RXJyb3IoXG4gICAgICAgICAgcm9vdCxcbiAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih0aHJvd25WYWx1ZSwgcm9vdC5jdXJyZW50KVxuICAgICAgICApO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh1bml0T2ZXb3JrLmZsYWdzICYgMzI3NjgpIHtcbiAgICAgICAgaWYgKGlzSHlkcmF0aW5nIHx8IHN1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25FcnJvcikgcm9vdCA9ICEwO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyB8fFxuICAgICAgICAgIDAgIT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDUzNjg3MDkxMilcbiAgICAgICAgKVxuICAgICAgICAgIHJvb3QgPSAhMTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MgPSByb290ID0gITApLFxuICAgICAgICAgIHN1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhIHx8XG4gICAgICAgICAgICBzdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uSW1tZWRpYXRlIHx8XG4gICAgICAgICAgICBzdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZSlcbiAgICAgICAgKVxuICAgICAgICAgIChzdXNwZW5kZWRSZWFzb24gPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgICAgIG51bGwgIT09IHN1c3BlbmRlZFJlYXNvbiAmJlxuICAgICAgICAgICAgICAxMyA9PT0gc3VzcGVuZGVkUmVhc29uLnRhZyAmJlxuICAgICAgICAgICAgICAoc3VzcGVuZGVkUmVhc29uLmZsYWdzIHw9IDE2Mzg0KTtcbiAgICAgICAgdW53aW5kVW5pdE9mV29yayh1bml0T2ZXb3JrLCByb290KTtcbiAgICAgIH0gZWxzZSBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gICAgICB2YXIgY29tcGxldGVkV29yayA9IHVuaXRPZldvcms7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgwICE9PSAoY29tcGxldGVkV29yay5mbGFncyAmIDMyNzY4KSkge1xuICAgICAgICAgIHVud2luZFVuaXRPZldvcmsoXG4gICAgICAgICAgICBjb21wbGV0ZWRXb3JrLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnQgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgICAgdW5pdE9mV29yayA9IGNvbXBsZXRlZFdvcmsucmV0dXJuO1xuICAgICAgICBzdGFydFByb2ZpbGVyVGltZXIoY29tcGxldGVkV29yayk7XG4gICAgICAgIGN1cnJlbnQgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBjb21wbGV0ZWRXb3JrLFxuICAgICAgICAgIGNvbXBsZXRlV29yayxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIGNvbXBsZXRlZFdvcmssXG4gICAgICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXNcbiAgICAgICAgKTtcbiAgICAgICAgKGNvbXBsZXRlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZEluY29tcGxldGVEdXJhdGlvbihjb21wbGV0ZWRXb3JrKTtcbiAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBsZXRlZFdvcmsgPSBjb21wbGV0ZWRXb3JrLnNpYmxpbmc7XG4gICAgICAgIGlmIChudWxsICE9PSBjb21wbGV0ZWRXb3JrKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBjb21wbGV0ZWRXb3JrO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGNvbXBsZXRlZFdvcmsgPSB1bml0T2ZXb3JrO1xuICAgICAgfSB3aGlsZSAobnVsbCAhPT0gY29tcGxldGVkV29yayk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcyAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RDb21wbGV0ZWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bndpbmRVbml0T2ZXb3JrKHVuaXRPZldvcmssIHNraXBTaWJsaW5ncykge1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgbmV4dCA9IHVud2luZFdvcmsodW5pdE9mV29yay5hbHRlcm5hdGUsIHVuaXRPZldvcmspO1xuICAgICAgICBpZiAobnVsbCAhPT0gbmV4dCkge1xuICAgICAgICAgIG5leHQuZmxhZ3MgJj0gMzI3Njc7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHVuaXRPZldvcmsubW9kZSAmIDIpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZEluY29tcGxldGVEdXJhdGlvbih1bml0T2ZXb3JrKTtcbiAgICAgICAgICBuZXh0ID0gdW5pdE9mV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgICBmb3IgKHZhciBjaGlsZCA9IHVuaXRPZldvcmsuY2hpbGQ7IG51bGwgIT09IGNoaWxkOyApXG4gICAgICAgICAgICAobmV4dCArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbiksIChjaGlsZCA9IGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHVuaXRPZldvcmsuYWN0dWFsRHVyYXRpb24gPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIG5leHQgPSB1bml0T2ZXb3JrLnJldHVybjtcbiAgICAgICAgbnVsbCAhPT0gbmV4dCAmJlxuICAgICAgICAgICgobmV4dC5mbGFncyB8PSAzMjc2OCksXG4gICAgICAgICAgKG5leHQuc3VidHJlZUZsYWdzID0gMCksXG4gICAgICAgICAgKG5leHQuZGVsZXRpb25zID0gbnVsbCkpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXNraXBTaWJsaW5ncyAmJlxuICAgICAgICAgICgodW5pdE9mV29yayA9IHVuaXRPZldvcmsuc2libGluZyksIG51bGwgIT09IHVuaXRPZldvcmspXG4gICAgICAgICkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gdW5pdE9mV29yaztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1bml0T2ZXb3JrID0gbmV4dDtcbiAgICAgIH0gd2hpbGUgKG51bGwgIT09IHVuaXRPZldvcmspO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Um9vdChcbiAgICAgIHJvb3QsXG4gICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgc3Bhd25lZExhbmUsXG4gICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgc3VzcGVuZGVkQ29tbWl0UmVhc29uLFxuICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuICAgICkge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgcHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgyKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLFxuICAgICAgICAgIGNvbW1pdFJvb3RJbXBsKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICAgICAgICBwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSxcbiAgICAgICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgIHN1c3BlbmRlZENvbW1pdFJlYXNvbixcbiAgICAgICAgICAgIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Um9vdEltcGwoXG4gICAgICByb290LFxuICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICB0cmFuc2l0aW9ucyxcbiAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICAgIHJlbmRlclByaW9yaXR5TGV2ZWwsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXNcbiAgICApIHtcbiAgICAgIGRvIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgIHdoaWxlIChudWxsICE9PSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyk7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nKCk7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncygpO1xuICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy5cIik7XG4gICAgICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUgPSByb290LmZpbmlzaGVkTGFuZXM7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0YXJ0ZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZChkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUpO1xuICAgICAgaWYgKG51bGwgPT09IGZpbmlzaGVkV29yaykgcmV0dXJuIG1hcmtDb21taXRTdG9wcGVkKCksIG51bGw7XG4gICAgICAwID09PSBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcInJvb3QuZmluaXNoZWRMYW5lcyBzaG91bGQgbm90IGJlIGVtcHR5IGR1cmluZyBhIGNvbW1pdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgcm9vdC5maW5pc2hlZExhbmVzID0gMDtcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgPT09IHJvb3QuY3VycmVudClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICByb290LmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSAwO1xuICAgICAgcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gbnVsbDtcbiAgICAgIHZhciByZW1haW5pbmdMYW5lcyA9IGZpbmlzaGVkV29yay5sYW5lcyB8IGZpbmlzaGVkV29yay5jaGlsZExhbmVzO1xuICAgICAgcmVtYWluaW5nTGFuZXMgfD0gY29uY3VycmVudGx5VXBkYXRlZExhbmVzO1xuICAgICAgbWFya1Jvb3RGaW5pc2hlZChcbiAgICAgICAgcm9vdCxcbiAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICByZW1haW5pbmdMYW5lcyxcbiAgICAgICAgc3Bhd25lZExhbmUsXG4gICAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lc1xuICAgICAgKTtcbiAgICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAoKHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbCksXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IDApKTtcbiAgICAgICgwID09PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDEwMjU2KSAmJlxuICAgICAgICAwID09PSAoZmluaXNoZWRXb3JrLmZsYWdzICYgMTAyNTYpKSB8fFxuICAgICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyB8fFxuICAgICAgICAoKHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gITApLFxuICAgICAgICAocGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSByZW1haW5pbmdMYW5lcyksXG4gICAgICAgIChwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gdHJhbnNpdGlvbnMpLFxuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCEwKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSkpO1xuICAgICAgY29tbWl0U3RhcnRUaW1lID0gbm93KCk7XG4gICAgICB0cmFuc2l0aW9ucyA9IDAgIT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxNTk5MCk7XG4gICAgICAwICE9PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDE1OTkwKSB8fCB0cmFuc2l0aW9uc1xuICAgICAgICA/ICgodHJhbnNpdGlvbnMgPSBSZWFjdFNoYXJlZEludGVybmFscy5UKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLFxuICAgICAgICAgIChzcGF3bmVkTGFuZSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpKSxcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoMiksXG4gICAgICAgICAgKHVwZGF0ZWRMYW5lcyA9IGV4ZWN1dGlvbkNvbnRleHQpLFxuICAgICAgICAgIChleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQpLFxuICAgICAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGVcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlc2V0QWZ0ZXJDb21taXQocm9vdC5jb250YWluZXJJbmZvKSxcbiAgICAgICAgICAocm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZCAmJlxuICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQoXG4gICAgICAgICAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlKSxcbiAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCAmJlxuICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQoKSxcbiAgICAgICAgICByZXF1ZXN0UGFpbnQoKSxcbiAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCA9IHVwZGF0ZWRMYW5lcyksXG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHNwYXduZWRMYW5lKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHRyYW5zaXRpb25zKSlcbiAgICAgICAgOiAocm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrKTtcbiAgICAgICh0cmFuc2l0aW9ucyA9IHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKVxuICAgICAgICA/ICgocm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSAhMSksXG4gICAgICAgICAgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gcm9vdCksXG4gICAgICAgICAgKHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlKSlcbiAgICAgICAgOiAocmVsZWFzZVJvb3RQb29sZWRDYWNoZShyb290LCByZW1haW5pbmdMYW5lcyksXG4gICAgICAgICAgKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApLFxuICAgICAgICAgIChyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbCkpO1xuICAgICAgcmVtYWluaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgIDAgPT09IHJlbWFpbmluZ0xhbmVzICYmIChsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGwpO1xuICAgICAgdHJhbnNpdGlvbnMgfHwgY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QpO1xuICAgICAgb25Db21taXRSb290JDEoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSwgcmVuZGVyUHJpb3JpdHlMZXZlbCk7XG4gICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiByb290Lm1lbW9pemVkVXBkYXRlcnMuY2xlYXIoKTtcbiAgICAgIG9uQ29tbWl0Um9vdCgpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgICAgaWYgKG51bGwgIT09IHJlY292ZXJhYmxlRXJyb3JzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHJlbmRlclByaW9yaXR5TGV2ZWwgPSByb290Lm9uUmVjb3ZlcmFibGVFcnJvciwgZmluaXNoZWRXb3JrID0gMDtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsgPCByZWNvdmVyYWJsZUVycm9ycy5sZW5ndGg7XG4gICAgICAgICAgZmluaXNoZWRXb3JrKytcbiAgICAgICAgKVxuICAgICAgICAgIChyZW1haW5pbmdMYW5lcyA9IHJlY292ZXJhYmxlRXJyb3JzW2ZpbmlzaGVkV29ya10pLFxuICAgICAgICAgICAgKHRyYW5zaXRpb25zID0gbWFrZUVycm9ySW5mbyhyZW1haW5pbmdMYW5lcy5zdGFjaykpLFxuICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgIHJlbWFpbmluZ0xhbmVzLnNvdXJjZSxcbiAgICAgICAgICAgICAgcmVuZGVyUHJpb3JpdHlMZXZlbCxcbiAgICAgICAgICAgICAgcmVtYWluaW5nTGFuZXMudmFsdWUsXG4gICAgICAgICAgICAgIHRyYW5zaXRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgMCAhPT0gKHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzICYgMykgJiYgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgcmVtYWluaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgIDAgIT09IChkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUgJiA0MTk0MjE4KSAmJlxuICAgICAgMCAhPT0gKHJlbWFpbmluZ0xhbmVzICYgNDIpXG4gICAgICAgID8gKChuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSAhMCksXG4gICAgICAgICAgcm9vdCA9PT0gcm9vdFdpdGhOZXN0ZWRVcGRhdGVzXG4gICAgICAgICAgICA/IG5lc3RlZFVwZGF0ZUNvdW50KytcbiAgICAgICAgICAgIDogKChuZXN0ZWRVcGRhdGVDb3VudCA9IDApLCAocm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gcm9vdCkpKVxuICAgICAgICA6IChuZXN0ZWRVcGRhdGVDb3VudCA9IDApO1xuICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpO1xuICAgICAgbWFya0NvbW1pdFN0b3BwZWQoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlRXJyb3JJbmZvKGNvbXBvbmVudFN0YWNrKSB7XG4gICAgICBjb21wb25lbnRTdGFjayA9IHsgY29tcG9uZW50U3RhY2s6IGNvbXBvbmVudFN0YWNrIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29tcG9uZW50U3RhY2ssIFwiZGlnZXN0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdZb3UgYXJlIGFjY2Vzc2luZyBcImRpZ2VzdFwiIGZyb20gdGhlIGVycm9ySW5mbyBvYmplY3QgcGFzc2VkIHRvIG9uUmVjb3ZlcmFibGVFcnJvci4gVGhpcyBwcm9wZXJ0eSBpcyBubyBsb25nZXIgcHJvdmlkZWQgYXMgcGFydCBvZiBlcnJvckluZm8gYnV0IGNhbiBiZSBhY2Nlc3NlZCBhcyBhIHByb3BlcnR5IG9mIHRoZSBFcnJvciBpbnN0YW5jZSBpdHNlbGYuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudFN0YWNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWxlYXNlUm9vdFBvb2xlZENhY2hlKHJvb3QsIHJlbWFpbmluZ0xhbmVzKSB7XG4gICAgICAwID09PSAocm9vdC5wb29sZWRDYWNoZUxhbmVzICY9IHJlbWFpbmluZ0xhbmVzKSAmJlxuICAgICAgICAoKHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wb29sZWRDYWNoZSksXG4gICAgICAgIG51bGwgIT0gcmVtYWluaW5nTGFuZXMgJiZcbiAgICAgICAgICAoKHJvb3QucG9vbGVkQ2FjaGUgPSBudWxsKSwgcmVsZWFzZUNhY2hlKHJlbWFpbmluZ0xhbmVzKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzKCkge1xuICAgICAgaWYgKG51bGwgIT09IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzKSB7XG4gICAgICAgIHZhciByb290ID0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMsXG4gICAgICAgICAgcmVtYWluaW5nTGFuZXMgPSBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcztcbiAgICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSAwO1xuICAgICAgICB2YXIgcmVuZGVyUHJpb3JpdHkgPSBsYW5lc1RvRXZlbnRQcmlvcml0eShwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyksXG4gICAgICAgICAgcHJpb3JpdHkgPSAzMiA+IHJlbmRlclByaW9yaXR5ID8gMzIgOiByZW5kZXJQcmlvcml0eTtcbiAgICAgICAgcmVuZGVyUHJpb3JpdHkgPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgICAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmlvcml0eSk7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzKVxuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJpb3JpdHkgPSBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zO1xuICAgICAgICAgICAgcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcm9vdCRqc2NvbXAkMCA9IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLFxuICAgICAgICAgICAgICBsYW5lcyA9IHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzO1xuICAgICAgICAgICAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsO1xuICAgICAgICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSAwO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PVxuICAgICAgICAgICAgICBOb0NvbnRleHRcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDYW5ub3QgZmx1c2ggcGFzc2l2ZSBlZmZlY3RzIHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMDtcbiAgICAgICAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMTtcbiAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgICAgICAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICAgICAgICBleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQ7XG4gICAgICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIocm9vdCRqc2NvbXAkMC5jdXJyZW50KTtcbiAgICAgICAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoXG4gICAgICAgICAgICAgIHJvb3QkanNjb21wJDAsXG4gICAgICAgICAgICAgIHJvb3QkanNjb21wJDAuY3VycmVudCxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIHByaW9yaXR5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCAmJlxuICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgICAgICAgICAgIGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290JGpzY29tcCQwKTtcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgICAgICAgICAgIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKDAsICExKTtcbiAgICAgICAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHNcbiAgICAgICAgICAgICAgPyByb290JGpzY29tcCQwID09PSByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzXG4gICAgICAgICAgICAgICAgPyBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQrK1xuICAgICAgICAgICAgICAgIDogKChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwKSxcbiAgICAgICAgICAgICAgICAgIChyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gcm9vdCRqc2NvbXAkMCkpXG4gICAgICAgICAgICAgIDogKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApO1xuICAgICAgICAgICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9IGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9XG4gICAgICAgICAgICAgICExO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBpbmplY3RlZEhvb2sgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGluamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAgICAgICAoKGhhc0xvZ2dlZEVycm9yID0gITApLFxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGF0ZU5vZGUgPSByb290JGpzY29tcCQwLmN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSByZW5kZXJQcmlvcml0eSksXG4gICAgICAgICAgICByZWxlYXNlUm9vdFBvb2xlZENhY2hlKHJvb3QsIHJlbWFpbmluZ0xhbmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChyb290RmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcikge1xuICAgICAgc291cmNlRmliZXIgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciwgc291cmNlRmliZXIpO1xuICAgICAgc291cmNlRmliZXIgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLnN0YXRlTm9kZSwgc291cmNlRmliZXIsIDIpO1xuICAgICAgcm9vdEZpYmVyID0gZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsIHNvdXJjZUZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHJvb3RGaWJlciAmJlxuICAgICAgICAobWFya1Jvb3RVcGRhdGVkJDEocm9vdEZpYmVyLCAyKSwgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3RGaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGVycm9yXG4gICAgKSB7XG4gICAgICBpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMTtcbiAgICAgIGlmICgzID09PSBzb3VyY2VGaWJlci50YWcpXG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHNvdXJjZUZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAoOyBudWxsICE9PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yOyApIHtcbiAgICAgICAgICBpZiAoMyA9PT0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci50YWcpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBzb3VyY2VGaWJlcixcbiAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgxID09PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnRhZykge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciB8fFxuICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggJiZcbiAgICAgICAgICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgfHxcbiAgICAgICAgICAgICAgICAgICFsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMoaW5zdGFuY2UpKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBzb3VyY2VGaWJlciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gICAgICAgICAgICAgIGVycm9yID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSgyKTtcbiAgICAgICAgICAgICAgaW5zdGFuY2UgPSBlbnF1ZXVlVXBkYXRlKG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yLCAyKTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgICAoaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUoXG4gICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBtYXJrUm9vdFVwZGF0ZWQkMShpbnN0YW5jZSwgMiksXG4gICAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGluc3RhbmNlKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciA9IG5lYXJlc3RNb3VudGVkQW5jZXN0b3IucmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJJbnRlcm5hbCBSZWFjdCBlcnJvcjogQXR0ZW1wdGVkIHRvIGNhcHR1cmUgYSBjb21taXQgcGhhc2UgZXJyb3IgaW5zaWRlIGEgZGV0YWNoZWQgdHJlZS4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuIFBvdGVudGlhbCBjYXVzZXMgaW5jbHVkZSBkZWxldGluZyB0aGUgc2FtZSBmaWJlciBtb3JlIHRoYW4gb25jZSwgY29tbWl0dGluZyBhbiBhbHJlYWR5LWZpbmlzaGVkIHRyZWUsIG9yIGFuIGluY29uc2lzdGVudCByZXR1cm4gcG9pbnRlci5cXG5cXG5FcnJvciBtZXNzYWdlOlxcblxcbiVzXCIsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCBsYW5lcykge1xuICAgICAgdmFyIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlO1xuICAgICAgaWYgKG51bGwgPT09IHBpbmdDYWNoZSkge1xuICAgICAgICBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbiAgICAgICAgdmFyIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICAodGhyZWFkSURzID0gcGluZ0NhY2hlLmdldCh3YWtlYWJsZSkpLFxuICAgICAgICAgIHZvaWQgMCA9PT0gdGhyZWFkSURzICYmXG4gICAgICAgICAgICAoKHRocmVhZElEcyA9IG5ldyBTZXQoKSksIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcykpO1xuICAgICAgdGhyZWFkSURzLmhhcyhsYW5lcykgfHxcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSAhMCksXG4gICAgICAgIHRocmVhZElEcy5hZGQobGFuZXMpLFxuICAgICAgICAocGluZ0NhY2hlID0gcGluZ1N1c3BlbmRlZFJvb3QuYmluZChudWxsLCByb290LCB3YWtlYWJsZSwgbGFuZXMpKSxcbiAgICAgICAgaXNEZXZUb29sc1ByZXNlbnQgJiYgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCBsYW5lcyksXG4gICAgICAgIHdha2VhYmxlLnRoZW4ocGluZ0NhY2hlLCBwaW5nQ2FjaGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGluZ1N1c3BlbmRlZFJvb3Qocm9vdCwgd2FrZWFibGUsIHBpbmdlZExhbmVzKSB7XG4gICAgICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gICAgICBudWxsICE9PSBwaW5nQ2FjaGUgJiYgcGluZ0NhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7XG4gICAgICByb290LnBpbmdlZExhbmVzIHw9IHJvb3Quc3VzcGVuZGVkTGFuZXMgJiBwaW5nZWRMYW5lcztcbiAgICAgIHJvb3Qud2FybUxhbmVzICY9IH5waW5nZWRMYW5lcztcbiAgICAgIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkgJiZcbiAgICAgICAgbnVsbCA9PT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkEgc3VzcGVuZGVkIHJlc291cmNlIGZpbmlzaGVkIGxvYWRpbmcgaW5zaWRlIGEgdGVzdCwgYnV0IHRoZSBldmVudCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgcmVzb2x2ZXMgc3VzcGVuZGVkIGRhdGEgc2hvdWxkIGJlIHdyYXBwZWQgaW50byBhY3QoLi4uKTpcXG5cXG5hY3QoKCkgPT4ge1xcbiAgLyogZmluaXNoIGxvYWRpbmcgc3VzcGVuZGVkIGRhdGEgKi9cXG59KTtcXG4vKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcblRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgaW4gdGhlIGJyb3dzZXIuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0XCJcbiAgICAgICAgKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdCA9PT0gcm9vdCAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiBwaW5nZWRMYW5lcykgPT09IHBpbmdlZExhbmVzICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5IHx8XG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNjI5MTQ1NjApID09PVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICBub3ckMSgpIC0gZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA8IEZBTExCQUNLX1RIUk9UVExFX01TKVxuICAgICAgICAgID8gKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0ICYmXG4gICAgICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKVxuICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzIHw9IHBpbmdlZExhbmVzKSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPSAwKSk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpIHtcbiAgICAgIDAgPT09IHJldHJ5TGFuZSAmJiAocmV0cnlMYW5lID0gY2xhaW1OZXh0UmV0cnlMYW5lKCkpO1xuICAgICAgYm91bmRhcnlGaWJlciA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuICAgICAgbnVsbCAhPT0gYm91bmRhcnlGaWJlciAmJlxuICAgICAgICAobWFya1Jvb3RVcGRhdGVkJDEoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKSxcbiAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGJvdW5kYXJ5RmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeShib3VuZGFyeUZpYmVyKSB7XG4gICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgcmV0cnlMYW5lID0gMDtcbiAgICAgIG51bGwgIT09IHN1c3BlbnNlU3RhdGUgJiYgKHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lKTtcbiAgICAgIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlUmV0cnlXYWtlYWJsZShib3VuZGFyeUZpYmVyLCB3YWtlYWJsZSkge1xuICAgICAgdmFyIHJldHJ5TGFuZSA9IDA7XG4gICAgICBzd2l0Y2ggKGJvdW5kYXJ5RmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBudWxsICE9PSBzdXNwZW5zZVN0YXRlICYmIChyZXRyeUxhbmUgPSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZS5fcmV0cnlDYWNoZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiUGluZ2VkIHVua25vd24gc3VzcGVuc2UgYm91bmRhcnkgdHlwZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBudWxsICE9PSByZXRyeUNhY2hlICYmIHJldHJ5Q2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgICAgIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWKFxuICAgICAgcm9vdCRqc2NvbXAkMCxcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgaXNJblN0cmljdE1vZGVcbiAgICApIHtcbiAgICAgIGlmICgwICE9PSAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMzM1NjI2MjQpKVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IHJvb3QkanNjb21wJDAsXG4gICAgICAgICAgICBmaWJlciA9IHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgaXNTdHJpY3RNb2RlRmliZXIgPSBmaWJlci50eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuICAgICAgICAgIGlzU3RyaWN0TW9kZUZpYmVyID0gaXNJblN0cmljdE1vZGUgfHwgaXNTdHJpY3RNb2RlRmliZXI7XG4gICAgICAgICAgMjIgIT09IGZpYmVyLnRhZ1xuICAgICAgICAgICAgPyBmaWJlci5mbGFncyAmIDMzNTU0NDMyXG4gICAgICAgICAgICAgID8gaXNTdHJpY3RNb2RlRmliZXIgJiZcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIsXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICAoZmliZXIubW9kZSAmIDY0KSA9PT0gTm9Nb2RlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYoXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICBpc1N0cmljdE1vZGVGaWJlclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogbnVsbCA9PT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICAoaXNTdHJpY3RNb2RlRmliZXIgJiYgZmliZXIuZmxhZ3MgJiA4MTkyXG4gICAgICAgICAgICAgICAgPyBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICBmaWJlclxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogZmliZXIuc3VidHJlZUZsYWdzICYgMzM1NTQ0MzIgJiZcbiAgICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVixcbiAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RyaWN0TW9kZUZpYmVyXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIocm9vdCwgZmliZXIpIHtcbiAgICAgIHZhciBzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyA9XG4gICAgICAgIDIgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDogITA7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICB0cnkge1xuICAgICAgICBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpYmVyKSxcbiAgICAgICAgICBzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyAmJiBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChmaWJlciksXG4gICAgICAgICAgcmVhcHBlYXJMYXlvdXRFZmZlY3RzKHJvb3QsIGZpYmVyLmFsdGVybmF0ZSwgZmliZXIsICExKSxcbiAgICAgICAgICBzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyAmJlxuICAgICAgICAgICAgcmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMocm9vdCwgZmliZXIsIDAsIG51bGwsICExKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QpIHtcbiAgICAgIHZhciBkb3VibGVJbnZva2VFZmZlY3RzID0gITA7XG4gICAgICByb290LmN1cnJlbnQubW9kZSAmIDI0IHx8IChkb3VibGVJbnZva2VFZmZlY3RzID0gITEpO1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcm9vdC5jdXJyZW50LFxuICAgICAgICBkb3VibGVJbnZva2VFZmZlY3RzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAzID09PSB0YWcgfHxcbiAgICAgICAgICAxID09PSB0YWcgfHxcbiAgICAgICAgICAwID09PSB0YWcgfHxcbiAgICAgICAgICAxMSA9PT0gdGFnIHx8XG4gICAgICAgICAgMTQgPT09IHRhZyB8fFxuICAgICAgICAgIDE1ID09PSB0YWdcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGFnID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJSZWFjdENvbXBvbmVudFwiO1xuICAgICAgICAgIGlmIChudWxsICE9PSBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5oYXModGFnKSkgcmV0dXJuO1xuICAgICAgICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5hZGQodGFnKTtcbiAgICAgICAgICB9IGVsc2UgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG5ldyBTZXQoW3RhZ10pO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkNhbid0IHBlcmZvcm0gYSBSZWFjdCBzdGF0ZSB1cGRhdGUgb24gYSBjb21wb25lbnQgdGhhdCBoYXNuJ3QgbW91bnRlZCB5ZXQuIFRoaXMgaW5kaWNhdGVzIHRoYXQgeW91IGhhdmUgYSBzaWRlLWVmZmVjdCBpbiB5b3VyIHJlbmRlciBmdW5jdGlvbiB0aGF0IGFzeW5jaHJvbm91c2x5IGxhdGVyIGNhbGxzIHRyaWVzIHRvIHVwZGF0ZSB0aGUgY29tcG9uZW50LiBNb3ZlIHRoaXMgd29yayB0byB1c2VFZmZlY3QgaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIGxhbmVzKSB7XG4gICAgICBpc0RldlRvb2xzUHJlc2VudCAmJlxuICAgICAgICByb290Lm1lbW9pemVkVXBkYXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2NoZWR1bGluZ0ZpYmVyKSB7XG4gICAgICAgICAgYWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsIHNjaGVkdWxpbmdGaWJlciwgbGFuZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhwcmlvcml0eUxldmVsLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGFjdFF1ZXVlID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWU7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gYWN0UXVldWVcbiAgICAgICAgPyAoYWN0UXVldWUucHVzaChjYWxsYmFjayksIGZha2VBY3RDYWxsYmFja05vZGUpXG4gICAgICAgIDogc2NoZWR1bGVDYWxsYmFjayQzKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKSB7XG4gICAgICBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpICYmXG4gICAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICYmXG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiQW4gdXBkYXRlIHRvICVzIGluc2lkZSBhIHRlc3Qgd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbldoZW4gdGVzdGluZywgY29kZSB0aGF0IGNhdXNlcyBSZWFjdCBzdGF0ZSB1cGRhdGVzIHNob3VsZCBiZSB3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuYWN0KCgpID0+IHtcXG4gIC8qIGZpcmUgZXZlbnRzIHRoYXQgdXBkYXRlIHN0YXRlICovXFxufSk7XFxuLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG5UaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIGluIHRoZSBicm93c2VyLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdFwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcilcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09PSByZXNvbHZlRmFtaWx5KSByZXR1cm4gdHlwZTtcbiAgICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZmFtaWx5ID8gdHlwZSA6IGZhbWlseS5jdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gcmVzb2x2ZUZhbWlseSkgcmV0dXJuIHR5cGU7XG4gICAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseSh0eXBlKTtcbiAgICAgIHJldHVybiB2b2lkIDAgPT09IGZhbWlseVxuICAgICAgICA/IG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICB2b2lkIDAgIT09IHR5cGUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLnJlbmRlciAmJlxuICAgICAgICAgICgoZmFtaWx5ID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUucmVuZGVyKSksXG4gICAgICAgICAgdHlwZS5yZW5kZXIgIT09IGZhbWlseSlcbiAgICAgICAgICA/ICgoZmFtaWx5ID0geyAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSwgcmVuZGVyOiBmYW1pbHkgfSksXG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZGlzcGxheU5hbWUgJiZcbiAgICAgICAgICAgICAgKGZhbWlseS5kaXNwbGF5TmFtZSA9IHR5cGUuZGlzcGxheU5hbWUpLFxuICAgICAgICAgICAgZmFtaWx5KVxuICAgICAgICAgIDogdHlwZVxuICAgICAgICA6IGZhbWlseS5jdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoZmliZXIsIGVsZW1lbnQpIHtcbiAgICAgIGlmIChudWxsID09PSByZXNvbHZlRmFtaWx5KSByZXR1cm4gITE7XG4gICAgICB2YXIgcHJldlR5cGUgPSBmaWJlci5lbGVtZW50VHlwZTtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnR5cGU7XG4gICAgICB2YXIgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMSxcbiAgICAgICAgJCR0eXBlb2ZOZXh0VHlwZSA9XG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVsZW1lbnQgJiYgbnVsbCAhPT0gZWxlbWVudFxuICAgICAgICAgICAgPyBlbGVtZW50LiQkdHlwZW9mXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZWxlbWVudCAmJiAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBlbGVtZW50XG4gICAgICAgICAgICA/IChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKVxuICAgICAgICAgICAgOiAkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEVcbiAgICAgICAgICAgID8gKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApXG4gICAgICAgICAgICA6ICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTUVNT19UWVBFXG4gICAgICAgICAgICA/IChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKVxuICAgICAgICAgICAgOiAkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZWVkc0NvbXBhcmVGYW1pbGllcyAmJlxuICAgICAgICAoKGZpYmVyID0gcmVzb2x2ZUZhbWlseShwcmV2VHlwZSkpLFxuICAgICAgICB2b2lkIDAgIT09IGZpYmVyICYmIGZpYmVyID09PSByZXNvbHZlRmFtaWx5KGVsZW1lbnQpKVxuICAgICAgICA/ICEwXG4gICAgICAgIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKSB7XG4gICAgICBudWxsICE9PSByZXNvbHZlRmFtaWx5ICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtTZXQgJiZcbiAgICAgICAgKG51bGwgPT09IGZhaWxlZEJvdW5kYXJpZXMgJiYgKGZhaWxlZEJvdW5kYXJpZXMgPSBuZXcgV2Vha1NldCgpKSxcbiAgICAgICAgZmFpbGVkQm91bmRhcmllcy5hZGQoZmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShcbiAgICAgIGZpYmVyLFxuICAgICAgdXBkYXRlZEZhbWlsaWVzLFxuICAgICAgc3RhbGVGYW1pbGllc1xuICAgICkge1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGUsXG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgfVxuICAgICAgaWYgKG51bGwgPT09IHJlc29sdmVGYW1pbHkpXG4gICAgICAgIHRocm93IEVycm9yKFwiRXhwZWN0ZWQgcmVzb2x2ZUZhbWlseSB0byBiZSBzZXQgZHVyaW5nIGhvdCByZWxvYWQuXCIpO1xuICAgICAgdmFyIG5lZWRzUmVuZGVyID0gITE7XG4gICAgICB0eXBlID0gITE7XG4gICAgICBudWxsICE9PSBjYW5kaWRhdGVUeXBlICYmXG4gICAgICAgICgoY2FuZGlkYXRlVHlwZSA9IHJlc29sdmVGYW1pbHkoY2FuZGlkYXRlVHlwZSkpLFxuICAgICAgICB2b2lkIDAgIT09IGNhbmRpZGF0ZVR5cGUgJiZcbiAgICAgICAgICAoc3RhbGVGYW1pbGllcy5oYXMoY2FuZGlkYXRlVHlwZSlcbiAgICAgICAgICAgID8gKHR5cGUgPSAhMClcbiAgICAgICAgICAgIDogdXBkYXRlZEZhbWlsaWVzLmhhcyhjYW5kaWRhdGVUeXBlKSAmJlxuICAgICAgICAgICAgICAoMSA9PT0gdGFnID8gKHR5cGUgPSAhMCkgOiAobmVlZHNSZW5kZXIgPSAhMCkpKSk7XG4gICAgICBudWxsICE9PSBmYWlsZWRCb3VuZGFyaWVzICYmXG4gICAgICAgIChmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlcikgfHxcbiAgICAgICAgICAobnVsbCAhPT0gYWx0ZXJuYXRlICYmIGZhaWxlZEJvdW5kYXJpZXMuaGFzKGFsdGVybmF0ZSkpKSAmJlxuICAgICAgICAodHlwZSA9ICEwKTtcbiAgICAgIHR5cGUgJiYgKGZpYmVyLl9kZWJ1Z05lZWRzUmVtb3VudCA9ICEwKTtcbiAgICAgIGlmICh0eXBlIHx8IG5lZWRzUmVuZGVyKVxuICAgICAgICAoYWx0ZXJuYXRlID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihhbHRlcm5hdGUsIGZpYmVyLCAyKTtcbiAgICAgIG51bGwgPT09IGNoaWxkIHx8XG4gICAgICAgIHR5cGUgfHxcbiAgICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICB1cGRhdGVkRmFtaWxpZXMsXG4gICAgICAgICAgc3RhbGVGYW1pbGllc1xuICAgICAgICApO1xuICAgICAgbnVsbCAhPT0gc2libGluZyAmJlxuICAgICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KFxuICAgICAgICAgIHNpYmxpbmcsXG4gICAgICAgICAgdXBkYXRlZEZhbWlsaWVzLFxuICAgICAgICAgIHN0YWxlRmFtaWxpZXNcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLnNpYmxpbmcgPVxuICAgICAgICB0aGlzLmNoaWxkID1cbiAgICAgICAgdGhpcy5yZXR1cm4gPVxuICAgICAgICB0aGlzLnN0YXRlTm9kZSA9XG4gICAgICAgIHRoaXMudHlwZSA9XG4gICAgICAgIHRoaXMuZWxlbWVudFR5cGUgPVxuICAgICAgICAgIG51bGw7XG4gICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgIHRoaXMucmVmQ2xlYW51cCA9IHRoaXMucmVmID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPVxuICAgICAgICB0aGlzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICB0aGlzLnVwZGF0ZVF1ZXVlID1cbiAgICAgICAgdGhpcy5tZW1vaXplZFByb3BzID1cbiAgICAgICAgICBudWxsO1xuICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgIHRoaXMuc3VidHJlZUZsYWdzID0gdGhpcy5mbGFncyA9IDA7XG4gICAgICB0aGlzLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgICB0aGlzLmNoaWxkTGFuZXMgPSB0aGlzLmxhbmVzID0gMDtcbiAgICAgIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSAtMDtcbiAgICAgIHRoaXMuYWN0dWFsU3RhcnRUaW1lID0gLTEuMTtcbiAgICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IHRoaXMuc2VsZkJhc2VEdXJhdGlvbiA9IC0wO1xuICAgICAgdGhpcy5fZGVidWdPd25lciA9IHRoaXMuX2RlYnVnSW5mbyA9IG51bGw7XG4gICAgICB0aGlzLl9kZWJ1Z05lZWRzUmVtb3VudCA9ICExO1xuICAgICAgdGhpcy5fZGVidWdIb29rVHlwZXMgPSBudWxsO1xuICAgICAgaGFzQmFkTWFwUG9seWZpbGwgfHxcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zIHx8XG4gICAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICAgICAgQ29tcG9uZW50ID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAhKCFDb21wb25lbnQgfHwgIUNvbXBvbmVudC5pc1JlYWN0Q29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzKSB7XG4gICAgICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKFxuICAgICAgICAgICAgY3VycmVudC50YWcsXG4gICAgICAgICAgICBwZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICBjdXJyZW50LmtleSxcbiAgICAgICAgICAgIGN1cnJlbnQubW9kZVxuICAgICAgICAgICkpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9IGN1cnJlbnQuZWxlbWVudFR5cGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXIpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXMgPSBjdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQpLFxuICAgICAgICAgIChjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzKSlcbiAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmFjdHVhbER1cmF0aW9uID0gLTApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5hY3R1YWxTdGFydFRpbWUgPSAtMS4xKSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IGN1cnJlbnQuZmxhZ3MgJiAzMTQ1NzI4MDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgICAgIHBlbmRpbmdQcm9wcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID1cbiAgICAgICAgbnVsbCA9PT0gcGVuZGluZ1Byb3BzXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIGxhbmVzOiBwZW5kaW5nUHJvcHMubGFuZXMsXG4gICAgICAgICAgICAgIGZpcnN0Q29udGV4dDogcGVuZGluZ1Byb3BzLmZpcnN0Q29udGV4dCxcbiAgICAgICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogcGVuZGluZ1Byb3BzLl9kZWJ1Z1RoZW5hYmxlU3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICAgICAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5yZWZDbGVhbnVwID0gY3VycmVudC5yZWZDbGVhbnVwO1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJbmZvID0gY3VycmVudC5fZGVidWdJbmZvO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ID0gY3VycmVudC5fZGVidWdOZWVkc1JlbW91bnQ7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gMzE0NTcyODI7XG4gICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSAwKSlcbiAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZSksXG4gICAgICAgICAgKHJlbmRlckxhbmVzID0gY3VycmVudC5kZXBlbmRlbmNpZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPVxuICAgICAgICAgICAgbnVsbCA9PT0gcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgbGFuZXM6IHJlbmRlckxhbmVzLmxhbmVzLFxuICAgICAgICAgICAgICAgICAgZmlyc3RDb250ZXh0OiByZW5kZXJMYW5lcy5maXJzdENvbnRleHQsXG4gICAgICAgICAgICAgICAgICBfZGVidWdUaGVuYWJsZVN0YXRlOiByZW5kZXJMYW5lcy5fZGVidWdUaGVuYWJsZVN0YXRlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb24pLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgIHR5cGUsXG4gICAgICBrZXksXG4gICAgICBwZW5kaW5nUHJvcHMsXG4gICAgICBvd25lcixcbiAgICAgIG1vZGUsXG4gICAgICBsYW5lc1xuICAgICkge1xuICAgICAgdmFyIGZpYmVyVGFnID0gMCxcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gdHlwZTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzaG91bGRDb25zdHJ1Y3QodHlwZSkgJiYgKGZpYmVyVGFnID0gMSksXG4gICAgICAgICAgKHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpKTtcbiAgICAgIGVsc2UgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzdXBwb3J0c1Jlc291cmNlcyAmJiBzdXBwb3J0c1NpbmdsZXRvbnNcbiAgICAgICAgICA/ICgoZmliZXJUYWcgPSBnZXRIb3N0Q29udGV4dCgpKSxcbiAgICAgICAgICAgIChmaWJlclRhZyA9IGlzSG9zdEhvaXN0YWJsZVR5cGUodHlwZSwgcGVuZGluZ1Byb3BzLCBmaWJlclRhZylcbiAgICAgICAgICAgICAgPyAyNlxuICAgICAgICAgICAgICA6IGlzSG9zdFNpbmdsZXRvblR5cGUodHlwZSlcbiAgICAgICAgICAgICAgICA/IDI3XG4gICAgICAgICAgICAgICAgOiA1KSlcbiAgICAgICAgICA6IHN1cHBvcnRzUmVzb3VyY2VzXG4gICAgICAgICAgICA/ICgoZmliZXJUYWcgPSBnZXRIb3N0Q29udGV4dCgpKSxcbiAgICAgICAgICAgICAgKGZpYmVyVGFnID0gaXNIb3N0SG9pc3RhYmxlVHlwZSh0eXBlLCBwZW5kaW5nUHJvcHMsIGZpYmVyVGFnKVxuICAgICAgICAgICAgICAgID8gMjZcbiAgICAgICAgICAgICAgICA6IDUpKVxuICAgICAgICAgICAgOiAoZmliZXJUYWcgPSBzdXBwb3J0c1NpbmdsZXRvbnNcbiAgICAgICAgICAgICAgICA/IGlzSG9zdFNpbmdsZXRvblR5cGUodHlwZSlcbiAgICAgICAgICAgICAgICAgID8gMjdcbiAgICAgICAgICAgICAgICAgIDogNVxuICAgICAgICAgICAgICAgIDogNSk7XG4gICAgICBlbHNlXG4gICAgICAgIGE6IHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgcGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICAgIGZpYmVyVGFnID0gODtcbiAgICAgICAgICAgIG1vZGUgfD0gMjQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAodHlwZSA9IHBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAgIChvd25lciA9IG1vZGUpLFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgdHlwZS5pZCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUHJvZmlsZXIgbXVzdCBzcGVjaWZ5IGFuIFwiaWRcIiBvZiB0eXBlIGBzdHJpbmdgIGFzIGEgcHJvcC4gUmVjZWl2ZWQgdGhlIHR5cGUgYCVzYCBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgdHlwZS5pZFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChrZXkgPSBjcmVhdGVGaWJlcigxMiwgdHlwZSwga2V5LCBvd25lciB8IDIpKSxcbiAgICAgICAgICAgICAgKGtleS5lbGVtZW50VHlwZSA9IFJFQUNUX1BST0ZJTEVSX1RZUEUpLFxuICAgICAgICAgICAgICAoa2V5LmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgICAgICAoa2V5LnN0YXRlTm9kZSA9IHsgZWZmZWN0RHVyYXRpb246IDAsIHBhc3NpdmVFZmZlY3REdXJhdGlvbjogMCB9KSxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChrZXkgPSBjcmVhdGVGaWJlcigxMywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpKSxcbiAgICAgICAgICAgICAgKGtleS5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEUpLFxuICAgICAgICAgICAgICAoa2V5LmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoa2V5ID0gY3JlYXRlRmliZXIoMTksIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSksXG4gICAgICAgICAgICAgIChrZXkuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUpLFxuICAgICAgICAgICAgICAoa2V5LmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmIG51bGwgIT09IHR5cGUpXG4gICAgICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gMTA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSAxMTtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSAxNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IDE2O1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHZvaWQgMCA9PT0gdHlwZSB8fFxuICAgICAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgICAgICAgMCA9PT0gT2JqZWN0LmtleXModHlwZSkubGVuZ3RoKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgKz1cbiAgICAgICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgICAgICBudWxsID09PSB0eXBlXG4gICAgICAgICAgICAgID8gKHBlbmRpbmdQcm9wcyA9IFwibnVsbFwiKVxuICAgICAgICAgICAgICA6IGlzQXJyYXlJbXBsKHR5cGUpXG4gICAgICAgICAgICAgICAgPyAocGVuZGluZ1Byb3BzID0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICAgICAgPyAoKHBlbmRpbmdQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgICAgIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIlVua25vd25cIikgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgICAgICAocmVzb2x2ZWRUeXBlID1cbiAgICAgICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgICAgIDogKHBlbmRpbmdQcm9wcyA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgICAgIGZpYmVyVGFnID0gb3duZXJcbiAgICAgICAgICAgICAgPyBcIm51bWJlclwiID09PSB0eXBlb2Ygb3duZXIudGFnXG4gICAgICAgICAgICAgICAgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyKVxuICAgICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG93bmVyLm5hbWVcbiAgICAgICAgICAgICAgICAgID8gb3duZXIubmFtZVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGZpYmVyVGFnICYmXG4gICAgICAgICAgICAgIChyZXNvbHZlZFR5cGUgKz1cbiAgICAgICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIGZpYmVyVGFnICsgXCJgLlwiKTtcbiAgICAgICAgICAgIGZpYmVyVGFnID0gMjk7XG4gICAgICAgICAgICBwZW5kaW5nUHJvcHMgPSBFcnJvcihcbiAgICAgICAgICAgICAgXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6IFwiICtcbiAgICAgICAgICAgICAgICAocGVuZGluZ1Byb3BzICsgXCIuXCIgKyByZXNvbHZlZFR5cGUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAga2V5ID0gY3JlYXRlRmliZXIoZmliZXJUYWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgICAgIGtleS5lbGVtZW50VHlwZSA9IHR5cGU7XG4gICAgICBrZXkudHlwZSA9IHJlc29sdmVkVHlwZTtcbiAgICAgIGtleS5sYW5lcyA9IGxhbmVzO1xuICAgICAga2V5Ll9kZWJ1Z093bmVyID0gb3duZXI7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIG1vZGUsIGxhbmVzKSB7XG4gICAgICBtb2RlID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICAgICAgICBlbGVtZW50LnR5cGUsXG4gICAgICAgIGVsZW1lbnQua2V5LFxuICAgICAgICBlbGVtZW50LnByb3BzLFxuICAgICAgICBlbGVtZW50Ll9vd25lcixcbiAgICAgICAgbW9kZSxcbiAgICAgICAgbGFuZXNcbiAgICAgICk7XG4gICAgICBtb2RlLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICByZXR1cm4gbW9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgICAgIGVsZW1lbnRzID0gY3JlYXRlRmliZXIoNywgZWxlbWVudHMsIGtleSwgbW9kZSk7XG4gICAgICBlbGVtZW50cy5sYW5lcyA9IGxhbmVzO1xuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gICAgICBwZW5kaW5nUHJvcHMgPSBjcmVhdGVGaWJlcigyMiwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICAgICAgcGVuZGluZ1Byb3BzLmVsZW1lbnRUeXBlID0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEU7XG4gICAgICBwZW5kaW5nUHJvcHMubGFuZXMgPSBsYW5lcztcbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRJbnN0YW5jZSA9IHtcbiAgICAgICAgX3Zpc2liaWxpdHk6IDEsXG4gICAgICAgIF9wZW5kaW5nVmlzaWJpbGl0eTogMSxcbiAgICAgICAgX3BlbmRpbmdNYXJrZXJzOiBudWxsLFxuICAgICAgICBfcmV0cnlDYWNoZTogbnVsbCxcbiAgICAgICAgX3RyYW5zaXRpb25zOiBudWxsLFxuICAgICAgICBfY3VycmVudDogbnVsbCxcbiAgICAgICAgZGV0YWNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gcHJpbWFyeUNoaWxkSW5zdGFuY2UsXG4gICAgICAgICAgICBmaWJlciA9IGluc3RhbmNlLl9jdXJyZW50O1xuICAgICAgICAgIGlmIChudWxsID09PSBmaWJlcilcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkNhbGxpbmcgT2Zmc2NyZWVuLmRldGFjaCBiZWZvcmUgaW5zdGFuY2UgaGFuZGxlIGhhcyBiZWVuIHNldC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoMCA9PT0gKGluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIDIpKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICAgICAgICBudWxsICE9PSByb290ICYmXG4gICAgICAgICAgICAgICgoaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5IHw9IDIpLFxuICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGF0dGFjaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHByaW1hcnlDaGlsZEluc3RhbmNlLFxuICAgICAgICAgICAgZmliZXIgPSBpbnN0YW5jZS5fY3VycmVudDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gZmliZXIpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJDYWxsaW5nIE9mZnNjcmVlbi5kZXRhY2ggYmVmb3JlIGluc3RhbmNlIGhhbmRsZSBoYXMgYmVlbiBzZXQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKDAgIT09IChpbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgJiAyKSkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgICAgICAgbnVsbCAhPT0gcm9vdCAmJlxuICAgICAgICAgICAgICAoKGluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmPSAtMyksXG4gICAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHBlbmRpbmdQcm9wcy5zdGF0ZU5vZGUgPSBwcmltYXJ5Q2hpbGRJbnN0YW5jZTtcbiAgICAgIHJldHVybiBwZW5kaW5nUHJvcHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgbW9kZSwgbGFuZXMpIHtcbiAgICAgIGNvbnRlbnQgPSBjcmVhdGVGaWJlcig2LCBjb250ZW50LCBudWxsLCBtb2RlKTtcbiAgICAgIGNvbnRlbnQubGFuZXMgPSBsYW5lcztcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICAgICAgbW9kZSA9IGNyZWF0ZUZpYmVyKFxuICAgICAgICA0LFxuICAgICAgICBudWxsICE9PSBwb3J0YWwuY2hpbGRyZW4gPyBwb3J0YWwuY2hpbGRyZW4gOiBbXSxcbiAgICAgICAgcG9ydGFsLmtleSxcbiAgICAgICAgbW9kZVxuICAgICAgKTtcbiAgICAgIG1vZGUubGFuZXMgPSBsYW5lcztcbiAgICAgIG1vZGUuc3RhdGVOb2RlID0ge1xuICAgICAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICAgICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLFxuICAgICAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG1vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEZpYmVyUm9vdE5vZGUoXG4gICAgICBjb250YWluZXJJbmZvLFxuICAgICAgdGFnLFxuICAgICAgaHlkcmF0ZSxcbiAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgZm9ybVN0YXRlXG4gICAgKSB7XG4gICAgICB0aGlzLnRhZyA9IDE7XG4gICAgICB0aGlzLmNvbnRhaW5lckluZm8gPSBjb250YWluZXJJbmZvO1xuICAgICAgdGhpcy5maW5pc2hlZFdvcmsgPVxuICAgICAgICB0aGlzLnBpbmdDYWNoZSA9XG4gICAgICAgIHRoaXMuY3VycmVudCA9XG4gICAgICAgIHRoaXMucGVuZGluZ0NoaWxkcmVuID1cbiAgICAgICAgICBudWxsO1xuICAgICAgdGhpcy50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICAgICAgdGhpcy5jYWxsYmFja05vZGUgPVxuICAgICAgICB0aGlzLm5leHQgPVxuICAgICAgICB0aGlzLnBlbmRpbmdDb250ZXh0ID1cbiAgICAgICAgdGhpcy5jb250ZXh0ID1cbiAgICAgICAgdGhpcy5jYW5jZWxQZW5kaW5nQ29tbWl0ID1cbiAgICAgICAgICBudWxsO1xuICAgICAgdGhpcy5jYWxsYmFja1ByaW9yaXR5ID0gMDtcbiAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWVzID0gY3JlYXRlTGFuZU1hcCgtMSk7XG4gICAgICB0aGlzLmVudGFuZ2xlZExhbmVzID1cbiAgICAgICAgdGhpcy5zaGVsbFN1c3BlbmRDb3VudGVyID1cbiAgICAgICAgdGhpcy5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyA9XG4gICAgICAgIHRoaXMuZmluaXNoZWRMYW5lcyA9XG4gICAgICAgIHRoaXMuZXhwaXJlZExhbmVzID1cbiAgICAgICAgdGhpcy53YXJtTGFuZXMgPVxuICAgICAgICB0aGlzLnBpbmdlZExhbmVzID1cbiAgICAgICAgdGhpcy5zdXNwZW5kZWRMYW5lcyA9XG4gICAgICAgIHRoaXMucGVuZGluZ0xhbmVzID1cbiAgICAgICAgICAwO1xuICAgICAgdGhpcy5lbnRhbmdsZW1lbnRzID0gY3JlYXRlTGFuZU1hcCgwKTtcbiAgICAgIHRoaXMuaGlkZGVuVXBkYXRlcyA9IGNyZWF0ZUxhbmVNYXAobnVsbCk7XG4gICAgICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4O1xuICAgICAgdGhpcy5vblVuY2F1Z2h0RXJyb3IgPSBvblVuY2F1Z2h0RXJyb3I7XG4gICAgICB0aGlzLm9uQ2F1Z2h0RXJyb3IgPSBvbkNhdWdodEVycm9yO1xuICAgICAgdGhpcy5vblJlY292ZXJhYmxlRXJyb3IgPSBvblJlY292ZXJhYmxlRXJyb3I7XG4gICAgICB0aGlzLnBvb2xlZENhY2hlID0gbnVsbDtcbiAgICAgIHRoaXMucG9vbGVkQ2FjaGVMYW5lcyA9IDA7XG4gICAgICB0aGlzLmZvcm1TdGF0ZSA9IGZvcm1TdGF0ZTtcbiAgICAgIHRoaXMuaW5jb21wbGV0ZVRyYW5zaXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSB0aGlzLmVmZmVjdER1cmF0aW9uID0gLTA7XG4gICAgICB0aGlzLm1lbW9pemVkVXBkYXRlcnMgPSBuZXcgU2V0KCk7XG4gICAgICBjb250YWluZXJJbmZvID0gdGhpcy5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gW107XG4gICAgICBmb3IgKHRhZyA9IDA7IDMxID4gdGFnOyB0YWcrKykgY29udGFpbmVySW5mby5wdXNoKG5ldyBTZXQoKSk7XG4gICAgICB0aGlzLl9kZWJ1Z1Jvb3RUeXBlID0gaHlkcmF0ZSA/IFwiaHlkcmF0ZVJvb3QoKVwiIDogXCJjcmVhdGVSb290KClcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KFxuICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgIHRhZyxcbiAgICAgIGh5ZHJhdGUsXG4gICAgICBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICBpc1N0cmljdE1vZGUsXG4gICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgIHRyYW5zaXRpb25DYWxsYmFja3MsXG4gICAgICBmb3JtU3RhdGVcbiAgICApIHtcbiAgICAgIGNvbnRhaW5lckluZm8gPSBuZXcgRmliZXJSb290Tm9kZShcbiAgICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgICAgdGFnLFxuICAgICAgICBoeWRyYXRlLFxuICAgICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgICAgZm9ybVN0YXRlXG4gICAgICApO1xuICAgICAgdGFnID0gMTtcbiAgICAgICEwID09PSBpc1N0cmljdE1vZGUgJiYgKHRhZyB8PSAyNCk7XG4gICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiAodGFnIHw9IDIpO1xuICAgICAgaXNTdHJpY3RNb2RlID0gY3JlYXRlRmliZXIoMywgbnVsbCwgbnVsbCwgdGFnKTtcbiAgICAgIGNvbnRhaW5lckluZm8uY3VycmVudCA9IGlzU3RyaWN0TW9kZTtcbiAgICAgIGlzU3RyaWN0TW9kZS5zdGF0ZU5vZGUgPSBjb250YWluZXJJbmZvO1xuICAgICAgdGFnID0gY3JlYXRlQ2FjaGUoKTtcbiAgICAgIHJldGFpbkNhY2hlKHRhZyk7XG4gICAgICBjb250YWluZXJJbmZvLnBvb2xlZENhY2hlID0gdGFnO1xuICAgICAgcmV0YWluQ2FjaGUodGFnKTtcbiAgICAgIGlzU3RyaWN0TW9kZS5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICBlbGVtZW50OiBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICAgIGlzRGVoeWRyYXRlZDogaHlkcmF0ZSxcbiAgICAgICAgY2FjaGU6IHRhZ1xuICAgICAgfTtcbiAgICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZShpc1N0cmljdE1vZGUpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lckluZm87XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBpZiAoIXBhcmVudENvbXBvbmVudCkgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgIHBhcmVudENvbXBvbmVudCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgIHJldHVybiBwYXJlbnRDb21wb25lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lclN5bmMoXG4gICAgICBlbGVtZW50LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgY2FsbGJhY2tcbiAgICApIHtcbiAgICAgIDAgPT09IGNvbnRhaW5lci50YWcgJiYgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgdXBkYXRlQ29udGFpbmVySW1wbChcbiAgICAgICAgY29udGFpbmVyLmN1cnJlbnQsXG4gICAgICAgIDIsXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDb250YWluZXJJbXBsKFxuICAgICAgcm9vdEZpYmVyLFxuICAgICAgbGFuZSxcbiAgICAgIGVsZW1lbnQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBpbmplY3RlZEhvb2sgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3RcbiAgICAgIClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdChyZW5kZXJlcklELCBjb250YWluZXIsIGVsZW1lbnQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlc1wiLFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTY2hlZHVsZWQobGFuZSk7XG4gICAgICBwYXJlbnRDb21wb25lbnQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuICAgICAgbnVsbCA9PT0gY29udGFpbmVyLmNvbnRleHRcbiAgICAgICAgPyAoY29udGFpbmVyLmNvbnRleHQgPSBwYXJlbnRDb21wb25lbnQpXG4gICAgICAgIDogKGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IHBhcmVudENvbXBvbmVudCk7XG4gICAgICBpc1JlbmRlcmluZyAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzICYmXG4gICAgICAgICgoZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy5cIixcbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnQpIHx8IFwiVW5rbm93blwiXG4gICAgICAgICkpO1xuICAgICAgY29udGFpbmVyID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgY29udGFpbmVyLnBheWxvYWQgPSB7IGVsZW1lbnQ6IGVsZW1lbnQgfTtcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwID09PSBjYWxsYmFjayA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjYWxsYmFjayAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICksXG4gICAgICAgIChjb250YWluZXIuY2FsbGJhY2sgPSBjYWxsYmFjaykpO1xuICAgICAgZWxlbWVudCA9IGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCBjb250YWluZXIsIGxhbmUpO1xuICAgICAgbnVsbCAhPT0gZWxlbWVudCAmJlxuICAgICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGVsZW1lbnQsIHJvb3RGaWJlciwgbGFuZSksXG4gICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMoZWxlbWVudCwgcm9vdEZpYmVyLCBsYW5lKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgICAgIGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBmaWJlciAmJiBudWxsICE9PSBmaWJlci5kZWh5ZHJhdGVkKSB7XG4gICAgICAgIHZhciBhID0gZmliZXIucmV0cnlMYW5lO1xuICAgICAgICBmaWJlci5yZXRyeUxhbmUgPSAwICE9PSBhICYmIGEgPCByZXRyeUxhbmUgPyBhIDogcmV0cnlMYW5lO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgcmV0cnlMYW5lKSB7XG4gICAgICBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKTtcbiAgICAgIChmaWJlciA9IGZpYmVyLmFsdGVybmF0ZSkgJiYgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExhbmVMYWJlbE1hcCgpIHtcbiAgICAgIGZvciAodmFyIG1hcCA9IG5ldyBNYXAoKSwgbGFuZSA9IDEsIGluZGV4ID0gMDsgMzEgPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgbGFiZWwgPSBnZXRMYWJlbEZvckxhbmUobGFuZSk7XG4gICAgICAgIG1hcC5zZXQobGFuZSwgbGFiZWwpO1xuICAgICAgICBsYW5lICo9IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICB2YXIgZXhwb3J0cyA9IHt9O1xuICAgIChcInVzZSBzdHJpY3RcIik7XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgU2NoZWR1bGVyID0gcmVxdWlyZShcInNjaGVkdWxlclwiKSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgICBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLFxuICAgICAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnNjb3BlXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5kZWJ1Z190cmFjZV9tb2RlXCIpO1xuICAgIHZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LmxlZ2FjeV9oaWRkZW5cIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnRyYWNpbmdfbWFya2VyXCIpO1xuICAgIHZhciBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIiksXG4gICAgICBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3IsXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgY3VycmVudCA9IG51bGwsXG4gICAgICBpc1JlbmRlcmluZyA9ICExLFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgcmVuZGVyZXJWZXJzaW9uID0gJCQkY29uZmlnLnJlbmRlcmVyVmVyc2lvbixcbiAgICAgIHJlbmRlcmVyUGFja2FnZU5hbWUgPSAkJCRjb25maWcucmVuZGVyZXJQYWNrYWdlTmFtZSxcbiAgICAgIGV4dHJhRGV2VG9vbHNDb25maWcgPSAkJCRjb25maWcuZXh0cmFEZXZUb29sc0NvbmZpZyxcbiAgICAgIGdldFB1YmxpY0luc3RhbmNlID0gJCQkY29uZmlnLmdldFB1YmxpY0luc3RhbmNlLFxuICAgICAgZ2V0Um9vdEhvc3RDb250ZXh0ID0gJCQkY29uZmlnLmdldFJvb3RIb3N0Q29udGV4dCxcbiAgICAgIGdldENoaWxkSG9zdENvbnRleHQgPSAkJCRjb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dCxcbiAgICAgIHByZXBhcmVGb3JDb21taXQgPSAkJCRjb25maWcucHJlcGFyZUZvckNvbW1pdCxcbiAgICAgIHJlc2V0QWZ0ZXJDb21taXQgPSAkJCRjb25maWcucmVzZXRBZnRlckNvbW1pdCxcbiAgICAgIGNyZWF0ZUluc3RhbmNlID0gJCQkY29uZmlnLmNyZWF0ZUluc3RhbmNlLFxuICAgICAgYXBwZW5kSW5pdGlhbENoaWxkID0gJCQkY29uZmlnLmFwcGVuZEluaXRpYWxDaGlsZCxcbiAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gJCQkY29uZmlnLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLFxuICAgICAgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSAkJCRjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICBjcmVhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuY3JlYXRlVGV4dEluc3RhbmNlLFxuICAgICAgc2NoZWR1bGVUaW1lb3V0ID0gJCQkY29uZmlnLnNjaGVkdWxlVGltZW91dCxcbiAgICAgIGNhbmNlbFRpbWVvdXQgPSAkJCRjb25maWcuY2FuY2VsVGltZW91dCxcbiAgICAgIG5vVGltZW91dCA9ICQkJGNvbmZpZy5ub1RpbWVvdXQsXG4gICAgICBpc1ByaW1hcnlSZW5kZXJlciA9ICQkJGNvbmZpZy5pc1ByaW1hcnlSZW5kZXJlcjtcbiAgICAkJCRjb25maWcud2FybnNJZk5vdEFjdGluZztcbiAgICB2YXIgc3VwcG9ydHNNdXRhdGlvbiA9ICQkJGNvbmZpZy5zdXBwb3J0c011dGF0aW9uLFxuICAgICAgc3VwcG9ydHNQZXJzaXN0ZW5jZSA9ICQkJGNvbmZpZy5zdXBwb3J0c1BlcnNpc3RlbmNlLFxuICAgICAgc3VwcG9ydHNIeWRyYXRpb24gPSAkJCRjb25maWcuc3VwcG9ydHNIeWRyYXRpb24sXG4gICAgICBnZXRJbnN0YW5jZUZyb21Ob2RlID0gJCQkY29uZmlnLmdldEluc3RhbmNlRnJvbU5vZGU7XG4gICAgJCQkY29uZmlnLmJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1cjtcbiAgICAkJCRjb25maWcuYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG4gICAgdmFyIHByZXBhcmVQb3J0YWxNb3VudCA9ICQkJGNvbmZpZy5wcmVwYXJlUG9ydGFsTW91bnQ7XG4gICAgJCQkY29uZmlnLnByZXBhcmVTY29wZVVwZGF0ZTtcbiAgICAkJCRjb25maWcuZ2V0SW5zdGFuY2VGcm9tU2NvcGU7XG4gICAgdmFyIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSA9ICQkJGNvbmZpZy5zZXRDdXJyZW50VXBkYXRlUHJpb3JpdHksXG4gICAgICBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkgPSAkJCRjb25maWcuZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5LFxuICAgICAgcmVzb2x2ZVVwZGF0ZVByaW9yaXR5ID0gJCQkY29uZmlnLnJlc29sdmVVcGRhdGVQcmlvcml0eTtcbiAgICAkJCRjb25maWcucmVzb2x2ZUV2ZW50VHlwZTtcbiAgICAkJCRjb25maWcucmVzb2x2ZUV2ZW50VGltZVN0YW1wO1xuICAgIHZhciBzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uID0gJCQkY29uZmlnLnNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24sXG4gICAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2UgPSAkJCRjb25maWcuZGV0YWNoRGVsZXRlZEluc3RhbmNlO1xuICAgICQkJGNvbmZpZy5yZXF1ZXN0UG9zdFBhaW50Q2FsbGJhY2s7XG4gICAgdmFyIG1heVN1c3BlbmRDb21taXQgPSAkJCRjb25maWcubWF5U3VzcGVuZENvbW1pdCxcbiAgICAgIHByZWxvYWRJbnN0YW5jZSA9ICQkJGNvbmZpZy5wcmVsb2FkSW5zdGFuY2UsXG4gICAgICBzdGFydFN1c3BlbmRpbmdDb21taXQgPSAkJCRjb25maWcuc3RhcnRTdXNwZW5kaW5nQ29tbWl0LFxuICAgICAgc3VzcGVuZEluc3RhbmNlID0gJCQkY29uZmlnLnN1c3BlbmRJbnN0YW5jZSxcbiAgICAgIHdhaXRGb3JDb21taXRUb0JlUmVhZHkgPSAkJCRjb25maWcud2FpdEZvckNvbW1pdFRvQmVSZWFkeSxcbiAgICAgIE5vdFBlbmRpbmdUcmFuc2l0aW9uID0gJCQkY29uZmlnLk5vdFBlbmRpbmdUcmFuc2l0aW9uLFxuICAgICAgSG9zdFRyYW5zaXRpb25Db250ZXh0ID0gJCQkY29uZmlnLkhvc3RUcmFuc2l0aW9uQ29udGV4dCxcbiAgICAgIHJlc2V0Rm9ybUluc3RhbmNlID0gJCQkY29uZmlnLnJlc2V0Rm9ybUluc3RhbmNlLFxuICAgICAgYmluZFRvQ29uc29sZSA9ICQkJGNvbmZpZy5iaW5kVG9Db25zb2xlLFxuICAgICAgc3VwcG9ydHNNaWNyb3Rhc2tzID0gJCQkY29uZmlnLnN1cHBvcnRzTWljcm90YXNrcyxcbiAgICAgIHNjaGVkdWxlTWljcm90YXNrID0gJCQkY29uZmlnLnNjaGVkdWxlTWljcm90YXNrLFxuICAgICAgc3VwcG9ydHNUZXN0U2VsZWN0b3JzID0gJCQkY29uZmlnLnN1cHBvcnRzVGVzdFNlbGVjdG9ycyxcbiAgICAgIGZpbmRGaWJlclJvb3QgPSAkJCRjb25maWcuZmluZEZpYmVyUm9vdCxcbiAgICAgIGdldEJvdW5kaW5nUmVjdCA9ICQkJGNvbmZpZy5nZXRCb3VuZGluZ1JlY3QsXG4gICAgICBnZXRUZXh0Q29udGVudCA9ICQkJGNvbmZpZy5nZXRUZXh0Q29udGVudCxcbiAgICAgIGlzSGlkZGVuU3VidHJlZSA9ICQkJGNvbmZpZy5pc0hpZGRlblN1YnRyZWUsXG4gICAgICBtYXRjaEFjY2Vzc2liaWxpdHlSb2xlID0gJCQkY29uZmlnLm1hdGNoQWNjZXNzaWJpbGl0eVJvbGUsXG4gICAgICBzZXRGb2N1c0lmRm9jdXNhYmxlID0gJCQkY29uZmlnLnNldEZvY3VzSWZGb2N1c2FibGUsXG4gICAgICBzZXR1cEludGVyc2VjdGlvbk9ic2VydmVyID0gJCQkY29uZmlnLnNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIsXG4gICAgICBhcHBlbmRDaGlsZCA9ICQkJGNvbmZpZy5hcHBlbmRDaGlsZCxcbiAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIgPSAkJCRjb25maWcuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcixcbiAgICAgIGNvbW1pdFRleHRVcGRhdGUgPSAkJCRjb25maWcuY29tbWl0VGV4dFVwZGF0ZSxcbiAgICAgIGNvbW1pdE1vdW50ID0gJCQkY29uZmlnLmNvbW1pdE1vdW50LFxuICAgICAgY29tbWl0VXBkYXRlID0gJCQkY29uZmlnLmNvbW1pdFVwZGF0ZSxcbiAgICAgIGluc2VydEJlZm9yZSA9ICQkJGNvbmZpZy5pbnNlcnRCZWZvcmUsXG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9ICQkJGNvbmZpZy5pbnNlcnRJbkNvbnRhaW5lckJlZm9yZSxcbiAgICAgIHJlbW92ZUNoaWxkID0gJCQkY29uZmlnLnJlbW92ZUNoaWxkLFxuICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyID0gJCQkY29uZmlnLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcixcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQgPSAkJCRjb25maWcucmVzZXRUZXh0Q29udGVudCxcbiAgICAgIGhpZGVJbnN0YW5jZSA9ICQkJGNvbmZpZy5oaWRlSW5zdGFuY2UsXG4gICAgICBoaWRlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLmhpZGVUZXh0SW5zdGFuY2UsXG4gICAgICB1bmhpZGVJbnN0YW5jZSA9ICQkJGNvbmZpZy51bmhpZGVJbnN0YW5jZSxcbiAgICAgIHVuaGlkZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy51bmhpZGVUZXh0SW5zdGFuY2UsXG4gICAgICBjbGVhckNvbnRhaW5lciA9ICQkJGNvbmZpZy5jbGVhckNvbnRhaW5lcixcbiAgICAgIGNsb25lSW5zdGFuY2UgPSAkJCRjb25maWcuY2xvbmVJbnN0YW5jZSxcbiAgICAgIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gJCQkY29uZmlnLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0ID0gJCQkY29uZmlnLmFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCxcbiAgICAgIGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4gPSAkJCRjb25maWcuZmluYWxpemVDb250YWluZXJDaGlsZHJlbixcbiAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9ICQkJGNvbmZpZy5yZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4sXG4gICAgICBjbG9uZUhpZGRlbkluc3RhbmNlID0gJCQkY29uZmlnLmNsb25lSGlkZGVuSW5zdGFuY2UsXG4gICAgICBjbG9uZUhpZGRlblRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5jbG9uZUhpZGRlblRleHRJbnN0YW5jZSxcbiAgICAgIGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcgPSAkJCRjb25maWcuaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyxcbiAgICAgIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrID0gJCQkY29uZmlnLmlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrLFxuICAgICAgZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzID1cbiAgICAgICAgJCQkY29uZmlnLmdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscyxcbiAgICAgIHJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5ID0gJCQkY29uZmlnLnJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5LFxuICAgICAgY2FuSHlkcmF0ZUZvcm1TdGF0ZU1hcmtlciA9ICQkJGNvbmZpZy5jYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyLFxuICAgICAgaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyA9ICQkJGNvbmZpZy5pc0Zvcm1TdGF0ZU1hcmtlck1hdGNoaW5nLFxuICAgICAgZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nID0gJCQkY29uZmlnLmdldE5leHRIeWRyYXRhYmxlU2libGluZyxcbiAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkID0gJCQkY29uZmlnLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIgPVxuICAgICAgICAkJCRjb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIsXG4gICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPVxuICAgICAgICAkJCRjb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlLFxuICAgICAgY2FuSHlkcmF0ZUluc3RhbmNlID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZUluc3RhbmNlID0gJCQkY29uZmlnLmh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGh5ZHJhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuaHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZSA9XG4gICAgICAgICQkJGNvbmZpZy5nZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgY29tbWl0SHlkcmF0ZWRDb250YWluZXIgPSAkJCRjb25maWcuY29tbWl0SHlkcmF0ZWRDb250YWluZXIsXG4gICAgICBjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UgPSAkJCRjb25maWcuY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5ID0gJCQkY29uZmlnLmNsZWFyU3VzcGVuc2VCb3VuZGFyeSxcbiAgICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIgPVxuICAgICAgICAkJCRjb25maWcuY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcixcbiAgICAgIHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzID1cbiAgICAgICAgJCQkY29uZmlnLnNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzLFxuICAgICAgZGlmZkh5ZHJhdGVkUHJvcHNGb3JEZXZXYXJuaW5ncyA9XG4gICAgICAgICQkJGNvbmZpZy5kaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzLFxuICAgICAgZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzID0gJCQkY29uZmlnLmRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyxcbiAgICAgIGRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MgPVxuICAgICAgICAkJCRjb25maWcuZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyxcbiAgICAgIHZhbGlkYXRlSHlkcmF0YWJsZUluc3RhbmNlID0gJCQkY29uZmlnLnZhbGlkYXRlSHlkcmF0YWJsZUluc3RhbmNlLFxuICAgICAgdmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLnZhbGlkYXRlSHlkcmF0YWJsZVRleHRJbnN0YW5jZSxcbiAgICAgIHN1cHBvcnRzUmVzb3VyY2VzID0gJCQkY29uZmlnLnN1cHBvcnRzUmVzb3VyY2VzLFxuICAgICAgaXNIb3N0SG9pc3RhYmxlVHlwZSA9ICQkJGNvbmZpZy5pc0hvc3RIb2lzdGFibGVUeXBlLFxuICAgICAgZ2V0SG9pc3RhYmxlUm9vdCA9ICQkJGNvbmZpZy5nZXRIb2lzdGFibGVSb290LFxuICAgICAgZ2V0UmVzb3VyY2UgPSAkJCRjb25maWcuZ2V0UmVzb3VyY2UsXG4gICAgICBhY3F1aXJlUmVzb3VyY2UgPSAkJCRjb25maWcuYWNxdWlyZVJlc291cmNlLFxuICAgICAgcmVsZWFzZVJlc291cmNlID0gJCQkY29uZmlnLnJlbGVhc2VSZXNvdXJjZSxcbiAgICAgIGh5ZHJhdGVIb2lzdGFibGUgPSAkJCRjb25maWcuaHlkcmF0ZUhvaXN0YWJsZSxcbiAgICAgIG1vdW50SG9pc3RhYmxlID0gJCQkY29uZmlnLm1vdW50SG9pc3RhYmxlLFxuICAgICAgdW5tb3VudEhvaXN0YWJsZSA9ICQkJGNvbmZpZy51bm1vdW50SG9pc3RhYmxlLFxuICAgICAgY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2UgPSAkJCRjb25maWcuY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2UsXG4gICAgICBwcmVwYXJlVG9Db21taXRIb2lzdGFibGVzID0gJCQkY29uZmlnLnByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXMsXG4gICAgICBtYXlSZXNvdXJjZVN1c3BlbmRDb21taXQgPSAkJCRjb25maWcubWF5UmVzb3VyY2VTdXNwZW5kQ29tbWl0LFxuICAgICAgcHJlbG9hZFJlc291cmNlID0gJCQkY29uZmlnLnByZWxvYWRSZXNvdXJjZSxcbiAgICAgIHN1c3BlbmRSZXNvdXJjZSA9ICQkJGNvbmZpZy5zdXNwZW5kUmVzb3VyY2UsXG4gICAgICBzdXBwb3J0c1NpbmdsZXRvbnMgPSAkJCRjb25maWcuc3VwcG9ydHNTaW5nbGV0b25zLFxuICAgICAgcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlID0gJCQkY29uZmlnLnJlc29sdmVTaW5nbGV0b25JbnN0YW5jZSxcbiAgICAgIGNsZWFyU2luZ2xldG9uID0gJCQkY29uZmlnLmNsZWFyU2luZ2xldG9uLFxuICAgICAgYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlID0gJCQkY29uZmlnLmFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZSxcbiAgICAgIHJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZSA9ICQkJGNvbmZpZy5yZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UsXG4gICAgICBpc0hvc3RTaW5nbGV0b25UeXBlID0gJCQkY29uZmlnLmlzSG9zdFNpbmdsZXRvblR5cGUsXG4gICAgICB2YWx1ZVN0YWNrID0gW107XG4gICAgdmFyIGZpYmVyU3RhY2sgPSBbXTtcbiAgICB2YXIgaW5kZXgkanNjb21wJDAgPSAtMSxcbiAgICAgIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuICAgIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbiAgICB2YXIgY2x6MzIgPSBNYXRoLmNsejMyID8gTWF0aC5jbHozMiA6IGNsejMyRmFsbGJhY2ssXG4gICAgICBsb2ckMSA9IE1hdGgubG9nLFxuICAgICAgTE4yID0gTWF0aC5MTjIsXG4gICAgICBuZXh0VHJhbnNpdGlvbkxhbmUgPSAxMjgsXG4gICAgICBuZXh0UmV0cnlMYW5lID0gNDE5NDMwNCxcbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2skMyA9IFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLFxuICAgICAgY2FuY2VsQ2FsbGJhY2skMSA9IFNjaGVkdWxlci51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayxcbiAgICAgIHNob3VsZFlpZWxkID0gU2NoZWR1bGVyLnVuc3RhYmxlX3Nob3VsZFlpZWxkLFxuICAgICAgcmVxdWVzdFBhaW50ID0gU2NoZWR1bGVyLnVuc3RhYmxlX3JlcXVlc3RQYWludCxcbiAgICAgIG5vdyQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdyxcbiAgICAgIEltbWVkaWF0ZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5LFxuICAgICAgVXNlckJsb2NraW5nUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksXG4gICAgICBOb3JtYWxQcmlvcml0eSQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICAgICAgSWRsZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0lkbGVQcmlvcml0eSxcbiAgICAgIGxvZyA9IFNjaGVkdWxlci5sb2csXG4gICAgICB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSA9IFNjaGVkdWxlci51bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSxcbiAgICAgIHJlbmRlcmVySUQgPSBudWxsLFxuICAgICAgaW5qZWN0ZWRIb29rID0gbnVsbCxcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MgPSBudWxsLFxuICAgICAgaGFzTG9nZ2VkRXJyb3IgPSAhMSxcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ID0gXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyxcbiAgICAgIG9iamVjdElzID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogaXMsXG4gICAgICBDYXB0dXJlZFN0YWNrcyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBmb3JrU3RhY2sgPSBbXSxcbiAgICAgIGZvcmtTdGFja0luZGV4ID0gMCxcbiAgICAgIHRyZWVGb3JrUHJvdmlkZXIgPSBudWxsLFxuICAgICAgdHJlZUZvcmtDb3VudCA9IDAsXG4gICAgICBpZFN0YWNrID0gW10sXG4gICAgICBpZFN0YWNrSW5kZXggPSAwLFxuICAgICAgdHJlZUNvbnRleHRQcm92aWRlciA9IG51bGwsXG4gICAgICB0cmVlQ29udGV4dElkID0gMSxcbiAgICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBcIlwiLFxuICAgICAgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBuZWVkc0VzY2FwaW5nID0gL1tcIicmPD5cXG5cXHRdfF5cXHN8XFxzJC8sXG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGwsXG4gICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbCxcbiAgICAgIGlzSHlkcmF0aW5nID0gITEsXG4gICAgICBkaWRTdXNwZW5kT3JFcnJvckRFViA9ICExLFxuICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsLFxuICAgICAgaHlkcmF0aW9uRXJyb3JzID0gbnVsbCxcbiAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMSxcbiAgICAgIEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiSHlkcmF0aW9uIE1pc21hdGNoIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yLCBhbmQgc2hvdWxkIG5vdCBsZWFrIGludG8gdXNlcnNwYWNlLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIGl0J3MgbGlrZWx5IGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICApLFxuICAgICAgTm9Nb2RlID0gMCxcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXMgPSBbXSxcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNJbmRleCA9IDAsXG4gICAgICBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgPSAwLFxuICAgICAgbm93ID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdyxcbiAgICAgIGNvbW1pdFN0YXJ0VGltZSA9IC0wLFxuICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMS4xLFxuICAgICAgcHJvZmlsZXJFZmZlY3REdXJhdGlvbiA9IC0wLFxuICAgICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkID0gITEsXG4gICAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSAhMSxcbiAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG51bGwsXG4gICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGwsXG4gICAgICBkaWRTY2hlZHVsZU1pY3JvdGFzayA9ICExLFxuICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0ID0gITEsXG4gICAgICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSAhMSxcbiAgICAgIGlzRmx1c2hpbmdXb3JrID0gITEsXG4gICAgICBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IDAsXG4gICAgICBmYWtlQWN0Q2FsbGJhY2tOb2RlJDEgPSB7fSxcbiAgICAgIGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBudWxsLFxuICAgICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9IDAsXG4gICAgICBjdXJyZW50RW50YW5nbGVkTGFuZSA9IDAsXG4gICAgICBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBudWxsLFxuICAgICAgVXBkYXRlU3RhdGUgPSAwLFxuICAgICAgUmVwbGFjZVN0YXRlID0gMSxcbiAgICAgIEZvcmNlVXBkYXRlID0gMixcbiAgICAgIENhcHR1cmVVcGRhdGUgPSAzLFxuICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgICB2YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9ICExO1xuICAgIHZhciBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICAgIHZhciBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITEsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncyA9IHtcbiAgICAgICAgcmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIHJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZzogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGRpc2NhcmRQZW5kaW5nV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9XG4gICAgICB9LFxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdLFxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdLFxuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXSxcbiAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoXG4gICAgICBmaWJlcixcbiAgICAgIGluc3RhbmNlXG4gICAgKSB7XG4gICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSB8fFxuICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgITAgIT09IGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICYmXG4gICAgICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBmaWJlci5tb2RlICYgOCAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgITAgIT09XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgJiZcbiAgICAgICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBmaWJlci5tb2RlICYgOCAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlciksXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAhMCAhPT0gaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICYmXG4gICAgICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKSxcbiAgICAgICAgZmliZXIubW9kZSAmIDggJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLnB1c2goZmliZXIpKTtcbiAgICB9O1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggJiZcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdKSk7XG4gICAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgfSksXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW10pKTtcbiAgICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChcbiAgICAgICAgICBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgfSksXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW10pKTtcbiAgICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW10pKTtcbiAgICAgIGlmICgwIDwgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUpIHtcbiAgICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoXG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIDAgPCBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFxuICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXNcbiAgICAgICAgKSksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4qIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIHJlZmFjdG9yIHlvdXIgY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGVyaXZlZC1zdGF0ZVxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSAmJlxuICAgICAgICAoKHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoXG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lc1xuICAgICAgICApKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlVzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKSksXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcImNvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4qIFJlbmFtZSBjb21wb25lbnRXaWxsTW91bnQgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiBUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuIGBucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplICYmXG4gICAgICAgICgoc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhcbiAgICAgICAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXNcbiAgICAgICAgKSksXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgcmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kZXJpdmVkLXN0YXRlXFxuKiBSZW5hbWUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiBUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuIGBucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplICYmXG4gICAgICAgICgoc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMpKSxcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiY29tcG9uZW50V2lsbFVwZGF0ZSBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuKiBSZW5hbWUgY29tcG9uZW50V2lsbFVwZGF0ZSB0byBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiBUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuIGBucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgIH07XG4gICAgdmFyIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKSxcbiAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQgPSBuZXcgU2V0KCk7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoXG4gICAgICBmaWJlcixcbiAgICAgIGluc3RhbmNlXG4gICAgKSB7XG4gICAgICB2YXIgc3RyaWN0Um9vdCA9IG51bGw7XG4gICAgICBmb3IgKHZhciBub2RlID0gZmliZXI7IG51bGwgIT09IG5vZGU7IClcbiAgICAgICAgbm9kZS5tb2RlICYgOCAmJiAoc3RyaWN0Um9vdCA9IG5vZGUpLCAobm9kZSA9IG5vZGUucmV0dXJuKTtcbiAgICAgIG51bGwgPT09IHN0cmljdFJvb3RcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBmaW5kIGEgU3RyaWN0TW9kZSBjb21wb25lbnQgaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKVxuICAgICAgICA6ICFkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSAmJlxuICAgICAgICAgICgobm9kZSA9IHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5nZXQoc3RyaWN0Um9vdCkpLFxuICAgICAgICAgIG51bGwgIT0gZmliZXIudHlwZS5jb250ZXh0VHlwZXMgfHxcbiAgICAgICAgICAgIG51bGwgIT0gZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyB8fFxuICAgICAgICAgICAgKG51bGwgIT09IGluc3RhbmNlICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCkpICYmXG4gICAgICAgICAgKHZvaWQgMCA9PT0gbm9kZSAmJlxuICAgICAgICAgICAgKChub2RlID0gW10pLCBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuc2V0KHN0cmljdFJvb3QsIG5vZGUpKSxcbiAgICAgICAgICBub2RlLnB1c2goZmliZXIpKTtcbiAgICB9O1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZm9yRWFjaChmdW5jdGlvbiAoZmliZXJBcnJheSkge1xuICAgICAgICBpZiAoMCAhPT0gZmliZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZmlyc3RGaWJlciA9IGZpYmVyQXJyYXlbMF0sXG4gICAgICAgICAgICB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBmaWJlckFycmF5LmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIik7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmlyc3RGaWJlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJMZWdhY3kgY29udGV4dCBBUEkgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIGEgc3RyaWN0LW1vZGUgdHJlZS5cXG5cXG5UaGUgb2xkIEFQSSB3aWxsIGJlIHN1cHBvcnRlZCBpbiBhbGwgMTYueCByZWxlYXNlcywgYnV0IGFwcGxpY2F0aW9ucyB1c2luZyBpdCBzaG91bGQgbWlncmF0ZSB0byB0aGUgbmV3IHZlcnNpb24uXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dFwiLFxuICAgICAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTtcbiAgICB9O1xuICAgIHZhciBTdXNwZW5zZUV4Y2VwdGlvbiA9IEVycm9yKFxuICAgICAgICBcIlN1c3BlbnNlIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yISBJdCdzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiBgdXNlYCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgcmVuZGVyLiBZb3UgbXVzdCBlaXRoZXIgcmV0aHJvdyBpdCBpbW1lZGlhdGVseSwgb3IgbW92ZSB0aGUgYHVzZWAgY2FsbCBvdXRzaWRlIG9mIHRoZSBgdHJ5L2NhdGNoYCBibG9jay4gQ2FwdHVyaW5nIHdpdGhvdXQgcmV0aHJvd2luZyB3aWxsIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvci5cXG5cXG5UbyBoYW5kbGUgYXN5bmMgZXJyb3JzLCB3cmFwIHlvdXIgY29tcG9uZW50IGluIGFuIGVycm9yIGJvdW5kYXJ5LCBvciBjYWxsIHRoZSBwcm9taXNlJ3MgYC5jYXRjaGAgbWV0aG9kIGFuZCBwYXNzIHRoZSByZXN1bHQgdG8gYHVzZWBcIlxuICAgICAgKSxcbiAgICAgIFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvbiA9IEVycm9yKFxuICAgICAgICBcIlN1c3BlbnNlIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yLCBhbmQgc2hvdWxkIG5vdCBsZWFrIGludG8gdXNlcnNwYWNlLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIGl0J3MgbGlrZWx5IGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICApLFxuICAgICAgbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlID0ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdJbnRlcm5hbCBSZWFjdCBlcnJvcjogQSBsaXN0ZW5lciB3YXMgdW5leHBlY3RlZGx5IGF0dGFjaGVkIHRvIGEgXCJub29wXCIgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsLFxuICAgICAgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSAhMSxcbiAgICAgIGNhbGxDb21wb25lbnQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpIHtcbiAgICAgICAgICB2YXIgd2FzUmVuZGVyaW5nID0gaXNSZW5kZXJpbmc7XG4gICAgICAgICAgaXNSZW5kZXJpbmcgPSAhMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaXNSZW5kZXJpbmcgPSB3YXNSZW5kZXJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENvbXBvbmVudEluREVWID1cbiAgICAgICAgY2FsbENvbXBvbmVudFtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxDb21wb25lbnQpLFxuICAgICAgY2FsbFJlbmRlciA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgdmFyIHdhc1JlbmRlcmluZyA9IGlzUmVuZGVyaW5nO1xuICAgICAgICAgIGlzUmVuZGVyaW5nID0gITA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaXNSZW5kZXJpbmcgPSB3YXNSZW5kZXJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbFJlbmRlckluREVWID0gY2FsbFJlbmRlcltcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxSZW5kZXIpLFxuICAgICAgY2FsbENvbXBvbmVudERpZE1vdW50ID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoZmluaXNoZWRXb3JrLCBpbnN0YW5jZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50RGlkTW91bnRJbkRFViA9IGNhbGxDb21wb25lbnREaWRNb3VudFtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIlxuICAgICAgXS5iaW5kKGNhbGxDb21wb25lbnREaWRNb3VudCksXG4gICAgICBjYWxsQ29tcG9uZW50RGlkVXBkYXRlID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICBwcmV2U3RhdGUsXG4gICAgICAgICAgc25hcHNob3RcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgc25hcHNob3QpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50RGlkVXBkYXRlSW5ERVYgPSBjYWxsQ29tcG9uZW50RGlkVXBkYXRlW1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXG4gICAgICBdLmJpbmQoY2FsbENvbXBvbmVudERpZFVwZGF0ZSksXG4gICAgICBjYWxsQ29tcG9uZW50RGlkQ2F0Y2ggPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChpbnN0YW5jZSwgZXJyb3JJbmZvKSB7XG4gICAgICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoKGVycm9ySW5mby52YWx1ZSwge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2s6IG51bGwgIT09IHN0YWNrID8gc3RhY2sgOiBcIlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50RGlkQ2F0Y2hJbkRFViA9IGNhbGxDb21wb25lbnREaWRDYXRjaFtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIlxuICAgICAgXS5iaW5kKGNhbGxDb21wb25lbnREaWRDYXRjaCksXG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRJbkRFViA9IGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIlxuICAgICAgXS5iaW5kKGNhbGxDb21wb25lbnRXaWxsVW5tb3VudCksXG4gICAgICBjYWxsQ3JlYXRlID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoZWZmZWN0KSB7XG4gICAgICAgICAgdmFyIGNyZWF0ZSA9IGVmZmVjdC5jcmVhdGU7XG4gICAgICAgICAgZWZmZWN0ID0gZWZmZWN0Lmluc3Q7XG4gICAgICAgICAgY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgICAgICAgcmV0dXJuIChlZmZlY3QuZGVzdHJveSA9IGNyZWF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ3JlYXRlSW5ERVYgPSBjYWxsQ3JlYXRlW1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbENyZWF0ZSksXG4gICAgICBjYWxsRGVzdHJveSA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICBkZXN0cm95XG4gICAgICAgICkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsRGVzdHJveUluREVWID1cbiAgICAgICAgY2FsbERlc3Ryb3lbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsRGVzdHJveSksXG4gICAgICBjYWxsTGF6eUluaXQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChsYXp5KSB7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Ll9pbml0O1xuICAgICAgICAgIHJldHVybiBpbml0KGxhenkuX3BheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbExhenlJbml0SW5ERVYgPVxuICAgICAgICBjYWxsTGF6eUluaXRbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsTGF6eUluaXQpLFxuICAgICAgdGhlbmFibGVTdGF0ZSQxID0gbnVsbCxcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwLFxuICAgICAgY3VycmVudERlYnVnSW5mbyA9IG51bGwsXG4gICAgICBkaWRXYXJuQWJvdXRNYXBzO1xuICAgIHZhciBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gKGRpZFdhcm5BYm91dE1hcHMgPSAhMSk7XG4gICAgdmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuICAgIHZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcbiAgICB2YXIgb3duZXJIYXNTeW1ib2xUeXBlV2FybmluZyA9IHt9O1xuICAgIHdhcm5Gb3JNaXNzaW5nS2V5ID0gZnVuY3Rpb24gKHJldHVybkZpYmVyLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gY2hpbGQgJiZcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGNoaWxkICYmXG4gICAgICAgIGNoaWxkLl9zdG9yZSAmJlxuICAgICAgICAoKCFjaGlsZC5fc3RvcmUudmFsaWRhdGVkICYmIG51bGwgPT0gY2hpbGQua2V5KSB8fFxuICAgICAgICAgIDIgPT09IGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQpXG4gICAgICApIHtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBjaGlsZC5fc3RvcmUpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSAxO1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpLFxuICAgICAgICAgIGNvbXBvbmVudEtleSA9IGNvbXBvbmVudE5hbWUgfHwgXCJudWxsXCI7XG4gICAgICAgIGlmICghb3duZXJIYXNLZXlVc2VXYXJuaW5nW2NvbXBvbmVudEtleV0pIHtcbiAgICAgICAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50S2V5XSA9ICEwO1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuX293bmVyO1xuICAgICAgICAgIHJldHVybkZpYmVyID0gcmV0dXJuRmliZXIuX2RlYnVnT3duZXI7XG4gICAgICAgICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBcIlwiO1xuICAgICAgICAgIHJldHVybkZpYmVyICYmXG4gICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgcmV0dXJuRmliZXIudGFnICYmXG4gICAgICAgICAgICAoY29tcG9uZW50S2V5ID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikpICYmXG4gICAgICAgICAgICAoY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9XG4gICAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYFwiICsgY29tcG9uZW50S2V5ICsgXCJgLlwiKTtcbiAgICAgICAgICBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIHx8XG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSAmJlxuICAgICAgICAgICAgICAoY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9XG4gICAgICAgICAgICAgICAgXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSArXG4gICAgICAgICAgICAgICAgXCI+LlwiKSk7XG4gICAgICAgICAgdmFyIGNoaWxkT3duZXJBcHBlbmRpeCA9IFwiXCI7XG4gICAgICAgICAgbnVsbCAhPSBjaGlsZCAmJlxuICAgICAgICAgICAgcmV0dXJuRmliZXIgIT09IGNoaWxkICYmXG4gICAgICAgICAgICAoKGNvbXBvbmVudE5hbWUgPSBudWxsKSxcbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBjaGlsZC50YWdcbiAgICAgICAgICAgICAgPyAoY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY2hpbGQpKVxuICAgICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZC5uYW1lICYmIChjb21wb25lbnROYW1lID0gY2hpbGQubmFtZSksXG4gICAgICAgICAgICBjb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICAgIChjaGlsZE93bmVyQXBwZW5kaXggPVxuICAgICAgICAgICAgICAgIFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgY29tcG9uZW50TmFtZSArIFwiLlwiKSk7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYod29ya0luUHJvZ3Jlc3MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICAgICAgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyxcbiAgICAgICAgICAgICAgY2hpbGRPd25lckFwcGVuZGl4XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBjcmVhdGVDaGlsZFJlY29uY2lsZXIoITApLFxuICAgICAgbW91bnRDaGlsZEZpYmVycyA9IGNyZWF0ZUNoaWxkUmVjb25jaWxlcighMSksXG4gICAgICBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKDApLFxuICAgICAgc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBzaGVsbEJvdW5kYXJ5ID0gbnVsbCxcbiAgICAgIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrID0gMSxcbiAgICAgIEZvcmNlU3VzcGVuc2VGYWxsYmFjayA9IDIsXG4gICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKDApLFxuICAgICAgTm9GbGFncyA9IDAsXG4gICAgICBIYXNFZmZlY3QgPSAxLFxuICAgICAgSW5zZXJ0aW9uID0gMixcbiAgICAgIExheW91dCA9IDQsXG4gICAgICBQYXNzaXZlID0gOCxcbiAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90O1xuICAgIHZhciBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciByZW5kZXJMYW5lcyA9IDAsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbCxcbiAgICAgIGN1cnJlbnRIb29rID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGwsXG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITEsXG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSAhMSxcbiAgICAgIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWID0gITEsXG4gICAgICBsb2NhbElkQ291bnRlciA9IDAsXG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDAsXG4gICAgICB0aGVuYWJsZVN0YXRlID0gbnVsbCxcbiAgICAgIGdsb2JhbENsaWVudElkQ291bnRlciA9IDAsXG4gICAgICBSRV9SRU5ERVJfTElNSVQgPSAyNSxcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbCxcbiAgICAgIGhvb2tUeXBlc0RldiA9IG51bGwsXG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xLFxuICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSAhMTtcbiAgICB2YXIgY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGxhc3RFZmZlY3Q6IG51bGwsIGV2ZW50czogbnVsbCwgc3RvcmVzOiBudWxsLCBtZW1vQ2FjaGU6IG51bGwgfTtcbiAgICB9O1xuICAgIHZhciBDb250ZXh0T25seURpc3BhdGNoZXIgPSB7XG4gICAgICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gICAgICB1c2U6IHVzZSxcbiAgICAgIHVzZUNhbGxiYWNrOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VFZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZUxheW91dEVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VNZW1vOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VSZWR1Y2VyOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VSZWY6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZVN0YXRlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VUcmFuc2l0aW9uOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlSWQ6IHRocm93SW52YWxpZEhvb2tFcnJvclxuICAgIH07XG4gICAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUNhY2hlUmVmcmVzaCA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlTWVtb0NhY2hlID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlRm9ybVN0YXRlID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VBY3Rpb25TdGF0ZSA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlT3B0aW1pc3RpYyA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICB2YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbCxcbiAgICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSBudWxsLFxuICAgICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGwsXG4gICAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsLFxuICAgICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGwsXG4gICAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGwsXG4gICAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogdXNlLFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIG1vdW50RWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uLCBpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uLFxuICAgICAgaW5pdGlhbFN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogdXNlLFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICBtb3VudEVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uLFxuICAgICAgaW5pdGlhbFN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uLFxuICAgICAgaW5pdGlhbFN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2hcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiB1c2UsXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2gsXG4gICAgICByZWR1Y2VyXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogdXNlLFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdXBkYXRlRWZmZWN0SW1wbCgyMDQ4LCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoXG4gICAgICBwYXNzdGhyb3VnaCxcbiAgICAgIHJlZHVjZXJcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZSh1c2FibGUpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgbW91bnRFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWZyZXNoKCk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtb0NhY2hlOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZU1lbW9DYWNoZShzaXplKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPVxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb24sXG4gICAgICBpbml0aWFsU3RhdGVcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb24sXG4gICAgICBpbml0aWFsU3RhdGVcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2hcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICByZXR1cm4gdXNlKHVzYWJsZSk7XG4gICAgICB9LFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdXBkYXRlRWZmZWN0SW1wbCgyMDQ4LCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvblxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2gsXG4gICAgICByZWR1Y2VyXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2UodXNhYmxlKTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vQ2FjaGU6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICByZXR1cm4gdXNlTWVtb0NhY2hlKHNpemUpO1xuICAgICAgfVxuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvblxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2gsXG4gICAgICByZWR1Y2VyXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gICAgdmFyIGZha2VJbnRlcm5hbEluc3RhbmNlID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG4gICAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgdmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgICAgICAgaXNNb3VudGVkOiBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIG93bmVyID0gY3VycmVudDtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gb3duZXIgJiYgaXNSZW5kZXJpbmcgJiYgMSA9PT0gb3duZXIudGFnKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBvd25lci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgfHxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gcmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCBuZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyByZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCBjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyKSB8fCBcIkEgY29tcG9uZW50XCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKGNvbXBvbmVudCA9IGNvbXBvbmVudC5fcmVhY3RJbnRlcm5hbHMpXG4gICAgICAgICAgICA/IGdldE5lYXJlc3RNb3VudGVkRmliZXIoY29tcG9uZW50KSA9PT0gY29tcG9uZW50XG4gICAgICAgICAgICA6ICExO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICAgIGluc3QgPSBpbnN0Ll9yZWFjdEludGVybmFscztcbiAgICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGluc3QpLFxuICAgICAgICAgICAgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgKHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayksICh1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaykpO1xuICAgICAgICAgIHBheWxvYWQgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgICAgbnVsbCAhPT0gcGF5bG9hZCAmJlxuICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXlsb2FkLCBpbnN0LCBsYW5lKSxcbiAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocGF5bG9hZCwgaW5zdCwgbGFuZSkpO1xuICAgICAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChpbnN0LCBsYW5lKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoaW5zdCksXG4gICAgICAgICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnRhZyA9IFJlcGxhY2VTdGF0ZTtcbiAgICAgICAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICh3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spLCAodXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2spKTtcbiAgICAgICAgICBwYXlsb2FkID0gZW5xdWV1ZVVwZGF0ZShpbnN0LCB1cGRhdGUsIGxhbmUpO1xuICAgICAgICAgIG51bGwgIT09IHBheWxvYWQgJiZcbiAgICAgICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF5bG9hZCwgaW5zdCwgbGFuZSksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHBheWxvYWQsIGluc3QsIGxhbmUpKTtcbiAgICAgICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoaW5zdCwgbGFuZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoaW5zdCksXG4gICAgICAgICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuICAgICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAod2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSwgKHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrKSk7XG4gICAgICAgICAgY2FsbGJhY2sgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIoY2FsbGJhY2ssIGluc3QsIGxhbmUpLFxuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhjYWxsYmFjaywgaW5zdCwgbGFuZSkpO1xuICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkICYmXG4gICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChpbnN0LCBsYW5lKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVwb3J0RXJyb3JcbiAgICAgICAgICA/IHJlcG9ydEVycm9yXG4gICAgICAgICAgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB3aW5kb3cgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB3aW5kb3cuRXJyb3JFdmVudFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgd2luZG93LkVycm9yRXZlbnQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9jZXNzICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJvY2Vzcy5lbWl0XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuY2F1Z2h0RXhjZXB0aW9uXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgY29tcG9uZW50TmFtZSA9IG51bGwsXG4gICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGwsXG4gICAgICBTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb24gPSBFcnJvcihcbiAgICAgICAgXCJUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IuIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIFJlYWN0J3Mgc2VsZWN0aXZlIGh5ZHJhdGlvbiBmZWF0dXJlLiBJZiB0aGlzIGxlYWtzIGludG8gdXNlcnNwYWNlLCBpdCdzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgKSxcbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAhMTtcbiAgICB2YXIgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSAhMTtcbiAgICB2YXIgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXIgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0VGFpbE9wdGlvbnMgPSB7fTtcbiAgICB2YXIgU1VTUEVOREVEX01BUktFUiA9IHtcbiAgICAgICAgZGVoeWRyYXRlZDogbnVsbCxcbiAgICAgICAgdHJlZUNvbnRleHQ6IG51bGwsXG4gICAgICAgIHJldHJ5TGFuZTogMFxuICAgICAgfSxcbiAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gITEsXG4gICAgICB2YWx1ZUN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbiAgICB2YXIgcmVuZGVyZXJDdXJzb3JERVYgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG4gICAgdmFyIHJlbmRlcmVyMkN1cnNvckRFViA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbiAgICB2YXIgcmVuZGVyZXJTaWdpbCA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGwsXG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsLFxuICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICExLFxuICAgICAgQWJvcnRDb250cm9sbGVyTG9jYWwgPVxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgQWJvcnRDb250cm9sbGVyXG4gICAgICAgICAgPyBBYm9ydENvbnRyb2xsZXJcbiAgICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdLFxuICAgICAgICAgICAgICAgIHNpZ25hbCA9ICh0aGlzLnNpZ25hbCA9IHtcbiAgICAgICAgICAgICAgICAgIGFib3J0ZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzaWduYWwuYWJvcnRlZCA9ICEwO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgc2NoZWR1bGVDYWxsYmFjayQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssXG4gICAgICBOb3JtYWxQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxcbiAgICAgIENhY2hlQ29udGV4dCA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgICAgQ29uc3VtZXI6IG51bGwsXG4gICAgICAgIFByb3ZpZGVyOiBudWxsLFxuICAgICAgICBfY3VycmVudFZhbHVlOiBudWxsLFxuICAgICAgICBfY3VycmVudFZhbHVlMjogbnVsbCxcbiAgICAgICAgX3RocmVhZENvdW50OiAwLFxuICAgICAgICBfY3VycmVudFJlbmRlcmVyOiBudWxsLFxuICAgICAgICBfY3VycmVudFJlbmRlcmVyMjogbnVsbFxuICAgICAgfSxcbiAgICAgIHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uLCByZXR1cm5WYWx1ZSkge1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlICYmXG4gICAgICAgIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gJiZcbiAgICAgICAgZW50YW5nbGVBc3luY0FjdGlvbih0cmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgICBudWxsICE9PSBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgcHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICB9O1xuICAgIHZhciByZXN1bWVkQ2FjaGUgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG4gICAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9ICExLFxuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9ICExLFxuICAgICAgbmVlZHNGb3JtUmVzZXQgPSAhMSxcbiAgICAgIFBvc3NpYmx5V2Vha1NldCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtTZXQgPyBXZWFrU2V0IDogU2V0LFxuICAgICAgbmV4dEVmZmVjdCA9IG51bGwsXG4gICAgICBpblByb2dyZXNzTGFuZXMgPSBudWxsLFxuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsLFxuICAgICAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gITEsXG4gICAgICBob3N0UGFyZW50ID0gbnVsbCxcbiAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExLFxuICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBudWxsLFxuICAgICAgc3VzcGVuc2V5Q29tbWl0RmxhZyA9IDgxOTIsXG4gICAgICBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyID0ge1xuICAgICAgICBnZXRDYWNoZUZvclR5cGU6IGZ1bmN0aW9uIChyZXNvdXJjZVR5cGUpIHtcbiAgICAgICAgICB2YXIgY2FjaGUgPSByZWFkQ29udGV4dChDYWNoZUNvbnRleHQpLFxuICAgICAgICAgICAgY2FjaGVGb3JUeXBlID0gY2FjaGUuZGF0YS5nZXQocmVzb3VyY2VUeXBlKTtcbiAgICAgICAgICB2b2lkIDAgPT09IGNhY2hlRm9yVHlwZSAmJlxuICAgICAgICAgICAgKChjYWNoZUZvclR5cGUgPSByZXNvdXJjZVR5cGUoKSksXG4gICAgICAgICAgICBjYWNoZS5kYXRhLnNldChyZXNvdXJjZVR5cGUsIGNhY2hlRm9yVHlwZSkpO1xuICAgICAgICAgIHJldHVybiBjYWNoZUZvclR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE93bmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDT01QT05FTlRfVFlQRSA9IDAsXG4gICAgICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSAxLFxuICAgICAgUk9MRV9UWVBFID0gMixcbiAgICAgIFRFU1RfTkFNRV9UWVBFID0gMyxcbiAgICAgIFRFWFRfVFlQRSA9IDQ7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuZm9yKSB7XG4gICAgICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgICAgIENPTVBPTkVOVF9UWVBFID0gc3ltYm9sRm9yKFwic2VsZWN0b3IuY29tcG9uZW50XCIpO1xuICAgICAgSEFTX1BTRVVET19DTEFTU19UWVBFID0gc3ltYm9sRm9yKFwic2VsZWN0b3IuaGFzX3BzZXVkb19jbGFzc1wiKTtcbiAgICAgIFJPTEVfVFlQRSA9IHN5bWJvbEZvcihcInNlbGVjdG9yLnJvbGVcIik7XG4gICAgICBURVNUX05BTUVfVFlQRSA9IHN5bWJvbEZvcihcInNlbGVjdG9yLnRlc3RfaWRcIik7XG4gICAgICBURVhUX1RZUEUgPSBzeW1ib2xGb3IoXCJzZWxlY3Rvci50ZXh0XCIpO1xuICAgIH1cbiAgICB2YXIgY29tbWl0SG9va3MgPSBbXSxcbiAgICAgIFBvc3NpYmx5V2Vha01hcCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwLFxuICAgICAgTm9Db250ZXh0ID0gMCxcbiAgICAgIFJlbmRlckNvbnRleHQgPSAyLFxuICAgICAgQ29tbWl0Q29udGV4dCA9IDQsXG4gICAgICBSb290SW5Qcm9ncmVzcyA9IDAsXG4gICAgICBSb290RmF0YWxFcnJvcmVkID0gMSxcbiAgICAgIFJvb3RFcnJvcmVkID0gMixcbiAgICAgIFJvb3RTdXNwZW5kZWQgPSAzLFxuICAgICAgUm9vdFN1c3BlbmRlZFdpdGhEZWxheSA9IDQsXG4gICAgICBSb290Q29tcGxldGVkID0gNSxcbiAgICAgIFJvb3REaWROb3RDb21wbGV0ZSA9IDYsXG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gTm9Db250ZXh0LFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCxcbiAgICAgIE5vdFN1c3BlbmRlZCA9IDAsXG4gICAgICBTdXNwZW5kZWRPbkVycm9yID0gMSxcbiAgICAgIFN1c3BlbmRlZE9uRGF0YSA9IDIsXG4gICAgICBTdXNwZW5kZWRPbkltbWVkaWF0ZSA9IDMsXG4gICAgICBTdXNwZW5kZWRPbkluc3RhbmNlID0gNCxcbiAgICAgIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWUgPSA1LFxuICAgICAgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlID0gNixcbiAgICAgIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZSA9IDcsXG4gICAgICBTdXNwZW5kZWRPbkh5ZHJhdGlvbiA9IDgsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZCxcbiAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzID0gITEsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyA9ICExLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyID0gITEsXG4gICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3MsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSA9ICExLFxuICAgICAgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IDAsXG4gICAgICBGQUxMQkFDS19USFJPVFRMRV9NUyA9IDMwMCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBJbmZpbml0eSxcbiAgICAgIFJFTkRFUl9USU1FT1VUX01TID0gNTAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IG51bGwsXG4gICAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGwsXG4gICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9ICExLFxuICAgICAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsLFxuICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSAwLFxuICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSAwLFxuICAgICAgcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IG51bGwsXG4gICAgICBORVNURURfVVBEQVRFX0xJTUlUID0gNTAsXG4gICAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDAsXG4gICAgICByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsLFxuICAgICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gITEsXG4gICAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gITEsXG4gICAgICBORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQgPSA1MCxcbiAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDAsXG4gICAgICByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbCxcbiAgICAgIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICExLFxuICAgICAgSU1NRURJQVRFX0NPTU1JVCA9IDAsXG4gICAgICBTVVNQRU5ERURfQ09NTUlUID0gMSxcbiAgICAgIFRIUk9UVExFRF9DT01NSVQgPSAyLFxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG51bGwsXG4gICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciA9ICExO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGZha2VBY3RDYWxsYmFja05vZGUgPSB7fSxcbiAgICAgIHJlc29sdmVGYW1pbHkgPSBudWxsLFxuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gICAgdmFyIGhhc0JhZE1hcFBvbHlmaWxsID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICAgIG5ldyBNYXAoW1tub25FeHRlbnNpYmxlT2JqZWN0LCBudWxsXV0pO1xuICAgICAgbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gITA7XG4gICAgfVxuICAgIHZhciBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gITE7XG4gICAgdmFyIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlID0ge307XG4gICAgdmFyIG92ZXJyaWRlSG9va1N0YXRlID0gbnVsbCxcbiAgICAgIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IG51bGwsXG4gICAgICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBudWxsLFxuICAgICAgb3ZlcnJpZGVQcm9wcyA9IG51bGwsXG4gICAgICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IG51bGwsXG4gICAgICBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IG51bGwsXG4gICAgICBzY2hlZHVsZVVwZGF0ZSA9IG51bGwsXG4gICAgICBzZXRFcnJvckhhbmRsZXIgPSBudWxsLFxuICAgICAgc2V0U3VzcGVuc2VIYW5kbGVyID0gbnVsbDtcbiAgICBvdmVycmlkZUhvb2tTdGF0ZSA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgsIHZhbHVlKSB7XG4gICAgICBpZCA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG4gICAgICBudWxsICE9PSBpZCAmJlxuICAgICAgICAoKHBhdGggPSBjb3B5V2l0aFNldEltcGwoaWQubWVtb2l6ZWRTdGF0ZSwgcGF0aCwgMCwgdmFsdWUpKSxcbiAgICAgICAgKGlkLm1lbW9pemVkU3RhdGUgPSBwYXRoKSxcbiAgICAgICAgKGlkLmJhc2VTdGF0ZSA9IHBhdGgpLFxuICAgICAgICAoZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcykpLFxuICAgICAgICAocGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMikpLFxuICAgICAgICBudWxsICE9PSBwYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXRoLCBmaWJlciwgMikpO1xuICAgIH07XG4gICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgcGF0aCkge1xuICAgICAgaWQgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuICAgICAgbnVsbCAhPT0gaWQgJiZcbiAgICAgICAgKChwYXRoID0gY29weVdpdGhEZWxldGVJbXBsKGlkLm1lbW9pemVkU3RhdGUsIHBhdGgsIDApKSxcbiAgICAgICAgKGlkLm1lbW9pemVkU3RhdGUgPSBwYXRoKSxcbiAgICAgICAgKGlkLmJhc2VTdGF0ZSA9IHBhdGgpLFxuICAgICAgICAoZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcykpLFxuICAgICAgICAocGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMikpLFxuICAgICAgICBudWxsICE9PSBwYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXRoLCBmaWJlciwgMikpO1xuICAgIH07XG4gICAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgICAgaWQgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuICAgICAgbnVsbCAhPT0gaWQgJiZcbiAgICAgICAgKChvbGRQYXRoID0gY29weVdpdGhSZW5hbWUoaWQubWVtb2l6ZWRTdGF0ZSwgb2xkUGF0aCwgbmV3UGF0aCkpLFxuICAgICAgICAoaWQubWVtb2l6ZWRTdGF0ZSA9IG9sZFBhdGgpLFxuICAgICAgICAoaWQuYmFzZVN0YXRlID0gb2xkUGF0aCksXG4gICAgICAgIChmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKSksXG4gICAgICAgIChvbGRQYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgIG51bGwgIT09IG9sZFBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKG9sZFBhdGgsIGZpYmVyLCAyKSk7XG4gICAgfTtcbiAgICBvdmVycmlkZVByb3BzID0gZnVuY3Rpb24gKGZpYmVyLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhTZXRJbXBsKGZpYmVyLm1lbW9pemVkUHJvcHMsIHBhdGgsIDAsIHZhbHVlKTtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZSAmJiAoZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcyk7XG4gICAgICBwYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBhdGgsIGZpYmVyLCAyKTtcbiAgICB9O1xuICAgIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBwYXRoKSB7XG4gICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aERlbGV0ZUltcGwoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgMCk7XG4gICAgICBmaWJlci5hbHRlcm5hdGUgJiYgKGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHMpO1xuICAgICAgcGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICBudWxsICE9PSBwYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXRoLCBmaWJlciwgMik7XG4gICAgfTtcbiAgICBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhSZW5hbWUoXG4gICAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMsXG4gICAgICAgIG9sZFBhdGgsXG4gICAgICAgIG5ld1BhdGhcbiAgICAgICk7XG4gICAgICBmaWJlci5hbHRlcm5hdGUgJiYgKGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHMpO1xuICAgICAgb2xkUGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICBudWxsICE9PSBvbGRQYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihvbGRQYXRoLCBmaWJlciwgMik7XG4gICAgfTtcbiAgICBzY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpO1xuICAgIH07XG4gICAgc2V0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKG5ld1Nob3VsZEVycm9ySW1wbCkge1xuICAgICAgc2hvdWxkRXJyb3JJbXBsID0gbmV3U2hvdWxkRXJyb3JJbXBsO1xuICAgIH07XG4gICAgc2V0U3VzcGVuc2VIYW5kbGVyID0gZnVuY3Rpb24gKG5ld1Nob3VsZFN1c3BlbmRJbXBsKSB7XG4gICAgICBzaG91bGRTdXNwZW5kSW1wbCA9IG5ld1Nob3VsZFN1c3BlbmRJbXBsO1xuICAgIH07XG4gICAgZXhwb3J0cy5hdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgaWYgKDEzID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDY3MTA4ODY0KTtcbiAgICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDY3MTA4ODY0KTtcbiAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIDY3MTA4ODY0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICBpZiAoMTMgPT09IGZpYmVyLnRhZykge1xuICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKSxcbiAgICAgICAgICByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBsYW5lKTtcbiAgICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGZpYmVyID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmIChmaWJlci5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkKSB7XG4gICAgICAgICAgICB2YXIgbGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhmaWJlci5wZW5kaW5nTGFuZXMpO1xuICAgICAgICAgICAgaWYgKDAgIT09IGxhbmVzKSB7XG4gICAgICAgICAgICAgIGZpYmVyLnBlbmRpbmdMYW5lcyB8PSAyO1xuICAgICAgICAgICAgICBmb3IgKGZpYmVyLmVudGFuZ2xlZExhbmVzIHw9IDI7IGxhbmVzOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IDEgPDwgKDMxIC0gY2x6MzIobGFuZXMpKTtcbiAgICAgICAgICAgICAgICBmaWJlci5lbnRhbmdsZW1lbnRzWzFdIHw9IGxhbmU7XG4gICAgICAgICAgICAgICAgbGFuZXMgJj0gfmxhbmU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGZpYmVyKTtcbiAgICAgICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT1cbiAgICAgICAgICAgICAgICBOb0NvbnRleHQgJiZcbiAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPVxuICAgICAgICAgICAgICAgICAgbm93JDEoKSArIFJFTkRFUl9USU1FT1VUX01TKSxcbiAgICAgICAgICAgICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAobGFuZXMgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpKSxcbiAgICAgICAgICAgIG51bGwgIT09IGxhbmVzICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihsYW5lcywgZmliZXIsIDIpLFxuICAgICAgICAgICAgZmx1c2hTeW5jV29yaygpLFxuICAgICAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIDIpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5iYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYSkge1xuICAgICAgcmV0dXJuIGZuKGEpO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVDb21wb25lbnRTZWxlY3RvciA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHJldHVybiB7ICQkdHlwZW9mOiBDT01QT05FTlRfVFlQRSwgdmFsdWU6IGNvbXBvbmVudCB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVDb250YWluZXIgPSBmdW5jdGlvbiAoXG4gICAgICBjb250YWluZXJJbmZvLFxuICAgICAgdGFnLFxuICAgICAgaHlkcmF0aW9uQ2FsbGJhY2tzLFxuICAgICAgaXNTdHJpY3RNb2RlLFxuICAgICAgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSxcbiAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgdHJhbnNpdGlvbkNhbGxiYWNrc1xuICAgICkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChcbiAgICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgICAgdGFnLFxuICAgICAgICAhMSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgaHlkcmF0aW9uQ2FsbGJhY2tzLFxuICAgICAgICBpc1N0cmljdE1vZGUsXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9ycykge1xuICAgICAgcmV0dXJuIHsgJCR0eXBlb2Y6IEhBU19QU0VVRE9fQ0xBU1NfVFlQRSwgdmFsdWU6IHNlbGVjdG9ycyB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVIeWRyYXRpb25Db250YWluZXIgPSBmdW5jdGlvbiAoXG4gICAgICBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICBjYWxsYmFjayxcbiAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICB0YWcsXG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICBpc1N0cmljdE1vZGUsXG4gICAgICBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLFxuICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgICAgZm9ybVN0YXRlXG4gICAgKSB7XG4gICAgICBpbml0aWFsQ2hpbGRyZW4gPSBjcmVhdGVGaWJlclJvb3QoXG4gICAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICAgIHRhZyxcbiAgICAgICAgITAsXG4gICAgICAgIGluaXRpYWxDaGlsZHJlbixcbiAgICAgICAgaHlkcmF0aW9uQ2FsbGJhY2tzLFxuICAgICAgICBpc1N0cmljdE1vZGUsXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgICAgICBmb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICBpbml0aWFsQ2hpbGRyZW4uY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKG51bGwpO1xuICAgICAgY29udGFpbmVySW5mbyA9IGluaXRpYWxDaGlsZHJlbi5jdXJyZW50O1xuICAgICAgdGFnID0gcmVxdWVzdFVwZGF0ZUxhbmUoY29udGFpbmVySW5mbyk7XG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MgPSBjcmVhdGVVcGRhdGUodGFnKTtcbiAgICAgIGh5ZHJhdGlvbkNhbGxiYWNrcy5jYWxsYmFjayA9XG4gICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiYgbnVsbCAhPT0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IG51bGw7XG4gICAgICBlbnF1ZXVlVXBkYXRlKGNvbnRhaW5lckluZm8sIGh5ZHJhdGlvbkNhbGxiYWNrcywgdGFnKTtcbiAgICAgIGluaXRpYWxDaGlsZHJlbi5jdXJyZW50LmxhbmVzID0gdGFnO1xuICAgICAgbWFya1Jvb3RVcGRhdGVkJDEoaW5pdGlhbENoaWxkcmVuLCB0YWcpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGluaXRpYWxDaGlsZHJlbik7XG4gICAgICByZXR1cm4gaW5pdGlhbENoaWxkcmVuO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sIGltcGxlbWVudGF0aW9uKSB7XG4gICAgICB2YXIga2V5ID1cbiAgICAgICAgMyA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbM10gPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKGtleSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIH0gY2F0Y2ggKGUkNikge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCAmJlxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICBrZXlbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICAgIGtleS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgICBcIk9iamVjdFwiXG4gICAgICAgICksXG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbihrZXkpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICAgICAga2V5OiBudWxsID09IGtleSA/IG51bGwgOiBcIlwiICsga2V5LFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlUm9sZVNlbGVjdG9yID0gZnVuY3Rpb24gKHJvbGUpIHtcbiAgICAgIHJldHVybiB7ICQkdHlwZW9mOiBST0xFX1RZUEUsIHZhbHVlOiByb2xlIH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZVRlc3ROYW1lU2VsZWN0b3IgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiB7ICQkdHlwZW9mOiBURVNUX05BTUVfVFlQRSwgdmFsdWU6IGlkIH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZVRleHRTZWxlY3RvciA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICByZXR1cm4geyAkJHR5cGVvZjogVEVYVF9UWVBFLCB2YWx1ZTogdGV4dCB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5kZWZhdWx0T25DYXVnaHRFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgZXJyb3JJbmZvKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lXG4gICAgICAgICAgPyBcIlRoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPFwiICsgY29tcG9uZW50TmFtZSArIFwiPiBjb21wb25lbnQuXCJcbiAgICAgICAgICA6IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHMuXCIsXG4gICAgICAgIHJlY3JlYXRlTWVzc2FnZSA9XG4gICAgICAgICAgXCJSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCB1c2luZyB0aGUgZXJyb3IgYm91bmRhcnkgeW91IHByb3ZpZGVkLCBcIiArXG4gICAgICAgICAgKChlcnJvckJvdW5kYXJ5TmFtZSB8fCBcIkFub255bW91c1wiKSArIFwiLlwiKSxcbiAgICAgICAgcHJldkdldEN1cnJlbnRTdGFjayA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayxcbiAgICAgICAgY29tcG9uZW50U3RhY2sgPVxuICAgICAgICAgIG51bGwgIT0gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrID8gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrIDogXCJcIjtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFN0YWNrO1xuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJlxuICAgICAgICBudWxsICE9PSBlcnJvciAmJlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IuZW52aXJvbm1lbnROYW1lXG4gICAgICAgICAgPyBiaW5kVG9Db25zb2xlKFxuICAgICAgICAgICAgICBcImVycm9yXCIsXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIiVvXFxuXFxuJXNcXG5cXG4lc1xcblwiLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVNZXNzYWdlLFxuICAgICAgICAgICAgICAgIHJlY3JlYXRlTWVzc2FnZVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBlcnJvci5lbnZpcm9ubWVudE5hbWVcbiAgICAgICAgICAgICkoKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlb1xcblxcbiVzXFxuXFxuJXNcXG5cIixcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVNZXNzYWdlLFxuICAgICAgICAgICAgICByZWNyZWF0ZU1lc3NhZ2VcbiAgICAgICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5kZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBleHBvcnRzLmRlZmF1bHRPblVuY2F1Z2h0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGVycm9ySW5mbykge1xuICAgICAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xuICAgICAgZXJyb3IgPSBjb21wb25lbnROYW1lXG4gICAgICAgID8gXCJBbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPFwiICsgY29tcG9uZW50TmFtZSArIFwiPiBjb21wb25lbnQuXCJcbiAgICAgICAgOiBcIkFuIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHMuXCI7XG4gICAgICB2YXIgcHJldkdldEN1cnJlbnRTdGFjayA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayxcbiAgICAgICAgY29tcG9uZW50U3RhY2sgPVxuICAgICAgICAgIG51bGwgIT0gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrID8gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrIDogXCJcIjtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFN0YWNrO1xuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIiVzXFxuXFxuJXNcXG5cIixcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBcIkNvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcblZpc2l0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuXCJcbiAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2s7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmRlZmVycmVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoMzIpLCAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLCBmbigpXG4gICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmRpc2NyZXRlVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoMiksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsKSxcbiAgICAgICAgICBmbihhLCBiLCBjLCBkKVxuICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBub3ckMSgpICsgUkVOREVSX1RJTUVPVVRfTVMpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5maW5kQWxsTm9kZXMgPSBmaW5kQWxsTm9kZXM7XG4gICAgZXhwb3J0cy5maW5kQm91bmRpbmdSZWN0cyA9IGZ1bmN0aW9uIChob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuXCIpO1xuICAgICAgc2VsZWN0b3JzID0gZmluZEFsbE5vZGVzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuICAgICAgaG9zdFJvb3QgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0b3JzLmxlbmd0aDsgaSsrKVxuICAgICAgICBob3N0Um9vdC5wdXNoKGdldEJvdW5kaW5nUmVjdChzZWxlY3RvcnNbaV0pKTtcbiAgICAgIGZvciAoc2VsZWN0b3JzID0gaG9zdFJvb3QubGVuZ3RoIC0gMTsgMCA8IHNlbGVjdG9yczsgc2VsZWN0b3JzLS0pIHtcbiAgICAgICAgaSA9IGhvc3RSb290W3NlbGVjdG9yc107XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHRhcmdldExlZnQgPSBpLngsXG4gICAgICAgICAgICB0YXJnZXRSaWdodCA9IHRhcmdldExlZnQgKyBpLndpZHRoLFxuICAgICAgICAgICAgdGFyZ2V0VG9wID0gaS55LFxuICAgICAgICAgICAgdGFyZ2V0Qm90dG9tID0gdGFyZ2V0VG9wICsgaS5oZWlnaHQsXG4gICAgICAgICAgICBqID0gc2VsZWN0b3JzIC0gMTtcbiAgICAgICAgICAwIDw9IGo7XG4gICAgICAgICAgai0tXG4gICAgICAgIClcbiAgICAgICAgICBpZiAoc2VsZWN0b3JzICE9PSBqKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJSZWN0ID0gaG9zdFJvb3Rbal0sXG4gICAgICAgICAgICAgIG90aGVyTGVmdCA9IG90aGVyUmVjdC54LFxuICAgICAgICAgICAgICBvdGhlclJpZ2h0ID0gb3RoZXJMZWZ0ICsgb3RoZXJSZWN0LndpZHRoLFxuICAgICAgICAgICAgICBvdGhlclRvcCA9IG90aGVyUmVjdC55LFxuICAgICAgICAgICAgICBvdGhlckJvdHRvbSA9IG90aGVyVG9wICsgb3RoZXJSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA+PSBvdGhlckxlZnQgJiZcbiAgICAgICAgICAgICAgdGFyZ2V0VG9wID49IG90aGVyVG9wICYmXG4gICAgICAgICAgICAgIHRhcmdldFJpZ2h0IDw9IG90aGVyUmlnaHQgJiZcbiAgICAgICAgICAgICAgdGFyZ2V0Qm90dG9tIDw9IG90aGVyQm90dG9tXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaG9zdFJvb3Quc3BsaWNlKHNlbGVjdG9ycywgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ICE9PSBvdGhlckxlZnQgfHxcbiAgICAgICAgICAgICAgICBpLndpZHRoICE9PSBvdGhlclJlY3Qud2lkdGggfHxcbiAgICAgICAgICAgICAgICBvdGhlckJvdHRvbSA8IHRhcmdldFRvcCB8fFxuICAgICAgICAgICAgICAgIG90aGVyVG9wID4gdGFyZ2V0Qm90dG9tXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBvdGhlclRvcCA+IHRhcmdldFRvcCAmJlxuICAgICAgICAgICAgICAgICgob3RoZXJSZWN0LmhlaWdodCArPSBvdGhlclRvcCAtIHRhcmdldFRvcCksXG4gICAgICAgICAgICAgICAgKG90aGVyUmVjdC55ID0gdGFyZ2V0VG9wKSk7XG4gICAgICAgICAgICAgIG90aGVyQm90dG9tIDwgdGFyZ2V0Qm90dG9tICYmXG4gICAgICAgICAgICAgICAgKG90aGVyUmVjdC5oZWlnaHQgPSB0YXJnZXRCb3R0b20gLSBvdGhlclRvcCk7XG4gICAgICAgICAgICAgIGhvc3RSb290LnNwbGljZShzZWxlY3RvcnMsIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgdGFyZ2V0VG9wICE9PSBvdGhlclRvcCB8fFxuICAgICAgICAgICAgICAgIGkuaGVpZ2h0ICE9PSBvdGhlclJlY3QuaGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgb3RoZXJSaWdodCA8IHRhcmdldExlZnQgfHxcbiAgICAgICAgICAgICAgICBvdGhlckxlZnQgPiB0YXJnZXRSaWdodFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgb3RoZXJMZWZ0ID4gdGFyZ2V0TGVmdCAmJlxuICAgICAgICAgICAgICAgICgob3RoZXJSZWN0LndpZHRoICs9IG90aGVyTGVmdCAtIHRhcmdldExlZnQpLFxuICAgICAgICAgICAgICAgIChvdGhlclJlY3QueCA9IHRhcmdldExlZnQpKTtcbiAgICAgICAgICAgICAgb3RoZXJSaWdodCA8IHRhcmdldFJpZ2h0ICYmXG4gICAgICAgICAgICAgICAgKG90aGVyUmVjdC53aWR0aCA9IHRhcmdldFJpZ2h0IC0gb3RoZXJMZWZ0KTtcbiAgICAgICAgICAgICAgaG9zdFJvb3Quc3BsaWNlKHNlbGVjdG9ycywgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0Um9vdDtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZSA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHZhciBmaWJlciA9IGNvbXBvbmVudC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICBpZiAodm9pZCAwID09PSBmaWJlcikge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29tcG9uZW50LnJlbmRlcilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgICAgIGNvbXBvbmVudCA9IE9iamVjdC5rZXlzKGNvbXBvbmVudCkuam9pbihcIixcIik7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBjb21wb25lbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbXBvbmVudCA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcbiAgICAgIHJldHVybiBudWxsID09PSBjb21wb25lbnQgPyBudWxsIDogZ2V0UHVibGljSW5zdGFuY2UoY29tcG9uZW50LnN0YXRlTm9kZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICBmaWJlciA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKTtcbiAgICAgIGZpYmVyID1cbiAgICAgICAgbnVsbCAhPT0gZmliZXIgPyBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKGZpYmVyKSA6IG51bGw7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZmliZXIgPyBudWxsIDogZ2V0UHVibGljSW5zdGFuY2UoZmliZXIuc3RhdGVOb2RlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZpYmVyID0gY29tcG9uZW50Ll9yZWFjdEludGVybmFscztcbiAgICAgIGlmICh2b2lkIDAgPT09IGZpYmVyKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb21wb25lbnQucmVuZGVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgICAgY29tcG9uZW50ID0gT2JqZWN0LmtleXMoY29tcG9uZW50KS5qb2luKFwiLFwiKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiBcIiArIGNvbXBvbmVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29tcG9uZW50ID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgICAgaWYgKG51bGwgPT09IGNvbXBvbmVudCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoY29tcG9uZW50Lm1vZGUgJiA4KSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgICAoKGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGNvbXBvbmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmliZXIubW9kZSAmIDhcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCIlcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuIEluc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGVcIixcbiAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCIlcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggcmVuZGVycyBTdHJpY3RNb2RlIGNoaWxkcmVuLiBJbnN0ZWFkLCBhZGQgYSByZWYgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gcmVmZXJlbmNlLiBMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3RyaWN0LW1vZGUtZmluZC1ub2RlXCIsXG4gICAgICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb21wb25lbnQuc3RhdGVOb2RlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmx1c2hQYXNzaXZlRWZmZWN0cyA9IGZsdXNoUGFzc2l2ZUVmZmVjdHM7XG4gICAgZXhwb3J0cy5mbHVzaFN5bmNGcm9tUmVjb25jaWxlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gMTtcbiAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgICAgIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICgoc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KDIpLCAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLCBmbikpXG4gICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dCksXG4gICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0ICYmXG4gICAgICAgICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmZsdXNoU3luY1dvcmsgPSBmbHVzaFN5bmNXb3JrO1xuICAgIGV4cG9ydHMuZm9jdXNXaXRoaW4gPSBmdW5jdGlvbiAoaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICAgICAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpXG4gICAgICAgIHRocm93IEVycm9yKFwiVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLlwiKTtcbiAgICAgIGhvc3RSb290ID0gZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KTtcbiAgICAgIHNlbGVjdG9ycyA9IGZpbmRQYXRocyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgICAgIHNlbGVjdG9ycyA9IEFycmF5LmZyb20oc2VsZWN0b3JzKTtcbiAgICAgIGZvciAoaG9zdFJvb3QgPSAwOyBob3N0Um9vdCA8IHNlbGVjdG9ycy5sZW5ndGg7ICkge1xuICAgICAgICB2YXIgZmliZXIgPSBzZWxlY3RvcnNbaG9zdFJvb3QrK10sXG4gICAgICAgICAgdGFnID0gZmliZXIudGFnO1xuICAgICAgICBpZiAoIWlzSGlkZGVuU3VidHJlZShmaWJlcikpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZykgJiZcbiAgICAgICAgICAgIHNldEZvY3VzSWZGb2N1c2FibGUoZmliZXIuc3RhdGVOb2RlKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IG51bGwgIT09IGZpYmVyOyApXG4gICAgICAgICAgICBzZWxlY3RvcnMucHVzaChmaWJlciksIChmaWJlciA9IGZpYmVyLnNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfTtcbiAgICBleHBvcnRzLmdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuXCIpO1xuICAgICAgdmFyIG1heFNlbGVjdG9ySW5kZXggPSAwLFxuICAgICAgICBtYXRjaGVkTmFtZXMgPSBbXTtcbiAgICAgIGhvc3RSb290ID0gW2ZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCksIDBdO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGhvc3RSb290Lmxlbmd0aDsgKSB7XG4gICAgICAgIHZhciBmaWJlciA9IGhvc3RSb290W2luZGV4KytdLFxuICAgICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgICBzZWxlY3RvckluZGV4ID0gaG9zdFJvb3RbaW5kZXgrK10sXG4gICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG4gICAgICAgIGlmICgoNSAhPT0gdGFnICYmIDI2ICE9PSB0YWcgJiYgMjcgIT09IHRhZykgfHwgIWlzSGlkZGVuU3VidHJlZShmaWJlcikpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSAmJlxuICAgICAgICAgICAgICAobWF0Y2hlZE5hbWVzLnB1c2goc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcikpLFxuICAgICAgICAgICAgICBzZWxlY3RvckluZGV4KyssXG4gICAgICAgICAgICAgIHNlbGVjdG9ySW5kZXggPiBtYXhTZWxlY3RvckluZGV4ICYmXG4gICAgICAgICAgICAgICAgKG1heFNlbGVjdG9ySW5kZXggPSBzZWxlY3RvckluZGV4KSksXG4gICAgICAgICAgICBzZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aClcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IG51bGwgIT09IGZpYmVyOyApXG4gICAgICAgICAgICAgIGhvc3RSb290LnB1c2goZmliZXIsIHNlbGVjdG9ySW5kZXgpLCAoZmliZXIgPSBmaWJlci5zaWJsaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhTZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIGhvc3RSb290ID0gW107XG4gICAgICAgICAgbWF4U2VsZWN0b3JJbmRleCA8IHNlbGVjdG9ycy5sZW5ndGg7XG4gICAgICAgICAgbWF4U2VsZWN0b3JJbmRleCsrXG4gICAgICAgIClcbiAgICAgICAgICBob3N0Um9vdC5wdXNoKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3JzW21heFNlbGVjdG9ySW5kZXhdKSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgXCJmaW5kQWxsTm9kZXMgd2FzIGFibGUgdG8gbWF0Y2ggcGFydCBvZiB0aGUgc2VsZWN0b3I6XFxuICBcIiArXG4gICAgICAgICAgKG1hdGNoZWROYW1lcy5qb2luKFwiID4gXCIpICtcbiAgICAgICAgICAgIFwiXFxuXFxuTm8gbWF0Y2hpbmcgY29tcG9uZW50IHdhcyBmb3VuZCBmb3I6XFxuICBcIikgK1xuICAgICAgICAgIGhvc3RSb290LmpvaW4oXCIgPiBcIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgZXhwb3J0cy5nZXRQdWJsaWNSb290SW5zdGFuY2UgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIgPSBjb250YWluZXIuY3VycmVudDtcbiAgICAgIGlmICghY29udGFpbmVyLmNoaWxkKSByZXR1cm4gbnVsbDtcbiAgICAgIHN3aXRjaCAoY29udGFpbmVyLmNoaWxkLnRhZykge1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbnRhaW5lci5jaGlsZC5zdGF0ZU5vZGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBjb250YWluZXIuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5pbmplY3RJbnRvRGV2VG9vbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW50ZXJuYWxzID0ge1xuICAgICAgICBidW5kbGVUeXBlOiAxLFxuICAgICAgICB2ZXJzaW9uOiByZW5kZXJlclZlcnNpb24sXG4gICAgICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6IHJlbmRlcmVyUGFja2FnZU5hbWUsXG4gICAgICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBSZWFjdFNoYXJlZEludGVybmFscyxcbiAgICAgICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGdldEluc3RhbmNlRnJvbU5vZGUsXG4gICAgICAgIHJlY29uY2lsZXJWZXJzaW9uOiBcIjE5LjAuMFwiXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gZXh0cmFEZXZUb29sc0NvbmZpZyAmJlxuICAgICAgICAoaW50ZXJuYWxzLnJlbmRlcmVyQ29uZmlnID0gZXh0cmFEZXZUb29sc0NvbmZpZyk7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVIb29rU3RhdGUgPSBvdmVycmlkZUhvb2tTdGF0ZTtcbiAgICAgIGludGVybmFscy5vdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGg7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoO1xuICAgICAgaW50ZXJuYWxzLm92ZXJyaWRlUHJvcHMgPSBvdmVycmlkZVByb3BzO1xuICAgICAgaW50ZXJuYWxzLm92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGg7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBvdmVycmlkZVByb3BzUmVuYW1lUGF0aDtcbiAgICAgIGludGVybmFscy5zY2hlZHVsZVVwZGF0ZSA9IHNjaGVkdWxlVXBkYXRlO1xuICAgICAgaW50ZXJuYWxzLnNldEVycm9ySGFuZGxlciA9IHNldEVycm9ySGFuZGxlcjtcbiAgICAgIGludGVybmFscy5zZXRTdXNwZW5zZUhhbmRsZXIgPSBzZXRTdXNwZW5zZUhhbmRsZXI7XG4gICAgICBpbnRlcm5hbHMuc2NoZWR1bGVSZWZyZXNoID0gc2NoZWR1bGVSZWZyZXNoO1xuICAgICAgaW50ZXJuYWxzLnNjaGVkdWxlUm9vdCA9IHNjaGVkdWxlUm9vdDtcbiAgICAgIGludGVybmFscy5zZXRSZWZyZXNoSGFuZGxlciA9IHNldFJlZnJlc2hIYW5kbGVyO1xuICAgICAgaW50ZXJuYWxzLmdldEN1cnJlbnRGaWJlciA9IGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzO1xuICAgICAgaW50ZXJuYWxzLmdldExhbmVMYWJlbE1hcCA9IGdldExhbmVMYWJlbE1hcDtcbiAgICAgIGludGVybmFscy5pbmplY3RQcm9maWxpbmdIb29rcyA9IGluamVjdFByb2ZpbGluZ0hvb2tzO1xuICAgICAgcmV0dXJuIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy5pc0FscmVhZHlSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0O1xuICAgIH07XG4gICAgZXhwb3J0cy5vYnNlcnZlVmlzaWJsZVJlY3RzID0gZnVuY3Rpb24gKFxuICAgICAgaG9zdFJvb3QsXG4gICAgICBzZWxlY3RvcnMsXG4gICAgICBjYWxsYmFjayxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2soKSB7XG4gICAgICAgIHZhciBuZXh0SW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgICAgICAgaW5zdGFuY2VSb290cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAwID4gbmV4dEluc3RhbmNlUm9vdHMuaW5kZXhPZih0YXJnZXQpICYmIHVub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgbmV4dEluc3RhbmNlUm9vdHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgMCA+IGluc3RhbmNlUm9vdHMuaW5kZXhPZih0YXJnZXQpICYmIG9ic2VydmUodGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuXCIpO1xuICAgICAgdmFyIGluc3RhbmNlUm9vdHMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG4gICAgICBjYWxsYmFjayA9IHNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaW5zdGFuY2VSb290cywgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgICAgdmFyIGRpc2Nvbm5lY3QgPSBjYWxsYmFjay5kaXNjb25uZWN0LFxuICAgICAgICBvYnNlcnZlID0gY2FsbGJhY2sub2JzZXJ2ZSxcbiAgICAgICAgdW5vYnNlcnZlID0gY2FsbGJhY2sudW5vYnNlcnZlO1xuICAgICAgY29tbWl0SG9va3MucHVzaChjb21taXRIb29rKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBjb21taXRIb29rcy5pbmRleE9mKGNvbW1pdEhvb2spO1xuICAgICAgICAgIDAgPD0gaW5kZXggJiYgY29tbWl0SG9va3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBkaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleHBvcnRzLnNob3VsZEVycm9yID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICByZXR1cm4gc2hvdWxkRXJyb3JJbXBsKGZpYmVyKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuc2hvdWxkU3VzcGVuZCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIHNob3VsZFN1c3BlbmRJbXBsKGZpYmVyKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuc3RhcnRIb3N0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChcbiAgICAgIGZvcm1GaWJlcixcbiAgICAgIHBlbmRpbmdTdGF0ZSxcbiAgICAgIGFjdGlvbixcbiAgICAgIGZvcm1EYXRhXG4gICAgKSB7XG4gICAgICBpZiAoNSAhPT0gZm9ybUZpYmVyLnRhZylcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB0aGUgZm9ybSBpbnN0YW5jZSB0byBiZSBhIEhvc3RDb21wb25lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBxdWV1ZSA9IGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcikucXVldWU7XG4gICAgICBzdGFydFRyYW5zaXRpb24oXG4gICAgICAgIGZvcm1GaWJlcixcbiAgICAgICAgcXVldWUsXG4gICAgICAgIHBlbmRpbmdTdGF0ZSxcbiAgICAgICAgTm90UGVuZGluZ1RyYW5zaXRpb24sXG4gICAgICAgIG51bGwgPT09IGFjdGlvblxuICAgICAgICAgID8gbm9vcFxuICAgICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5UICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwicmVxdWVzdEZvcm1SZXNldCB3YXMgY2FsbGVkIG91dHNpZGUgYSB0cmFuc2l0aW9uIG9yIGFjdGlvbi4gVG8gZml4LCBtb3ZlIHRvIGFuIGFjdGlvbiwgb3Igd3JhcCB3aXRoIHN0YXJ0VHJhbnNpdGlvbi5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHZhciByZXNldFN0YXRlUXVldWUgPVxuICAgICAgICAgICAgICAgIGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcikubmV4dC5xdWV1ZTtcbiAgICAgICAgICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICAgICAgICAgIGZvcm1GaWJlcixcbiAgICAgICAgICAgICAgICByZXNldFN0YXRlUXVldWUsXG4gICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZm9ybUZpYmVyKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uKGZvcm1EYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVwZGF0ZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChcbiAgICAgIGVsZW1lbnQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIuY3VycmVudCxcbiAgICAgICAgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQpO1xuICAgICAgdXBkYXRlQ29udGFpbmVySW1wbChcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgbGFuZSxcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfTtcbiAgICBleHBvcnRzLnVwZGF0ZUNvbnRhaW5lclN5bmMgPSB1cGRhdGVDb250YWluZXJTeW5jO1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9KSxcbiAgKG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cyksXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pKTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiJCQkY29uZmlnIiwiZmluZEhvb2siLCJmaWJlciIsImlkIiwibWVtb2l6ZWRTdGF0ZSIsIm5leHQiLCJjb3B5V2l0aFNldEltcGwiLCJvYmoiLCJwYXRoIiwiaW5kZXgiLCJ2YWx1ZSIsImxlbmd0aCIsImtleSIsInVwZGF0ZWQiLCJpc0FycmF5SW1wbCIsInNsaWNlIiwiYXNzaWduIiwiY29weVdpdGhSZW5hbWUiLCJvbGRQYXRoIiwibmV3UGF0aCIsImNvbnNvbGUiLCJ3YXJuIiwiaSIsImNvcHlXaXRoUmVuYW1lSW1wbCIsIm9sZEtleSIsInNwbGljZSIsImNvcHlXaXRoRGVsZXRlSW1wbCIsInNob3VsZFN1c3BlbmRJbXBsIiwic2hvdWxkRXJyb3JJbXBsIiwiY3JlYXRlRmliZXIiLCJ0YWciLCJwZW5kaW5nUHJvcHMiLCJtb2RlIiwiRmliZXJOb2RlIiwic2NoZWR1bGVSb290Iiwicm9vdCIsImVsZW1lbnQiLCJjb250ZXh0IiwiZW1wdHlDb250ZXh0T2JqZWN0IiwidXBkYXRlQ29udGFpbmVyU3luYyIsImZsdXNoU3luY1dvcmsiLCJzY2hlZHVsZVJlZnJlc2giLCJ1cGRhdGUiLCJyZXNvbHZlRmFtaWx5Iiwic3RhbGVGYW1pbGllcyIsInVwZGF0ZWRGYW1pbGllcyIsImZsdXNoUGFzc2l2ZUVmZmVjdHMiLCJzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5IiwiY3VycmVudCIsInNldFJlZnJlc2hIYW5kbGVyIiwiaGFuZGxlciIsIndhcm5JbnZhbGlkSG9va0FjY2VzcyIsImVycm9yIiwid2FybkludmFsaWRDb250ZXh0QWNjZXNzIiwibm9vcCIsIndhcm5Gb3JNaXNzaW5nS2V5Iiwic2V0VG9Tb3J0ZWRTdHJpbmciLCJzZXQiLCJhcnJheSIsImZvckVhY2giLCJwdXNoIiwic29ydCIsImpvaW4iLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInR5cGUiLCIkJHR5cGVvZiIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9DT05TVU1FUl9UWVBFIiwiX2NvbnRleHQiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiaW5uZXJUeXBlIiwicmVuZGVyIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiX3BheWxvYWQiLCJfaW5pdCIsIngiLCJnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyIiwiX2RlYnVnSW5mbyIsInJldHVybiIsImRpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsImxvZyIsInByZXZJbmZvIiwiaW5mbyIsInByZXZXYXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwiZ3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJncm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImdyb3VwRW5kIiwicHJvcHMiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUiLCJwcmVmaXgiLCJFcnJvciIsIm1hdGNoIiwic3RhY2siLCJ0cmltIiwic3VmZml4IiwiaW5kZXhPZiIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsInJlZW50cnkiLCJmcmFtZSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJnZXQiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiSCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiRmFrZSIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiUmVmbGVjdCIsImNvbnRyb2wiLCJjYWxsIiwieCQwIiwieCQxIiwiY2F0Y2giLCJzYW1wbGUiLCJuYW1lUHJvcERlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfUnVuSW5Sb290RnJhbWUkRGV0ZXIiLCJzYW1wbGVTdGFjayIsImNvbnRyb2xTdGFjayIsInNhbXBsZUxpbmVzIiwic3BsaXQiLCJjb250cm9sTGluZXMiLCJpbmNsdWRlcyIsIl9mcmFtZSIsInJlcGxhY2UiLCJkZXNjcmliZUZpYmVyIiwiZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kIiwid29ya0luUHJvZ3Jlc3MiLCJkZWJ1Z0luZm8iLCJlbnRyeSIsIkpTQ29tcGlsZXJfdGVtcF9jb25zdCIsImVudiIsIkpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCIsIm1lc3NhZ2UiLCJnZXRDdXJyZW50RmliZXJTdGFja0luRGV2IiwicnVuV2l0aEZpYmVySW5ERVYiLCJjYWxsYmFjayIsImFyZzAiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJhcmc0IiwicHJldmlvdXNGaWJlciIsImdldEN1cnJlbnRTdGFjayIsImlzUmVuZGVyaW5nIiwiZ2V0TmVhcmVzdE1vdW50ZWRGaWJlciIsIm5vZGUiLCJuZWFyZXN0TW91bnRlZCIsImFsdGVybmF0ZSIsImZsYWdzIiwiYXNzZXJ0SXNNb3VudGVkIiwiZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgiLCJhIiwiYiIsInBhcmVudEEiLCJwYXJlbnRCIiwiY2hpbGQiLCJzaWJsaW5nIiwiZGlkRmluZENoaWxkIiwiX2NoaWxkIiwic3RhdGVOb2RlIiwiZmluZEN1cnJlbnRIb3N0RmliZXIiLCJwYXJlbnQiLCJmaW5kQ3VycmVudEhvc3RGaWJlckltcGwiLCJmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsIiwiY3JlYXRlQ3Vyc29yIiwiZGVmYXVsdFZhbHVlIiwicG9wIiwiY3Vyc29yIiwiaW5kZXgkanNjb21wJDAiLCJmaWJlclN0YWNrIiwidmFsdWVTdGFjayIsImNsejMyRmFsbGJhY2siLCJsb2ckMSIsIkxOMiIsImdldExhYmVsRm9yTGFuZSIsImxhbmUiLCJnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyIsImxhbmVzIiwicGVuZGluZ1N5bmNMYW5lcyIsImdldE5leHRMYW5lcyIsIndpcExhbmVzIiwicGVuZGluZ0xhbmVzIiwibmV4dExhbmVzIiwic3VzcGVuZGVkTGFuZXMiLCJwaW5nZWRMYW5lcyIsIndhcm1MYW5lcyIsImZpbmlzaGVkTGFuZXMiLCJub25JZGxlUGVuZGluZ0xhbmVzIiwiY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyIsInJlbmRlckxhbmVzIiwiY29tcHV0ZUV4cGlyYXRpb25UaW1lIiwiY3VycmVudFRpbWUiLCJjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSIsIm5leHRUcmFuc2l0aW9uTGFuZSIsImNsYWltTmV4dFJldHJ5TGFuZSIsIm5leHRSZXRyeUxhbmUiLCJjcmVhdGVMYW5lTWFwIiwiaW5pdGlhbCIsImxhbmVNYXAiLCJtYXJrUm9vdFVwZGF0ZWQkMSIsInVwZGF0ZUxhbmUiLCJtYXJrUm9vdEZpbmlzaGVkIiwicmVtYWluaW5nTGFuZXMiLCJzcGF3bmVkTGFuZSIsInVwZGF0ZWRMYW5lcyIsInN1c3BlbmRlZFJldHJ5TGFuZXMiLCJwcmV2aW91c2x5UGVuZGluZ0xhbmVzIiwiZXhwaXJlZExhbmVzIiwiZW50YW5nbGVkTGFuZXMiLCJlcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyIsInNoZWxsU3VzcGVuZENvdW50ZXIiLCJlbnRhbmdsZW1lbnRzIiwiZXhwaXJhdGlvblRpbWVzIiwiaGlkZGVuVXBkYXRlcyIsImNsejMyIiwiaGlkZGVuVXBkYXRlc0ZvckxhbmUiLCJtYXJrU3Bhd25lZERlZmVycmVkTGFuZSIsInNwYXduZWRMYW5lSW5kZXgiLCJtYXJrUm9vdEVudGFuZ2xlZCIsInJvb3RFbnRhbmdsZWRMYW5lcyIsImFkZEZpYmVyVG9MYW5lc01hcCIsImlzRGV2VG9vbHNQcmVzZW50IiwicGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCIsImFkZCIsIm1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZCIsIm1lbW9pemVkVXBkYXRlcnMiLCJzaXplIiwiaGFzIiwiY2xlYXIiLCJsYW5lc1RvRXZlbnRQcmlvcml0eSIsImluamVjdEludGVybmFscyIsImludGVybmFscyIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImhvb2siLCJpc0Rpc2FibGVkIiwic3VwcG9ydHNGaWJlciIsInJlbmRlcmVySUQiLCJpbmplY3QiLCJpbmplY3RlZEhvb2siLCJlcnIiLCJjaGVja0RDRSIsIm9uQ29tbWl0Um9vdCQxIiwiZXZlbnRQcmlvcml0eSIsIm9uQ29tbWl0RmliZXJSb290IiwiZGlkRXJyb3IiLCJzY2hlZHVsZXJQcmlvcml0eSIsIkltbWVkaWF0ZVByaW9yaXR5IiwiVXNlckJsb2NraW5nUHJpb3JpdHkiLCJOb3JtYWxQcmlvcml0eSQxIiwiSWRsZVByaW9yaXR5IiwiaGFzTG9nZ2VkRXJyb3IiLCJzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyIsIm5ld0lzU3RyaWN0TW9kZSIsInVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlIiwic2V0U3RyaWN0TW9kZSIsImluamVjdFByb2ZpbGluZ0hvb2tzIiwicHJvZmlsaW5nSG9va3MiLCJpbmplY3RlZFByb2ZpbGluZ0hvb2tzIiwibWFya0NvbW1pdFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCIsIm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkIiwibWFya1JlbmRlclN0YXJ0ZWQiLCJtYXJrUmVuZGVyU3RvcHBlZCIsIm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZCIsImlzIiwieSIsImNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyIiwic291cmNlIiwiZXhpc3RpbmciLCJDYXB0dXJlZFN0YWNrcyIsInB1c2hUcmVlRm9yayIsInRvdGFsQ2hpbGRyZW4iLCJ3YXJuSWZOb3RIeWRyYXRpbmciLCJmb3JrU3RhY2siLCJmb3JrU3RhY2tJbmRleCIsInRyZWVGb3JrQ291bnQiLCJ0cmVlRm9ya1Byb3ZpZGVyIiwicHVzaFRyZWVJZCIsImlkU3RhY2siLCJpZFN0YWNrSW5kZXgiLCJ0cmVlQ29udGV4dElkIiwidHJlZUNvbnRleHRPdmVyZmxvdyIsInRyZWVDb250ZXh0UHJvdmlkZXIiLCJiYXNlSWRXaXRoTGVhZGluZ0JpdCIsImJhc2VMZW5ndGgiLCJudW1iZXJPZk92ZXJmbG93Qml0cyIsInRvU3RyaW5nIiwicHVzaE1hdGVyaWFsaXplZFRyZWVJZCIsInBvcFRyZWVDb250ZXh0IiwiaXNIeWRyYXRpbmciLCJyZXF1aXJlZENvbnRleHQiLCJjIiwicHVzaEhvc3RDb250YWluZXIiLCJuZXh0Um9vdEluc3RhbmNlIiwicm9vdEluc3RhbmNlU3RhY2tDdXJzb3IiLCJjb250ZXh0RmliZXJTdGFja0N1cnNvciIsImNvbnRleHRTdGFja0N1cnNvciIsImdldFJvb3RIb3N0Q29udGV4dCIsInBvcEhvc3RDb250YWluZXIiLCJnZXRIb3N0Q29udGV4dCIsInB1c2hIb3N0Q29udGV4dCIsImhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IiLCJuZXh0Q29udGV4dCIsImdldENoaWxkSG9zdENvbnRleHQiLCJwb3BIb3N0Q29udGV4dCIsImlzUHJpbWFyeVJlbmRlcmVyIiwiSG9zdFRyYW5zaXRpb25Db250ZXh0IiwiX2N1cnJlbnRWYWx1ZSIsIk5vdFBlbmRpbmdUcmFuc2l0aW9uIiwiX2N1cnJlbnRWYWx1ZTIiLCJmaW5kTm90YWJsZU5vZGUiLCJpbmRlbnQiLCJzZXJ2ZXJQcm9wcyIsInNlcnZlclRhaWwiLCJjaGlsZHJlbiIsImRpc3RhbmNlRnJvbUxlYWYiLCJpbmRlbnRhdGlvbiIsInJlcGVhdCIsImFkZGVkIiwicmVtb3ZlZCIsImRlc2NyaWJlRmliZXJUeXBlIiwiZGVzY3JpYmVUZXh0Tm9kZSIsImNvbnRlbnQiLCJtYXhMZW5ndGgiLCJuZWVkc0VzY2FwaW5nIiwidGVzdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkZXNjcmliZVRleHREaWZmIiwiY2xpZW50VGV4dCIsImZpcnN0RGlmZiIsImNoYXJDb2RlQXQiLCJvYmplY3ROYW1lIiwib2JqZWN0IiwibSIsInAwIiwiZGVzY3JpYmVWYWx1ZSIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsInByb3BOYW1lIiwiaGFzT3duUHJvcGVydHkiLCJqc29uUHJvcE5hbWUiLCJTdHJpbmciLCJkZXNjcmliZVByb3BWYWx1ZSIsImRlc2NyaWJlRXhwYW5kZWRFbGVtZW50Iiwicm93UHJlZml4IiwicmVtYWluaW5nUm93TGVuZ3RoIiwicHJvcGVydGllcyIsInByb3BWYWx1ZSIsImRlc2NyaWJlUHJvcGVydGllc0RpZmYiLCJjbGllbnRPYmplY3QiLCJzZXJ2ZXJPYmplY3QiLCJyZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzIiwiY2xpZW50UHJvcFZhbHVlIiwiX3Byb3BOYW1lIiwiZGVzY3JpYmVFbGVtZW50RGlmZiIsImNsaWVudFByb3BzIiwic2VydmVyUHJvcE5hbWVzIiwiTWFwIiwicHJvcE5hbWUkanNjb21wJDAiLCJ0b0xvd2VyQ2FzZSIsIl9wcm9wTmFtZTIiLCJtYXhMZW5ndGgkanNjb21wJDAiLCJzZXJ2ZXJQcm9wTmFtZSIsImRlbGV0ZSIsImtleXMiLCJkZXNjcmliZVNpYmxpbmdGaWJlciIsImRlc2NyaWJlTm9kZSIsInNraXBUb05vZGUiLCJzZXJ2ZXJDb21wb25lbnROYW1lIiwiZGVzY3JpYmVEaWZmIiwicm9vdE5vZGUiLCJidWlsZEh5ZHJhdGlvbkRpZmZOb2RlIiwiaHlkcmF0aW9uRGlmZlJvb3RERVYiLCJzaWJsaW5ncyIsIndhcm5Ob25IeWRyYXRlZEluc3RhbmNlIiwicmVqZWN0ZWRDYW5kaWRhdGUiLCJkaWRTdXNwZW5kT3JFcnJvckRFViIsImRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MiLCJ0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2giLCJkaWZmIiwiZGlmZlJvb3QiLCJxdWV1ZUh5ZHJhdGlvbkVycm9yIiwiSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24iLCJwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlIiwiaG9zdENvbnRleHQiLCJzdXBwb3J0c0h5ZHJhdGlvbiIsImh5ZHJhdGVJbnN0YW5jZSIsIm1lbW9pemVkUHJvcHMiLCJwb3BUb05leHRIb3N0UGFyZW50IiwiaHlkcmF0aW9uUGFyZW50RmliZXIiLCJyb290T3JTaW5nbGV0b25Db250ZXh0IiwicG9wSHlkcmF0aW9uU3RhdGUiLCJzaG91bGRDbGVhciIsInN1cHBvcnRzU2luZ2xldG9ucyIsInNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzIiwic2hvdWxkU2V0VGV4dENvbnRlbnQiLCJuZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiZGlmZk5vZGUiLCJkZXNjcmlwdGlvbiIsImdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UiLCJnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmciLCJkZWh5ZHJhdGVkIiwicmVzZXRIeWRyYXRpb25TdGF0ZSIsImh5ZHJhdGlvbkVycm9ycyIsImVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MiLCJmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzIiwiZW5kSW5kZXgiLCJjb25jdXJyZW50UXVldWVzSW5kZXgiLCJjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMiLCJjb25jdXJyZW50UXVldWVzIiwicXVldWUiLCJwZW5kaW5nIiwibWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QiLCJlbnF1ZXVlVXBkYXRlJDEiLCJlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUiLCJnZXRSb290Rm9yVXBkYXRlZEZpYmVyIiwiZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lIiwic291cmNlRmliZXIiLCJpc0hpZGRlbiIsImNoaWxkTGFuZXMiLCJfdmlzaWJpbGl0eSIsIm5lc3RlZFVwZGF0ZUNvdW50IiwiTkVTVEVEX1VQREFURV9MSU1JVCIsIm5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCIsInJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMiLCJyb290V2l0aE5lc3RlZFVwZGF0ZXMiLCJORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQiLCJ3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWIiwicHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucyIsInByZXZFZmZlY3REdXJhdGlvbiIsInByb2ZpbGVyRWZmZWN0RHVyYXRpb24iLCJwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMiLCJlbGFwc2VkVGltZSIsImJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyIsInN0YXJ0UHJvZmlsZXJUaW1lciIsInByb2ZpbGVyU3RhcnRUaW1lIiwibm93IiwiYWN0dWFsU3RhcnRUaW1lIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREdXJhdGlvbiIsImFjdHVhbER1cmF0aW9uIiwic2VsZkJhc2VEdXJhdGlvbiIsInN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkSW5jb21wbGV0ZUR1cmF0aW9uIiwicmVjb3JkRWZmZWN0RHVyYXRpb24iLCJzdGFydEVmZmVjdFRpbWVyIiwidHJhbnNmZXJBY3R1YWxEdXJhdGlvbiIsImVuc3VyZVJvb3RJc1NjaGVkdWxlZCIsImxhc3RTY2hlZHVsZWRSb290IiwiZmlyc3RTY2hlZHVsZWRSb290IiwibWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrIiwiYWN0UXVldWUiLCJkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QiLCJzY2hlZHVsZUltbWVkaWF0ZVRhc2siLCJwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2siLCJkaWRTY2hlZHVsZU1pY3JvdGFzayIsImZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsIiwic3luY1RyYW5zaXRpb25MYW5lcyIsIm9ubHlMZWdhY3kiLCJpc0ZsdXNoaW5nV29yayIsImRpZFBlcmZvcm1Tb21lV29yayIsInBlcmZvcm1TeW5jV29ya09uUm9vdCIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290IiwiY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUiLCJzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uIiwibm93JDEiLCJwcmV2Iiwic2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayIsImV4cGlyYXRpb25UaW1lIiwiY2FsbGJhY2tOb2RlIiwid29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24iLCJTdXNwZW5kZWRPbkRhdGEiLCJjYW5jZWxQZW5kaW5nQ29tbWl0IiwiY2FuY2VsQ2FsbGJhY2siLCJjYWxsYmFja1ByaW9yaXR5IiwiZmFrZUFjdENhbGxiYWNrTm9kZSQxIiwicGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrIiwiYmluZCIsInNjaGVkdWxlQ2FsbGJhY2skMyIsImRpZFRpbWVvdXQiLCJuZXN0ZWRVcGRhdGVTY2hlZHVsZWQiLCJjdXJyZW50VXBkYXRlSXNOZXN0ZWQiLCJvcmlnaW5hbENhbGxiYWNrTm9kZSIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwIiwicGVyZm9ybVdvcmtPblJvb3QiLCJjYW5jZWxDYWxsYmFjayQxIiwiY2IiLCJzdXBwb3J0c01pY3JvdGFza3MiLCJzY2hlZHVsZU1pY3JvdGFzayIsImV4ZWN1dGlvbkNvbnRleHQiLCJSZW5kZXJDb250ZXh0IiwiQ29tbWl0Q29udGV4dCIsIk5vQ29udGV4dCIsInJlcXVlc3RUcmFuc2l0aW9uTGFuZSIsImVudGFuZ2xlQXN5bmNBY3Rpb24iLCJ0cmFuc2l0aW9uIiwidGhlbmFibGUiLCJjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzIiwiZW50YW5nbGVkTGlzdGVuZXJzIiwiY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCIsImN1cnJlbnRFbnRhbmdsZWRMYW5lIiwiY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlIiwic3RhdHVzIiwidGhlbiIsInJlc29sdmUiLCJwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlIiwibGlzdGVuZXJzIiwiY2hhaW5UaGVuYWJsZVZhbHVlIiwicmVzdWx0IiwidGhlbmFibGVXaXRoT3ZlcnJpZGUiLCJyZWFzb24iLCJpbml0aWFsaXplVXBkYXRlUXVldWUiLCJ1cGRhdGVRdWV1ZSIsImJhc2VTdGF0ZSIsImZpcnN0QmFzZVVwZGF0ZSIsImxhc3RCYXNlVXBkYXRlIiwic2hhcmVkIiwiaGlkZGVuQ2FsbGJhY2tzIiwiY2FsbGJhY2tzIiwiY2xvbmVVcGRhdGVRdWV1ZSIsImNyZWF0ZVVwZGF0ZSIsIlVwZGF0ZVN0YXRlIiwicGF5bG9hZCIsImVucXVldWVVcGRhdGUiLCJjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUiLCJkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlIiwiY29tcG9uZW50TmFtZSIsImVudGFuZ2xlVHJhbnNpdGlvbnMiLCJxdWV1ZUxhbmVzIiwiZW5xdWV1ZUNhcHR1cmVkVXBkYXRlIiwiY2FwdHVyZWRVcGRhdGUiLCJuZXdGaXJzdCIsIm5ld0xhc3QiLCJjbG9uZSIsInN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24iLCJkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uIiwiZW50YW5nbGVkQWN0aW9uVGhlbmFibGUiLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJpbnN0YW5jZSRqc2NvbXAkMCIsImhhc0ZvcmNlVXBkYXRlIiwicGVuZGluZ1F1ZXVlIiwibGFzdFBlbmRpbmdVcGRhdGUiLCJmaXJzdFBlbmRpbmdVcGRhdGUiLCJuZXdTdGF0ZSIsImlzSGlkZGVuVXBkYXRlIiwicGFydGlhbFN0YXRlIiwibmV4dFByb3BzIiwiaW5zdGFuY2UiLCJSZXBsYWNlU3RhdGUiLCJpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwibmV4dFN0YXRlIiwiQ2FwdHVyZVVwZGF0ZSIsIkZvcmNlVXBkYXRlIiwid29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIiwiY2FsbENhbGxiYWNrIiwiY29tbWl0SGlkZGVuQ2FsbGJhY2tzIiwiY29tbWl0Q2FsbGJhY2tzIiwic2hhbGxvd0VxdWFsIiwib2JqQSIsIm9iakIiLCJvYmplY3RJcyIsImtleXNBIiwia2V5c0IiLCJjdXJyZW50S2V5IiwiY3JlYXRlVGhlbmFibGVTdGF0ZSIsImRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZSIsInRoZW5hYmxlcyIsImlzVGhlbmFibGVSZXNvbHZlZCIsIm5vb3AkMSIsInRyYWNrVXNlZFRoZW5hYmxlIiwidGhlbmFibGVTdGF0ZSIsImRpZFVzZVByb21pc2UiLCJ0cmFja2VkVGhlbmFibGVzIiwiY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2giLCJmdWxmaWxsZWRWYWx1ZSIsImZ1bGZpbGxlZFRoZW5hYmxlIiwicmVqZWN0ZWRUaGVuYWJsZSIsInN1c3BlbmRlZFRoZW5hYmxlIiwibmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYiLCJTdXNwZW5zZUV4Y2VwdGlvbiIsImdldFN1c3BlbmRlZFRoZW5hYmxlIiwicmVqZWN0ZWRSZWFzb24iLCJwdXNoRGVidWdJbmZvIiwicHJldmlvdXNEZWJ1Z0luZm8iLCJjdXJyZW50RGVidWdJbmZvIiwiY29uY2F0IiwidmFsaWRhdGVGcmFnbWVudFByb3BzIiwicmV0dXJuRmliZXIiLCJjcmVhdGVGaWJlckZyb21FbGVtZW50IiwiZXJyb3JlZEtleSIsInVud3JhcFRoZW5hYmxlIiwidGhlbmFibGVJbmRleENvdW50ZXIkMSIsInRoZW5hYmxlU3RhdGUkMSIsImNvZXJjZVJlZiIsInJlZiIsInRocm93T25JbnZhbGlkT2JqZWN0VHlwZSIsIm5ld0NoaWxkIiwiUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSIsIndhcm5PbkZ1bmN0aW9uVHlwZSIsImludmFsaWRDaGlsZCIsInBhcmVudE5hbWUiLCJvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmciLCJ3YXJuT25TeW1ib2xUeXBlIiwib3duZXJIYXNTeW1ib2xUeXBlV2FybmluZyIsImNyZWF0ZUNoaWxkUmVjb25jaWxlciIsInNob3VsZFRyYWNrU2lkZUVmZmVjdHMiLCJkZWxldGVDaGlsZCIsImNoaWxkVG9EZWxldGUiLCJkZWxldGlvbnMiLCJkZWxldGVSZW1haW5pbmdDaGlsZHJlbiIsImN1cnJlbnRGaXJzdENoaWxkIiwibWFwUmVtYWluaW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkcmVuIiwidXNlRmliZXIiLCJjcmVhdGVXb3JrSW5Qcm9ncmVzcyIsInBsYWNlQ2hpbGQiLCJuZXdGaWJlciIsImxhc3RQbGFjZWRJbmRleCIsIm5ld0luZGV4IiwicGxhY2VTaW5nbGVDaGlsZCIsInVwZGF0ZVRleHROb2RlIiwidGV4dENvbnRlbnQiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwiX2RlYnVnT3duZXIiLCJ1cGRhdGVFbGVtZW50IiwiZWxlbWVudFR5cGUiLCJ1cGRhdGVGcmFnbWVudCIsImlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyIsImNhbGxMYXp5SW5pdEluREVWIiwiX293bmVyIiwidXBkYXRlUG9ydGFsIiwicG9ydGFsIiwiY29udGFpbmVySW5mbyIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlRmliZXJGcm9tUG9ydGFsIiwiZnJhZ21lbnQiLCJjcmVhdGVGaWJlckZyb21GcmFnbWVudCIsImNyZWF0ZUNoaWxkIiwiX3ByZXZEZWJ1Z0luZm8iLCJyZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uIiwidXBkYXRlU2xvdCIsIm9sZEZpYmVyIiwidXBkYXRlRnJvbU1hcCIsIm5ld0lkeCIsIl9wcmV2RGVidWdJbmZvNyIsIndhcm5PbkludmFsaWRLZXkiLCJrbm93bktleXMiLCJTZXQiLCJyZWNvbmNpbGVDaGlsZHJlbkFycmF5IiwibmV3Q2hpbGRyZW4iLCJyZXN1bHRpbmdGaXJzdENoaWxkIiwicHJldmlvdXNOZXdGaWJlciIsIm5leHRPbGRGaWJlciIsInJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IiLCJzdGVwIiwiZG9uZSIsInJlY29uY2lsZUNoaWxkRmliZXJzSW1wbCIsInByZXZEZWJ1Z0luZm8iLCJkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIiwiZW50cmllcyIsImRpZFdhcm5BYm91dE1hcHMiLCJmaXJzdENoaWxkRmliZXIiLCJwdXNoSGlkZGVuQ29udGV4dCIsInByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyIsImVudGFuZ2xlZFJlbmRlckxhbmVzIiwicHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yIiwiY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciIsImJhc2VMYW5lcyIsInJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2siLCJwb3BIaWRkZW5Db250ZXh0IiwicHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyIiwic3VzcGVuc2VTdGFja0N1cnNvciIsIlN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrIiwic3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IiLCJzaGVsbEJvdW5kYXJ5IiwicHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlciIsInJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayIsInBvcFN1c3BlbnNlSGFuZGxlciIsImZpbmRGaXJzdFN1c3BlbmRlZCIsInJvdyIsInN0YXRlIiwiaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyIsImlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrIiwicmV2ZWFsT3JkZXIiLCJtb3VudEhvb2tUeXBlc0RldiIsImhvb2tOYW1lIiwiY3VycmVudEhvb2tOYW1lSW5EZXYiLCJob29rVHlwZXNEZXYiLCJ1cGRhdGVIb29rVHlwZXNEZXYiLCJob29rVHlwZXNVcGRhdGVJbmRleERldiIsImN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEiLCJkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQiLCJ0YWJsZSIsIm9sZEhvb2tOYW1lIiwibmV3SG9va05hbWUiLCJjaGVja0RlcHNBcmVBcnJheURldiIsImRlcHMiLCJ3YXJuT25Vc2VGb3JtU3RhdGVJbkRldiIsImRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZSIsInRocm93SW52YWxpZEhvb2tFcnJvciIsImFyZUhvb2tJbnB1dHNFcXVhbCIsIm5leHREZXBzIiwicHJldkRlcHMiLCJpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyIsInJlbmRlcldpdGhIb29rcyIsIkNvbXBvbmVudCIsInNlY29uZEFyZyIsIm5leHRSZW5kZXJMYW5lcyIsIl9kZWJ1Z0hvb2tUeXBlcyIsImRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50IiwiSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViIsIkhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYiLCJIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYiLCJzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViIsIk5vTW9kZSIsImNhbGxDb21wb25lbnRJbkRFViIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyIsInJlbmRlcldpdGhIb29rc0FnYWluIiwiZmluaXNoUmVuZGVyaW5nSG9va3MiLCJkZXBlbmRlbmNpZXMiLCJmaXJzdENvbnRleHQiLCJfZGVidWdUaGVuYWJsZVN0YXRlIiwiQ29udGV4dE9ubHlEaXNwYXRjaGVyIiwiZGlkUmVuZGVyVG9vRmV3SG9va3MiLCJjdXJyZW50SG9vayIsIndvcmtJblByb2dyZXNzSG9vayIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUiLCJ0aGVuYWJsZUluZGV4Q291bnRlciIsImRpZFJlY2VpdmVVcGRhdGUiLCJjaGVja0lmQ29udGV4dENoYW5nZWQiLCJkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaCIsIm51bWJlck9mUmVSZW5kZXJzIiwiUkVfUkVOREVSX0xJTUlUIiwibGFzdEVmZmVjdCIsImV2ZW50cyIsInN0b3JlcyIsIm1lbW9DYWNoZSIsIkhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViIsIlRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnQiLCJkaXNwYXRjaGVyIiwibWF5YmVUaGVuYWJsZSIsInVzZVN0YXRlIiwidXNlVGhlbmFibGUiLCJjaGVja0RpZFJlbmRlcklkSG9vayIsImRpZFJlbmRlcklkSG9vayIsImxvY2FsSWRDb3VudGVyIiwiYmFpbG91dEhvb2tzIiwicmVzZXRIb29rc09uVW53aW5kIiwibW91bnRXb3JrSW5Qcm9ncmVzc0hvb2siLCJiYXNlUXVldWUiLCJ1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2siLCJuZXh0Q3VycmVudEhvb2siLCJuZXh0V29ya0luUHJvZ3Jlc3NIb29rIiwidXNlIiwidXNhYmxlIiwicmVhZENvbnRleHQiLCJ1c2VNZW1vQ2FjaGUiLCJkYXRhIiwibWFwIiwiY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSIsIkFycmF5IiwiUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCIsImJhc2ljU3RhdGVSZWR1Y2VyIiwiYWN0aW9uIiwibW91bnRSZWR1Y2VyIiwicmVkdWNlciIsImluaXRpYWxBcmciLCJpbml0IiwiaW5pdGlhbFN0YXRlIiwiZGlzcGF0Y2giLCJsYXN0UmVuZGVyZWRSZWR1Y2VyIiwibGFzdFJlbmRlcmVkU3RhdGUiLCJkaXNwYXRjaFJlZHVjZXJBY3Rpb24iLCJ1cGRhdGVSZWR1Y2VyIiwidXBkYXRlUmVkdWNlckltcGwiLCJiYXNlRmlyc3QiLCJuZXdCYXNlUXVldWVGaXJzdCIsIm5ld0Jhc2VRdWV1ZUxhc3QiLCJyZXZlcnRMYW5lIiwiaGFzRWFnZXJTdGF0ZSIsImVhZ2VyU3RhdGUiLCJyZXJlbmRlclJlZHVjZXIiLCJsYXN0UmVuZGVyUGhhc2VVcGRhdGUiLCJtb3VudFN5bmNFeHRlcm5hbFN0b3JlIiwic3Vic2NyaWJlIiwiZ2V0U25hcHNob3QiLCJnZXRTZXJ2ZXJTbmFwc2hvdCIsIm5leHRTbmFwc2hvdCIsImRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90IiwicHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayIsIm1vdW50RWZmZWN0Iiwic3Vic2NyaWJlVG9TdG9yZSIsInB1c2hFZmZlY3QiLCJIYXNFZmZlY3QiLCJQYXNzaXZlIiwidXBkYXRlU3RvcmVJbnN0YW5jZSIsImRlc3Ryb3kiLCJ1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZSIsImlzSHlkcmF0aW5nJGpzY29tcCQwIiwiY2FjaGVkU25hcHNob3QiLCJjcmVhdGUiLCJ1cGRhdGVFZmZlY3RJbXBsIiwicmVuZGVyZWRTbmFwc2hvdCIsImluc3QiLCJjaGVja0lmU25hcHNob3RDaGFuZ2VkIiwiZm9yY2VTdG9yZVJlcmVuZGVyIiwibGF0ZXN0R2V0U25hcHNob3QiLCJuZXh0VmFsdWUiLCJzY2hlZHVsZVVwZGF0ZU9uRmliZXIiLCJtb3VudFN0YXRlSW1wbCIsImluaXRpYWxTdGF0ZUluaXRpYWxpemVyIiwibW91bnRTdGF0ZSIsImRpc3BhdGNoU2V0U3RhdGUiLCJtb3VudE9wdGltaXN0aWMiLCJwYXNzdGhyb3VnaCIsImRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlIiwidXBkYXRlT3B0aW1pc3RpYyIsInVwZGF0ZU9wdGltaXN0aWNJbXBsIiwicmVyZW5kZXJPcHRpbWlzdGljIiwiZGlzcGF0Y2hBY3Rpb25TdGF0ZSIsImFjdGlvblF1ZXVlIiwic2V0UGVuZGluZ1N0YXRlIiwic2V0U3RhdGUiLCJpc1JlbmRlclBoYXNlVXBkYXRlIiwiYWN0aW9uTm9kZSIsImlzVHJhbnNpdGlvbiIsImxpc3RlbmVyIiwiVCIsInJ1bkFjdGlvblN0YXRlQWN0aW9uIiwicHJldlN0YXRlIiwicHJldlRyYW5zaXRpb24iLCJjdXJyZW50VHJhbnNpdGlvbiIsIl91cGRhdGVkRmliZXJzIiwicmV0dXJuVmFsdWUiLCJvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCIsIlMiLCJoYW5kbGVBY3Rpb25SZXR1cm5WYWx1ZSIsIm9uQWN0aW9uRXJyb3IiLCJlcnJvciQyIiwib25BY3Rpb25TdWNjZXNzIiwibm90aWZ5QWN0aW9uTGlzdGVuZXJzIiwibGFzdCIsImFjdGlvblN0YXRlUmVkdWNlciIsIm9sZFN0YXRlIiwibW91bnRBY3Rpb25TdGF0ZSIsImluaXRpYWxTdGF0ZVByb3AiLCJzc3JGb3JtU3RhdGUiLCJmb3JtU3RhdGUiLCJpc01hdGNoaW5nIiwibWFya2VySW5zdGFuY2UiLCJjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyIiwiaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyIsInVwZGF0ZUFjdGlvblN0YXRlIiwic3RhdGVIb29rIiwidXBkYXRlQWN0aW9uU3RhdGVJbXBsIiwiY3VycmVudFN0YXRlSG9vayIsImFjdGlvblF1ZXVlSG9vayIsImFjdGlvblN0YXRlQWN0aW9uRWZmZWN0IiwicmVyZW5kZXJBY3Rpb25TdGF0ZSIsIm1vdW50UmVmIiwiaW5pdGlhbFZhbHVlIiwibW91bnRFZmZlY3RJbXBsIiwiZmliZXJGbGFncyIsImhvb2tGbGFncyIsIm1vdW50TGF5b3V0RWZmZWN0IiwiTGF5b3V0IiwiaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdCIsInJlZkNsZWFudXAiLCJtb3VudEltcGVyYXRpdmVIYW5kbGUiLCJ1cGRhdGVJbXBlcmF0aXZlSGFuZGxlIiwibW91bnRDYWxsYmFjayIsInVwZGF0ZUNhbGxiYWNrIiwibW91bnRNZW1vIiwibmV4dENyZWF0ZSIsInVwZGF0ZU1lbW8iLCJtb3VudERlZmVycmVkVmFsdWUiLCJtb3VudERlZmVycmVkVmFsdWVJbXBsIiwidXBkYXRlRGVmZXJyZWRWYWx1ZSIsInVwZGF0ZURlZmVycmVkVmFsdWVJbXBsIiwicmVyZW5kZXJEZWZlcnJlZFZhbHVlIiwicmVxdWVzdERlZmVycmVkTGFuZSIsInByZXZWYWx1ZSIsInN0YXJ0VHJhbnNpdGlvbiIsInBlbmRpbmdTdGF0ZSIsImZpbmlzaGVkU3RhdGUiLCJwcmV2aW91c1ByaW9yaXR5IiwiZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5Iiwic2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5IiwidGhlbmFibGVGb3JGaW5pc2hlZFN0YXRlIiwiZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsIiwicmVxdWVzdFVwZGF0ZUxhbmUiLCJlbnN1cmVGb3JtQ29tcG9uZW50SXNTdGF0ZWZ1bCIsImZvcm1GaWJlciIsImV4aXN0aW5nU3RhdGVIb29rIiwiaW5pdGlhbFJlc2V0U3RhdGUiLCJtb3VudFRyYW5zaXRpb24iLCJ1cGRhdGVUcmFuc2l0aW9uIiwiYm9vbGVhbk9yVGhlbmFibGUiLCJzdGFydCIsInJlcmVuZGVyVHJhbnNpdGlvbiIsInVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzIiwibW91bnRJZCIsImlkZW50aWZpZXJQcmVmaXgiLCJ0cmVlSWQiLCJpZFdpdGhMZWFkaW5nQml0IiwiZ2xvYmFsQ2xpZW50SWRDb3VudGVyIiwibW91bnRSZWZyZXNoIiwicmVmcmVzaENhY2hlIiwic2VlZEtleSIsInByb3ZpZGVyIiwiY3JlYXRlQ2FjaGUiLCJjYWNoZSIsIkpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMCIsImVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZSIsImVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZSIsIkpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMSIsInByZXZEaXNwYXRjaGVyIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYiLCJjdXJyZW50U3RhdGUiLCJ0aHJvd0lmRHVyaW5nUmVuZGVyIiwid2Fybk9uSW52YWxpZENhbGxiYWNrIiwiZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrIiwiYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjdG9yIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwiY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsImRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCIsImNsYXNzQ29tcG9uZW50VXBkYXRlciIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJyZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyIsImJhc2VQcm9wcyIsImRlZmF1bHRQcm9wcyIsImxvZ1VuY2F1Z2h0RXJyb3IiLCJlcnJvckluZm8iLCJlcnJvckJvdW5kYXJ5TmFtZSIsInRocm93bkVycm9ycyIsIm9uVW5jYXVnaHRFcnJvciIsImNvbXBvbmVudFN0YWNrIiwiZSIsInNldFRpbWVvdXQiLCJsb2dDYXVnaHRFcnJvciIsImJvdW5kYXJ5Iiwib25DYXVnaHRFcnJvciIsImVycm9yQm91bmRhcnkiLCJjcmVhdGVSb290RXJyb3JVcGRhdGUiLCJjcmVhdGVDbGFzc0Vycm9yVXBkYXRlIiwiaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyIsImNvbXBvbmVudERpZENhdGNoIiwibGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQiLCJjYWxsQ29tcG9uZW50RGlkQ2F0Y2hJbkRFViIsInRocm93RXhjZXB0aW9uIiwicm9vdFJlbmRlckxhbmVzIiwicmVzdG9yZVBlbmRpbmdVcGRhdGVycyIsInByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzIiwicmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSIsIndvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMiLCJSb290SW5Qcm9ncmVzcyIsIlJvb3RTdXNwZW5kZWQiLCJub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUiLCJhdHRhY2hQaW5nTGlzdGVuZXIiLCJ0cmFuc2l0aW9ucyIsIm1hcmtlckluc3RhbmNlcyIsInJldHJ5UXVldWUiLCJjYXVzZSIsIlJvb3RTdXNwZW5kZWRXaXRoRGVsYXkiLCJSb290RXJyb3JlZCIsIndvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMiLCJyZWNvbmNpbGVDaGlsZHJlbiIsIm5leHRDaGlsZHJlbiIsIm1vdW50Q2hpbGRGaWJlcnMiLCJyZWNvbmNpbGVDaGlsZEZpYmVycyIsInVwZGF0ZUZvcndhcmRSZWYiLCJwcm9wc1dpdGhvdXRSZWYiLCJwcmVwYXJlVG9SZWFkQ29udGV4dCIsImJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsiLCJ1cGRhdGVNZW1vQ29tcG9uZW50Iiwic2hvdWxkQ29uc3RydWN0IiwiY29tcGFyZSIsInJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyIsInZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldiIsInVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQiLCJjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMiLCJjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCIsInByZXZQcm9wcyIsInVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50IiwidXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50IiwibmV4dElzRGV0YWNoZWQiLCJfcGVuZGluZ1Zpc2liaWxpdHkiLCJtYXJrUmVmIiwiZGVmZXJIaWRkZW5PZmZzY3JlZW5Db21wb25lbnQiLCJjYWNoZVBvb2wiLCJwdXNoVHJhbnNpdGlvbiIsIm5leHRCYXNlTGFuZXMiLCJwZWVrQ2FjaGVGcm9tUG9vbCIsIkNhY2hlQ29udGV4dCIsInBvb2wiLCJkaWRXYXJuQWJvdXRCYWRDbGFzcyIsIlJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzIiwicmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmciLCJjb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMiLCJyZXBsYXlGdW5jdGlvbkNvbXBvbmVudCIsInVwZGF0ZUNsYXNzQ29tcG9uZW50IiwiY3VycmVudCRqc2NvbXAkMCIsIl9pbnN0YW5jZSIsInVwZGF0ZXIiLCJlbnF1ZXVlU2V0U3RhdGUiLCJjb250ZXh0VHlwZSIsImRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSIsIl9yZWFjdEludGVybmFscyIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJmYWtlSW50ZXJuYWxJbnN0YW5jZSIsImRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmciLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIiwibmV3QXBpTmFtZSIsImRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUiLCJnZXRJbml0aWFsU3RhdGUiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImdldERlZmF1bHRQcm9wcyIsImNoaWxkQ29udGV4dFR5cGVzIiwiZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMSIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsImNvbXBvbmVudERpZFVubW91bnQiLCJjb21wb25lbnREaWRSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJjb21wb25lbnREaWRVcGRhdGUiLCJkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUiLCJnZXRDaGlsZENvbnRleHQiLCJyZWZzIiwiZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUiLCJyZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsImNvbXBvbmVudERpZE1vdW50IiwidW5yZXNvbHZlZE9sZFByb3BzIiwib2xkQ29udGV4dCIsImNhbGxSZW5kZXJJbkRFViIsImRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMiLCJtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyIsImRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQiLCJtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUiLCJnZXRTdXNwZW5kZWRDYWNoZSIsImdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlIiwicHJpbWFyeVRyZWVEaWREZWZlciIsIndvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lIiwidXBkYXRlU3VzcGVuc2VDb21wb25lbnQiLCJzaG93RmFsbGJhY2siLCJkaWRTdXNwZW5kIiwiSlNDb21waWxlcl90ZW1wIiwiRm9yY2VTdXNwZW5zZUZhbGxiYWNrIiwibmV4dEluc3RhbmNlIiwiSlNDb21waWxlcl90ZW1wJGpzY29tcCQwIiwiY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJ0cmVlQ29udGV4dCIsIm92ZXJmbG93IiwicmV0cnlMYW5lIiwiZmFsbGJhY2siLCJtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIiLCJTVVNQRU5ERURfTUFSS0VSIiwibW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbiIsInJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nIiwiZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzIiwiZGlnZXN0IiwiU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uIiwicmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeSIsInJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5IiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlIiwic3VidHJlZUZsYWdzIiwicHJpbWFyeUNoaWxkcmVuIiwib2Zmc2NyZWVuUHJvcHMiLCJjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4iLCJzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIiLCJwcm9wYWdhdGlvblJvb3QiLCJzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoIiwidmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZCIsImNoaWxkU2xvdCIsImlzQW5BcnJheSIsImluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSIsImlzQmFja3dhcmRzIiwidGFpbCIsImxhc3RDb250ZW50Um93IiwidGFpbE1vZGUiLCJyZW5kZXJTdGF0ZSIsInJlbmRlcmluZyIsInJlbmRlcmluZ1N0YXJ0VGltZSIsInVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudCIsImRpZFdhcm5BYm91dFJldmVhbE9yZGVyIiwiZGlkV2FybkFib3V0VGFpbE9wdGlvbnMiLCJfaSIsImF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlIiwicHVzaFByb3ZpZGVyIiwiZWZmZWN0RHVyYXRpb24iLCJwYXNzaXZlRWZmZWN0RHVyYXRpb24iLCJkaWRTdXNwZW5kQmVmb3JlIiwiYmVnaW5Xb3JrIiwiX2RlYnVnTmVlZHNSZW1vdW50IiwicHJldlNpYmxpbmciLCJyZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyIsInByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzIiwiaXNEZWh5ZHJhdGVkIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIiLCJzdXBwb3J0c1Jlc291cmNlcyIsImdldFJlc291cmNlIiwiY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2UiLCJyZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UiLCJkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQiLCJ2YWxpZGF0ZUh5ZHJhdGFibGVJbnN0YW5jZSIsImNhbkh5ZHJhdGVJbnN0YW5jZSIsInZhbGlkYXRlSHlkcmF0YWJsZVRleHRJbnN0YW5jZSIsImNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciIsInBvb2xlZENhY2hlIiwicmV0YWluQ2FjaGUiLCJwb29sZWRDYWNoZUxhbmVzIiwicmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzIiwibGFzdENvbnRleHREZXBlbmRlbmN5IiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIiLCJwcm92aWRlckZpYmVyIiwidmFsdWVDdXJzb3IiLCJyZW5kZXJlckN1cnNvckRFViIsIl9jdXJyZW50UmVuZGVyZXIiLCJyZW5kZXJlclNpZ2lsIiwicmVuZGVyZXIyQ3Vyc29yREVWIiwiX2N1cnJlbnRSZW5kZXJlcjIiLCJwb3BQcm92aWRlciIsImN1cnJlbnRWYWx1ZSIsImNvbnRleHRzIiwiZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlIiwibGlzdCIsIm5leHRGaWJlciIsImRlcGVuZGVuY3kiLCJpc0luc2lkZVByb3BhZ2F0aW9uQmFpbG91dCIsImN1cnJlbnRQYXJlbnQiLCJjdXJyZW50RGVwZW5kZW5jaWVzIiwibWVtb2l6ZWRWYWx1ZSIsInJlYWRDb250ZXh0Rm9yQ29uc3VtZXIiLCJjb25zdW1lciIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXJMb2NhbCIsInJlZkNvdW50Iiwic2lnbmFsIiwiYWJvcnRlZCIsInJlbGVhc2VDYWNoZSIsInNjaGVkdWxlQ2FsbGJhY2skMSIsIk5vcm1hbFByaW9yaXR5IiwiYWJvcnQiLCJjYWNoZVJlc3VtZWRGcm9tUHJldmlvdXNSZW5kZXIiLCJyZXN1bWVkQ2FjaGUiLCJvZmZzY3JlZW5Xb3JrSW5Qcm9ncmVzcyIsInByZXZDYWNoZVBvb2wiLCJjYWNoZUZyb21Qb29sIiwibWFya1VwZGF0ZSIsImRvZXNSZXF1aXJlQ2xvbmUiLCJjb21wbGV0ZWRXb3JrIiwiYXBwZW5kQWxsQ2hpbGRyZW4iLCJuZWVkc1Zpc2liaWxpdHlUb2dnbGUiLCJzdXBwb3J0c011dGF0aW9uIiwiYXBwZW5kSW5pdGlhbENoaWxkIiwic3VwcG9ydHNQZXJzaXN0ZW5jZSIsIl9ub2RlIiwiY2xvbmVIaWRkZW5JbnN0YW5jZSIsImNsb25lSGlkZGVuVGV4dEluc3RhbmNlIiwiYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciIsImNvbnRhaW5lckNoaWxkU2V0IiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0IiwidXBkYXRlSG9zdENvbnRhaW5lciIsImNvbnRhaW5lciIsIm5ld0NoaWxkU2V0IiwiY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQiLCJwZW5kaW5nQ2hpbGRyZW4iLCJmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuIiwidXBkYXRlSG9zdENvbXBvbmVudCIsImN1cnJlbnRJbnN0YW5jZSIsIl9vbGRQcm9wcyIsImN1cnJlbnRIb3N0Q29udGV4dCIsImNsb25lSW5zdGFuY2UiLCJmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiIsInByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZCIsIm1heVN1c3BlbmRDb21taXQiLCJwcmVsb2FkSW5zdGFuY2UiLCJzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuIiwiU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uIiwicHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkIiwicmVzb3VyY2UiLCJtYXlSZXNvdXJjZVN1c3BlbmRDb21taXQiLCJwcmVsb2FkUmVzb3VyY2UiLCJzY2hlZHVsZVJldHJ5RWZmZWN0Iiwid29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzIiwiY3V0T2ZmVGFpbElmTmVlZGVkIiwiaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrIiwibGFzdFRhaWxOb2RlIiwiX2xhc3RUYWlsTm9kZSIsImJ1YmJsZVByb3BlcnRpZXMiLCJkaWRCYWlsb3V0IiwibmV3Q2hpbGRMYW5lcyIsIl90cmVlQmFzZUR1cmF0aW9uIiwiX2NoaWxkMiIsInRyZWVCYXNlRHVyYXRpb24iLCJjb21wbGV0ZVdvcmsiLCJwZW5kaW5nQ29udGV4dCIsInF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMiLCJuZXh0UmVzb3VyY2UiLCJjcmVhdGVJbnN0YW5jZSIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyIsImh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSIsInByZXBhcmVQb3J0YWxNb3VudCIsInJlc2V0V29ya0luUHJvZ3Jlc3MiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lIiwidW53aW5kV29yayIsInVud2luZEludGVycnVwdGVkV29yayIsImludGVycnVwdGVkV29yayIsInNob3VsZFByb2ZpbGUiLCJjb21taXRIb29rTGF5b3V0RWZmZWN0cyIsImZpbmlzaGVkV29yayIsImNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQiLCJjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMiLCJuZWFyZXN0TW91bnRlZEFuY2VzdG9yIiwiY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50IiwiZmlyc3RFZmZlY3QiLCJOb0ZsYWdzIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkIiwiSW5zZXJ0aW9uIiwiaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0IiwiY2FsbENyZWF0ZUluREVWIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkIiwiYWRkZW5kdW0iLCJuIiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkIiwiY2FsbERlc3Ryb3lJbkRFViIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQiLCJjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyIsImNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMiLCJjb21taXRDbGFzc0NhbGxiYWNrcyIsImNhbGxHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXMiLCJjb21taXRDbGFzc1NuYXBzaG90IiwicmVzb2x2ZWRQcmV2UHJvcHMiLCJzbmFwc2hvdCIsImRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUiLCJzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQiLCJjYWxsQ29tcG9uZW50V2lsbFVubW91bnRJbkRFViIsImNvbW1pdEF0dGFjaFJlZiIsImdldFB1YmxpY0luc3RhbmNlIiwic2FmZWx5QXR0YWNoUmVmIiwic2FmZWx5RGV0YWNoUmVmIiwiZXJyb3IkMyIsImNvbW1pdFByb2ZpbGVyIiwiY29tbWl0U3RhcnRUaW1lIiwiX2ZpbmlzaGVkV29yayRtZW1vaXplIiwib25Db21taXQiLCJvblJlbmRlciIsImNvbW1pdFByb2ZpbGVyUG9zdENvbW1pdEltcGwiLCJfZmluaXNoZWRXb3JrJG1lbW9pemUyIiwib25Qb3N0Q29tbWl0IiwiY29tbWl0SG9zdE1vdW50IiwiY29tbWl0TW91bnQiLCJjb21taXRIb3N0VXBkYXRlIiwiY29tbWl0VXBkYXRlIiwiaXNIb3N0UGFyZW50IiwiZ2V0SG9zdFNpYmxpbmciLCJpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyIiwiYmVmb3JlIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJjb21taXRQbGFjZW1lbnQiLCJwYXJlbnRGaWJlciIsInJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRIb3N0UG9ydGFsQ29udGFpbmVyQ2hpbGRyZW4iLCJyZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4iLCJjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMiLCJmaXJzdENoaWxkIiwicHJlcGFyZUZvckNvbW1pdCIsIm5leHRFZmZlY3QiLCJjbGVhckNvbnRhaW5lciIsInNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciIsImNvbW1pdExheW91dEVmZmVjdE9uRmliZXIiLCJmaW5pc2hlZFJvb3QiLCJyZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyIsImNhbGxDb21wb25lbnREaWRNb3VudEluREVWIiwiY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWIiwiY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MiLCJvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4iLCJvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIiwicHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsInByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIiwicmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyIsImRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzIiwiZGV0YWNoRGVsZXRlZEluc3RhbmNlIiwicmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyIsImNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIiLCJkZWxldGVkRmliZXIiLCJvbkNvbW1pdEZpYmVyVW5tb3VudCIsInJlbGVhc2VSZXNvdXJjZSIsInVubW91bnRIb2lzdGFibGUiLCJwcmV2SG9zdFBhcmVudCIsImhvc3RQYXJlbnQiLCJwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyIiwiaG9zdFBhcmVudElzQ29udGFpbmVyIiwicmVsZWFzZVNpbmdsZXRvbkluc3RhbmNlIiwicmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyIiwicmVtb3ZlQ2hpbGQiLCJjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyIiwiY2xlYXJTdXNwZW5zZUJvdW5kYXJ5IiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJnZXRSZXRyeUNhY2hlIiwicmV0cnlDYWNoZSIsIlBvc3NpYmx5V2Vha1NldCIsIl9yZXRyeUNhY2hlIiwiYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyIsIndha2VhYmxlcyIsIndha2VhYmxlIiwicmV0cnkiLCJyZXNvbHZlUmV0cnlXYWtlYWJsZSIsImluUHJvZ3Jlc3NMYW5lcyIsImluUHJvZ3Jlc3NSb290IiwiY29tbWl0TXV0YXRpb25FZmZlY3RzIiwiY29tbWl0dGVkTGFuZXMiLCJjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyIsInJvb3QkanNjb21wJDAiLCJjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMiLCJob2lzdGFibGVSb290IiwiY3VycmVudEhvaXN0YWJsZVJvb3QiLCJoeWRyYXRlSG9pc3RhYmxlIiwibW91bnRIb2lzdGFibGUiLCJhY3F1aXJlUmVzb3VyY2UiLCJjbGVhclNpbmdsZXRvbiIsImFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZSIsIm5lZWRzRm9ybVJlc2V0IiwiY29tbWl0VGV4dFVwZGF0ZSIsInByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXMiLCJnZXRIb2lzdGFibGVSb290IiwiY29tbWl0SHlkcmF0ZWRDb250YWluZXIiLCJyZWN1cnNpdmVseVJlc2V0Rm9ybXMiLCJnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIiwid2FzSGlkZGVuIiwiX2N1cnJlbnQiLCJyZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyIsImhpZGVJbnN0YW5jZSIsInVuaGlkZUluc3RhbmNlIiwiaGlkZVRleHRJbnN0YW5jZSIsInVuaGlkZVRleHRJbnN0YW5jZSIsInJlc2V0Rm9ybUluc3RhbmNlIiwiY29tbWl0TGF5b3V0RWZmZWN0cyIsImRpc2FwcGVhckxheW91dEVmZmVjdHMiLCJyZWFwcGVhckxheW91dEVmZmVjdHMiLCJpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzIiwiY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyIsInByZXZpb3VzQ2FjaGUiLCJjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdCIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzIiwiY29tbWl0dGVkVHJhbnNpdGlvbnMiLCJjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzIiwicmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzIiwicmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJfaW5zdGFuY2UyIiwiZmluaXNoZWRSb290JGpzY29tcCQwIiwicmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0Iiwic3VzcGVuc2V5Q29tbWl0RmxhZyIsImFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyIiwic3VzcGVuZFJlc291cmNlIiwic3VzcGVuZEluc3RhbmNlIiwicHJldmlvdXNIb2lzdGFibGVSb290IiwiZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MiLCJyZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbiIsImNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlciIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdCIsImRlbGV0ZWRTdWJ0cmVlUm9vdCIsImZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdCIsImhvc3RSb290IiwibWF5YmVGaWJlciIsImdldEluc3RhbmNlRnJvbU5vZGUiLCJmaW5kRmliZXJSb290IiwibWF0Y2hTZWxlY3RvciIsImZpYmVyJGpzY29tcCQwIiwic2VsZWN0b3IiLCJDT01QT05FTlRfVFlQRSIsIkhBU19QU0VVRE9fQ0xBU1NfVFlQRSIsInRhZyRqc2NvbXAkMCIsInNlbGVjdG9ySW5kZXgiLCJzZWxlY3RvciRqc2NvbXAkMCIsImlzSGlkZGVuU3VidHJlZSIsIlJPTEVfVFlQRSIsIm1hdGNoQWNjZXNzaWJpbGl0eVJvbGUiLCJURVhUX1RZUEUiLCJnZXRUZXh0Q29udGVudCIsIlRFU1RfTkFNRV9UWVBFIiwic2VsZWN0b3JUb1N0cmluZyIsImZpbmRQYXRocyIsInNlbGVjdG9ycyIsIm1hdGNoaW5nRmliZXJzIiwiZmluZEFsbE5vZGVzIiwic3VwcG9ydHNUZXN0U2VsZWN0b3JzIiwiZnJvbSIsIm9uQ29tbWl0Um9vdCIsImNvbW1pdEhvb2tzIiwiY29tbWl0SG9vayIsImlzQ29uY3VycmVudEFjdEVudmlyb25tZW50IiwiaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsIiwiSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIiwicmVzb2x2ZVVwZGF0ZVByaW9yaXR5Iiwic3VzcGVuc2VIYW5kbGVyIiwiaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzIiwiZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyIsInByZXBhcmVGcmVzaFN0YWNrIiwibWFya1Jvb3RTdXNwZW5kZWQiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciIsIndhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFViIsIndvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIiwiZm9yY2VTeW5jIiwic2hvdWxkVGltZVNsaWNlIiwiZXhpdFN0YXR1cyIsInJlbmRlclJvb3RDb25jdXJyZW50IiwicmVuZGVyUm9vdFN5bmMiLCJyZW5kZXJXYXNDb25jdXJyZW50Iiwid29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmciLCJSb290RGlkTm90Q29tcGxldGUiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MiLCJpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMiLCJlcnJvclJldHJ5TGFuZXMiLCJlcnJvclJldHJ5TGFuZXMkanNjb21wJDAiLCJ3YXNSb290RGVoeWRyYXRlZCIsIndvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciIsIndvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzIiwiUm9vdEZhdGFsRXJyb3JlZCIsIlJvb3RDb21wbGV0ZWQiLCJjb21taXRSb290Iiwid29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyIsIndvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUiLCJJTU1FRElBVEVfQ09NTUlUIiwiRkFMTEJBQ0tfVEhST1RUTEVfTVMiLCJ0aW1lb3V0SGFuZGxlIiwic2NoZWR1bGVUaW1lb3V0IiwiY29tbWl0Um9vdFdoZW5SZWFkeSIsIlRIUk9UVExFRF9DT01NSVQiLCJlcnJvcnMiLCJhcHBseSIsInJlY292ZXJhYmxlRXJyb3JzIiwiZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlIiwiZGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzIiwic3VzcGVuZGVkQ29tbWl0UmVhc29uIiwiY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lIiwiY29tcGxldGVkUmVuZGVyRW5kVGltZSIsInN0YXJ0U3VzcGVuZGluZ0NvbW1pdCIsIndhaXRGb3JDb21taXRUb0JlUmVhZHkiLCJTVVNQRU5ERURfQ09NTUlUIiwiY2hlY2siLCJkaWRBdHRlbXB0RW50aXJlVHJlZSIsIndvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzIiwicmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrIiwiTm90U3VzcGVuZGVkIiwibm9UaW1lb3V0IiwiY2FuY2VsVGltZW91dCIsIndvcmtJblByb2dyZXNzVGhyb3duVmFsdWUiLCJhbGxFbnRhbmdsZWRMYW5lcyIsImRpc2NhcmRQZW5kaW5nV2FybmluZ3MiLCJoYW5kbGVUaHJvdyIsInRocm93blZhbHVlIiwiU3VzcGVuZGVkT25JbW1lZGlhdGUiLCJTdXNwZW5kZWRPbkluc3RhbmNlIiwiU3VzcGVuZGVkT25IeWRyYXRpb24iLCJTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2UiLCJTdXNwZW5kZWRPbkVycm9yIiwiZXJyb3JlZFdvcmsiLCJtYXJrQ29tcG9uZW50RXJyb3JlZCIsIlN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZSIsIm1hcmtDb21wb25lbnRTdXNwZW5kZWQiLCJwdXNoRGlzcGF0Y2hlciIsInB1c2hBc3luY0Rpc3BhdGNoZXIiLCJwcmV2QXN5bmNEaXNwYXRjaGVyIiwiQSIsIkRlZmF1bHRBc3luY0Rpc3BhdGNoZXIiLCJzaG91bGRZaWVsZEZvclByZXJlbmRlcmluZyIsInByZXZFeGVjdXRpb25Db250ZXh0IiwidW5pdE9mV29yayIsInRocm93QW5kVW53aW5kV29ya0xvb3AiLCJ3b3JrTG9vcFN5bmMiLCJ0aHJvd25WYWx1ZSQ0IiwicGVyZm9ybVVuaXRPZldvcmsiLCJSRU5ERVJfVElNRU9VVF9NUyIsInJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsiLCJTdXNwZW5kZWRPbkluc3RhbmNlQW5kUmVhZHlUb0NvbnRpbnVlIiwiaG9zdEZpYmVyIiwiY29tcGxldGVVbml0T2ZXb3JrIiwid29ya0xvb3BDb25jdXJyZW50IiwidGhyb3duVmFsdWUkNSIsIm1hcmtSZW5kZXJZaWVsZGVkIiwic2hvdWxkWWllbGQiLCJyZXBsYXlCZWdpbldvcmsiLCJpc1Byb2ZpbGluZ01vZGUiLCJzdXNwZW5kZWRSZWFzb24iLCJ1bndpbmRVbml0T2ZXb3JrIiwic2tpcFNpYmxpbmdzIiwicHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkiLCJjb21taXRSb290SW1wbCIsInJlbmRlclByaW9yaXR5TGV2ZWwiLCJyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyIsImZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmciLCJmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsIm1hcmtDb21taXRTdGFydGVkIiwicm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMiLCJwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyIsInBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMiLCJzY2hlZHVsZUNhbGxiYWNrIiwicmVzZXRBZnRlckNvbW1pdCIsIm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZCIsIm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCIsInJlcXVlc3RQYWludCIsInBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzIiwicmVsZWFzZVJvb3RQb29sZWRDYWNoZSIsImNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFViIsIm9uUmVjb3ZlcmFibGVFcnJvciIsIm1ha2VFcnJvckluZm8iLCJyZW5kZXJQcmlvcml0eSIsInByaW9yaXR5IiwibWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCIsIm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQiLCJvblBvc3RDb21taXRGaWJlclJvb3QiLCJjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdCIsInJvb3RGaWJlciIsInBpbmdDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsInRocmVhZElEcyIsInBpbmdTdXNwZW5kZWRSb290IiwicmV0cnlUaW1lZE91dEJvdW5kYXJ5IiwiYm91bmRhcnlGaWJlciIsInN1c3BlbnNlU3RhdGUiLCJyZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWIiwiaXNJblN0cmljdE1vZGUiLCJpc1N0cmljdE1vZGVGaWJlciIsImRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyIiwic2hvdWxkRG91YmxlSW52b2tlUGFzc2l2ZUVmZmVjdHMiLCJhcmd1bWVudHMiLCJkb3VibGVJbnZva2VFZmZlY3RzIiwiZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCIsInNjaGVkdWxpbmdGaWJlciIsInByaW9yaXR5TGV2ZWwiLCJmYWtlQWN0Q2FsbGJhY2tOb2RlIiwiZmFtaWx5IiwicHJldlR5cGUiLCJuZWVkc0NvbXBhcmVGYW1pbGllcyIsIiQkdHlwZW9mTmV4dFR5cGUiLCJXZWFrU2V0IiwiZmFpbGVkQm91bmRhcmllcyIsImNhbmRpZGF0ZVR5cGUiLCJuZWVkc1JlbmRlciIsImhhc0JhZE1hcFBvbHlmaWxsIiwicHJldmVudEV4dGVuc2lvbnMiLCJpc1JlYWN0Q29tcG9uZW50Iiwib3duZXIiLCJmaWJlclRhZyIsInJlc29sdmVkVHlwZSIsImlzSG9zdEhvaXN0YWJsZVR5cGUiLCJpc0hvc3RTaW5nbGV0b25UeXBlIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiZWxlbWVudHMiLCJwcmltYXJ5Q2hpbGRJbnN0YW5jZSIsIl9wZW5kaW5nTWFya2VycyIsIl90cmFuc2l0aW9ucyIsImRldGFjaCIsImF0dGFjaCIsIkZpYmVyUm9vdE5vZGUiLCJoeWRyYXRlIiwiaW5jb21wbGV0ZVRyYW5zaXRpb25zIiwiX2RlYnVnUm9vdFR5cGUiLCJjcmVhdGVGaWJlclJvb3QiLCJpbml0aWFsQ2hpbGRyZW4iLCJoeWRyYXRpb25DYWxsYmFja3MiLCJpc1N0cmljdE1vZGUiLCJ0cmFuc2l0aW9uQ2FsbGJhY2tzIiwidGVzdFN0cmluZ0NvZXJjaW9uIiwiZ2V0Q29udGV4dEZvclN1YnRyZWUiLCJwYXJlbnRDb21wb25lbnQiLCJ1cGRhdGVDb250YWluZXJJbXBsIiwib25TY2hlZHVsZUZpYmVyUm9vdCIsIm1hcmtSZW5kZXJTY2hlZHVsZWQiLCJkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzIiwibWFya1JldHJ5TGFuZUltcGwiLCJtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZCIsImdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzIiwiZ2V0TGFuZUxhYmVsTWFwIiwibGFiZWwiLCJSZWFjdCIsInJlcXVpcmUiLCJTY2hlZHVsZXIiLCJTeW1ib2wiLCJmb3IiLCJpdGVyYXRvciIsIl9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSIsIl9fcmVhY3REaXNhYmxlZExvZyIsIldlYWtNYXAiLCJpc0FycmF5IiwicmVuZGVyZXJWZXJzaW9uIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsImV4dHJhRGV2VG9vbHNDb25maWciLCJ3YXJuc0lmTm90QWN0aW5nIiwiYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyIiwiYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIiLCJwcmVwYXJlU2NvcGVVcGRhdGUiLCJnZXRJbnN0YW5jZUZyb21TY29wZSIsInJlc29sdmVFdmVudFR5cGUiLCJyZXNvbHZlRXZlbnRUaW1lU3RhbXAiLCJyZXF1ZXN0UG9zdFBhaW50Q2FsbGJhY2siLCJiaW5kVG9Db25zb2xlIiwiZ2V0Qm91bmRpbmdSZWN0Iiwic2V0Rm9jdXNJZkZvY3VzYWJsZSIsInNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJmcmVlemUiLCJNYXRoIiwidW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayIsInVuc3RhYmxlX2NhbmNlbENhbGxiYWNrIiwidW5zdGFibGVfc2hvdWxkWWllbGQiLCJ1bnN0YWJsZV9yZXF1ZXN0UGFpbnQiLCJ1bnN0YWJsZV9ub3ciLCJ1bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSIsInVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5IiwidW5zdGFibGVfTm9ybWFsUHJpb3JpdHkiLCJ1bnN0YWJsZV9JZGxlUHJpb3JpdHkiLCJwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzIiwiZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyIsImNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyIsImNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMiLCJzb3J0ZWROYW1lcyIsInBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyIsImRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQiLCJzdHJpY3RSb290IiwiZmliZXJBcnJheSIsImZpcnN0RmliZXIiLCJ1bmlxdWVOYW1lcyIsImNhbGxDb21wb25lbnQiLCJ3YXNSZW5kZXJpbmciLCJjYWxsUmVuZGVyIiwiY2FsbENvbXBvbmVudERpZE1vdW50IiwiY2FsbENvbXBvbmVudERpZFVwZGF0ZSIsImNhbGxDb21wb25lbnREaWRDYXRjaCIsImNhbGxDb21wb25lbnRXaWxsVW5tb3VudCIsImNhbGxDcmVhdGUiLCJlZmZlY3QiLCJjYWxsRGVzdHJveSIsImNhbGxMYXp5SW5pdCIsImxhenkiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJfc3RvcmUiLCJ2YWxpZGF0ZWQiLCJjb21wb25lbnRLZXkiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lckFwcGVuZGl4IiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZUxheW91dEVmZmVjdCIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWR1Y2VyIiwidXNlUmVmIiwidXNlRGVidWdWYWx1ZSIsInVzZURlZmVycmVkVmFsdWUiLCJ1c2VUcmFuc2l0aW9uIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJ1c2VJZCIsInVzZUNhY2hlUmVmcmVzaCIsInVzZUZvcm1TdGF0ZSIsInVzZUFjdGlvblN0YXRlIiwidXNlT3B0aW1pc3RpYyIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYiLCJJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIiwiaXNNb3VudGVkIiwiY29tcG9uZW50IiwiX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwibWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkIiwicmVwb3J0R2xvYmFsRXJyb3IiLCJyZXBvcnRFcnJvciIsIndpbmRvdyIsIkVycm9yRXZlbnQiLCJldmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiZGlzcGF0Y2hFdmVudCIsInByb2Nlc3MiLCJlbWl0IiwiQWJvcnRDb250cm9sbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIkNvbnN1bWVyIiwiUHJvdmlkZXIiLCJfdGhyZWFkQ291bnQiLCJwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2giLCJnZXRDYWNoZUZvclR5cGUiLCJyZXNvdXJjZVR5cGUiLCJjYWNoZUZvclR5cGUiLCJnZXRPd25lciIsInN5bWJvbEZvciIsIkluZmluaXR5Iiwibm9uRXh0ZW5zaWJsZU9iamVjdCIsImRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlIiwib3ZlcnJpZGVIb29rU3RhdGUiLCJvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgiLCJvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgiLCJvdmVycmlkZVByb3BzIiwib3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgiLCJvdmVycmlkZVByb3BzUmVuYW1lUGF0aCIsInNjaGVkdWxlVXBkYXRlIiwic2V0RXJyb3JIYW5kbGVyIiwic2V0U3VzcGVuc2VIYW5kbGVyIiwibmV3U2hvdWxkRXJyb3JJbXBsIiwibmV3U2hvdWxkU3VzcGVuZEltcGwiLCJhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiIsImF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSIsImF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiIsImJhdGNoZWRVcGRhdGVzIiwiY3JlYXRlQ29tcG9uZW50U2VsZWN0b3IiLCJjcmVhdGVDb250YWluZXIiLCJjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlIiwiY3JlYXRlSGFzUHNldWRvQ2xhc3NTZWxlY3RvciIsImNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lciIsImNyZWF0ZVBvcnRhbCIsImUkNiIsInRvU3RyaW5nVGFnIiwiY3JlYXRlUm9sZVNlbGVjdG9yIiwicm9sZSIsImNyZWF0ZVRlc3ROYW1lU2VsZWN0b3IiLCJjcmVhdGVUZXh0U2VsZWN0b3IiLCJ0ZXh0IiwiZGVmYXVsdE9uQ2F1Z2h0RXJyb3IiLCJjb21wb25lbnROYW1lTWVzc2FnZSIsInJlY3JlYXRlTWVzc2FnZSIsInByZXZHZXRDdXJyZW50U3RhY2siLCJlbnZpcm9ubWVudE5hbWUiLCJkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yIiwiZGVmYXVsdE9uVW5jYXVnaHRFcnJvciIsImRlZmVycmVkVXBkYXRlcyIsImRpc2NyZXRlVXBkYXRlcyIsImQiLCJmaW5kQm91bmRpbmdSZWN0cyIsInRhcmdldExlZnQiLCJ0YXJnZXRSaWdodCIsIndpZHRoIiwidGFyZ2V0VG9wIiwidGFyZ2V0Qm90dG9tIiwiaGVpZ2h0IiwiaiIsIm90aGVyUmVjdCIsIm90aGVyTGVmdCIsIm90aGVyUmlnaHQiLCJvdGhlclRvcCIsIm90aGVyQm90dG9tIiwiZmluZEhvc3RJbnN0YW5jZSIsImZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzIiwiZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nIiwibWV0aG9kTmFtZSIsImZsdXNoU3luY0Zyb21SZWNvbmNpbGVyIiwiZm9jdXNXaXRoaW4iLCJnZXRGaW5kQWxsTm9kZXNGYWlsdXJlRGVzY3JpcHRpb24iLCJtYXhTZWxlY3RvckluZGV4IiwibWF0Y2hlZE5hbWVzIiwiZ2V0UHVibGljUm9vdEluc3RhbmNlIiwiaW5qZWN0SW50b0RldlRvb2xzIiwiYnVuZGxlVHlwZSIsInZlcnNpb24iLCJjdXJyZW50RGlzcGF0Y2hlclJlZiIsImZpbmRGaWJlckJ5SG9zdEluc3RhbmNlIiwicmVjb25jaWxlclZlcnNpb24iLCJyZW5kZXJlckNvbmZpZyIsImdldEN1cnJlbnRGaWJlciIsImlzQWxyZWFkeVJlbmRlcmluZyIsIm9ic2VydmVWaXNpYmxlUmVjdHMiLCJvcHRpb25zIiwibmV4dEluc3RhbmNlUm9vdHMiLCJpbnN0YW5jZVJvb3RzIiwidGFyZ2V0IiwidW5vYnNlcnZlIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJzaG91bGRFcnJvciIsInNob3VsZFN1c3BlbmQiLCJzdGFydEhvc3RUcmFuc2l0aW9uIiwiZm9ybURhdGEiLCJyZXNldFN0YXRlUXVldWUiLCJ1cGRhdGVDb250YWluZXIiLCJkZWZhdWx0Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/react-reconciler/constants.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler-constants.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGtMQUEyRTtBQUM3RSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxFZ29mb3h4eFxcRG9jdW1lbnRzXFxwb3J0Zm9saW8td2Vic2l0ZVxcbm9kZV9tb2R1bGVzXFxyZWFjdC1yZWNvbmNpbGVyXFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-reconciler/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsOEpBQWlFO0FBQ25FIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEVnb2ZveHh4XFxEb2N1bWVudHNcXHBvcnRmb2xpby13ZWJzaXRlXFxub2RlX21vZHVsZXNcXHJlYWN0LXJlY29uY2lsZXJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function performWorkUntilDeadline() {\n      if (isMessageLoopRunning) {\n        var currentTime = exports.unstable_now();\n        startTime = currentTime;\n        var hasMoreWork = !0;\n        try {\n          a: {\n            isHostCallbackScheduled = !1;\n            isHostTimeoutScheduled &&\n              ((isHostTimeoutScheduled = !1),\n              localClearTimeout(taskTimeoutID),\n              (taskTimeoutID = -1));\n            isPerformingWork = !0;\n            var previousPriorityLevel = currentPriorityLevel;\n            try {\n              b: {\n                advanceTimers(currentTime);\n                for (\n                  currentTask = peek(taskQueue);\n                  null !== currentTask &&\n                  !(\n                    currentTask.expirationTime > currentTime &&\n                    shouldYieldToHost()\n                  );\n\n                ) {\n                  var callback = currentTask.callback;\n                  if (\"function\" === typeof callback) {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    var continuationCallback = callback(\n                      currentTask.expirationTime <= currentTime\n                    );\n                    currentTime = exports.unstable_now();\n                    if (\"function\" === typeof continuationCallback) {\n                      currentTask.callback = continuationCallback;\n                      advanceTimers(currentTime);\n                      hasMoreWork = !0;\n                      break b;\n                    }\n                    currentTask === peek(taskQueue) && pop(taskQueue);\n                    advanceTimers(currentTime);\n                  } else pop(taskQueue);\n                  currentTask = peek(taskQueue);\n                }\n                if (null !== currentTask) hasMoreWork = !0;\n                else {\n                  var firstTimer = peek(timerQueue);\n                  null !== firstTimer &&\n                    requestHostTimeout(\n                      handleTimeout,\n                      firstTimer.startTime - currentTime\n                    );\n                  hasMoreWork = !1;\n                }\n              }\n              break a;\n            } finally {\n              (currentTask = null),\n                (currentPriorityLevel = previousPriorityLevel),\n                (isPerformingWork = !1);\n            }\n            hasMoreWork = void 0;\n          }\n        } finally {\n          hasMoreWork\n            ? schedulePerformWorkUntilDeadline()\n            : (isMessageLoopRunning = !1);\n        }\n      }\n    }\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      a: for (; 0 < index; ) {\n        var parentIndex = (index - 1) >>> 1,\n          parent = heap[parentIndex];\n        if (0 < compare(parent, node))\n          (heap[parentIndex] = node),\n            (heap[index] = parent),\n            (index = parentIndex);\n        else break a;\n      }\n    }\n    function peek(heap) {\n      return 0 === heap.length ? null : heap[0];\n    }\n    function pop(heap) {\n      if (0 === heap.length) return null;\n      var first = heap[0],\n        last = heap.pop();\n      if (last !== first) {\n        heap[0] = last;\n        a: for (\n          var index = 0, length = heap.length, halfLength = length >>> 1;\n          index < halfLength;\n\n        ) {\n          var leftIndex = 2 * (index + 1) - 1,\n            left = heap[leftIndex],\n            rightIndex = leftIndex + 1,\n            right = heap[rightIndex];\n          if (0 > compare(left, last))\n            rightIndex < length && 0 > compare(right, left)\n              ? ((heap[index] = right),\n                (heap[rightIndex] = last),\n                (index = rightIndex))\n              : ((heap[index] = left),\n                (heap[leftIndex] = last),\n                (index = leftIndex));\n          else if (rightIndex < length && 0 > compare(right, last))\n            (heap[index] = right),\n              (heap[rightIndex] = last),\n              (index = rightIndex);\n          else break a;\n        }\n      }\n      return first;\n    }\n    function compare(a, b) {\n      var diff = a.sortIndex - b.sortIndex;\n      return 0 !== diff ? diff : a.id - b.id;\n    }\n    function advanceTimers(currentTime) {\n      for (var timer = peek(timerQueue); null !== timer; ) {\n        if (null === timer.callback) pop(timerQueue);\n        else if (timer.startTime <= currentTime)\n          pop(timerQueue),\n            (timer.sortIndex = timer.expirationTime),\n            push(taskQueue, timer);\n        else break;\n        timer = peek(timerQueue);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = !1;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled)\n        if (null !== peek(taskQueue))\n          (isHostCallbackScheduled = !0), requestHostCallback();\n        else {\n          var firstTimer = peek(timerQueue);\n          null !== firstTimer &&\n            requestHostTimeout(\n              handleTimeout,\n              firstTimer.startTime - currentTime\n            );\n        }\n    }\n    function shouldYieldToHost() {\n      return exports.unstable_now() - startTime < frameInterval ? !1 : !0;\n    }\n    function requestHostCallback() {\n      isMessageLoopRunning ||\n        ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());\n    }\n    function requestHostTimeout(callback, ms) {\n      taskTimeoutID = localSetTimeout(function () {\n        callback(exports.unstable_now());\n      }, ms);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    exports.unstable_now = void 0;\n    if (\n      \"object\" === typeof performance &&\n      \"function\" === typeof performance.now\n    ) {\n      var localPerformance = performance;\n      exports.unstable_now = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date,\n        initialTime = localDate.now();\n      exports.unstable_now = function () {\n        return localDate.now() - initialTime;\n      };\n    }\n    var taskQueue = [],\n      timerQueue = [],\n      taskIdCounter = 1,\n      currentTask = null,\n      currentPriorityLevel = 3,\n      isPerformingWork = !1,\n      isHostCallbackScheduled = !1,\n      isHostTimeoutScheduled = !1,\n      localSetTimeout = \"function\" === typeof setTimeout ? setTimeout : null,\n      localClearTimeout =\n        \"function\" === typeof clearTimeout ? clearTimeout : null,\n      localSetImmediate =\n        \"undefined\" !== typeof setImmediate ? setImmediate : null,\n      isMessageLoopRunning = !1,\n      taskTimeoutID = -1,\n      frameInterval = 5,\n      startTime = -1;\n    if (\"function\" === typeof localSetImmediate)\n      var schedulePerformWorkUntilDeadline = function () {\n        localSetImmediate(performWorkUntilDeadline);\n      };\n    else if (\"undefined\" !== typeof MessageChannel) {\n      var channel = new MessageChannel(),\n        port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      schedulePerformWorkUntilDeadline = function () {\n        port.postMessage(null);\n      };\n    } else\n      schedulePerformWorkUntilDeadline = function () {\n        localSetTimeout(performWorkUntilDeadline, 0);\n      };\n    exports.unstable_IdlePriority = 5;\n    exports.unstable_ImmediatePriority = 1;\n    exports.unstable_LowPriority = 4;\n    exports.unstable_NormalPriority = 3;\n    exports.unstable_Profiling = null;\n    exports.unstable_UserBlockingPriority = 2;\n    exports.unstable_cancelCallback = function (task) {\n      task.callback = null;\n    };\n    exports.unstable_continueExecution = function () {\n      isHostCallbackScheduled ||\n        isPerformingWork ||\n        ((isHostCallbackScheduled = !0), requestHostCallback());\n    };\n    exports.unstable_forceFrameRate = function (fps) {\n      0 > fps || 125 < fps\n        ? console.error(\n            \"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\"\n          )\n        : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);\n    };\n    exports.unstable_getCurrentPriorityLevel = function () {\n      return currentPriorityLevel;\n    };\n    exports.unstable_getFirstCallbackNode = function () {\n      return peek(taskQueue);\n    };\n    exports.unstable_next = function (eventHandler) {\n      switch (currentPriorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n          var priorityLevel = 3;\n          break;\n        default:\n          priorityLevel = currentPriorityLevel;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_pauseExecution = function () {};\n    exports.unstable_requestPaint = function () {};\n    exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n          break;\n        default:\n          priorityLevel = 3;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_scheduleCallback = function (\n      priorityLevel,\n      callback,\n      options\n    ) {\n      var currentTime = exports.unstable_now();\n      \"object\" === typeof options && null !== options\n        ? ((options = options.delay),\n          (options =\n            \"number\" === typeof options && 0 < options\n              ? currentTime + options\n              : currentTime))\n        : (options = currentTime);\n      switch (priorityLevel) {\n        case 1:\n          var timeout = -1;\n          break;\n        case 2:\n          timeout = 250;\n          break;\n        case 5:\n          timeout = 1073741823;\n          break;\n        case 4:\n          timeout = 1e4;\n          break;\n        default:\n          timeout = 5e3;\n      }\n      timeout = options + timeout;\n      priorityLevel = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: options,\n        expirationTime: timeout,\n        sortIndex: -1\n      };\n      options > currentTime\n        ? ((priorityLevel.sortIndex = options),\n          push(timerQueue, priorityLevel),\n          null === peek(taskQueue) &&\n            priorityLevel === peek(timerQueue) &&\n            (isHostTimeoutScheduled\n              ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))\n              : (isHostTimeoutScheduled = !0),\n            requestHostTimeout(handleTimeout, options - currentTime)))\n        : ((priorityLevel.sortIndex = timeout),\n          push(taskQueue, priorityLevel),\n          isHostCallbackScheduled ||\n            isPerformingWork ||\n            ((isHostCallbackScheduled = !0), requestHostCallback()));\n      return priorityLevel;\n    };\n    exports.unstable_shouldYield = shouldYieldToHost;\n    exports.unstable_wrapCallback = function (callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQkFBb0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0JBQW9CO0FBQzFCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU0sb0JBQW9CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUksNkJBQTZCO0FBQ2pDLElBQUksa0NBQWtDO0FBQ3RDLElBQUksNEJBQTRCO0FBQ2hDLElBQUksK0JBQStCO0FBQ25DLElBQUksMEJBQTBCO0FBQzlCLElBQUkscUNBQXFDO0FBQ3pDLElBQUksK0JBQStCO0FBQ25DO0FBQ0E7QUFDQSxJQUFJLGtDQUFrQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0JBQStCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0NBQXdDO0FBQzVDO0FBQ0E7QUFDQSxJQUFJLHFDQUFxQztBQUN6QztBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQkFBK0I7QUFDbkMsSUFBSSw2QkFBNkI7QUFDakMsSUFBSSxnQ0FBZ0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlDQUFpQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0QkFBNEI7QUFDaEMsSUFBSSw2QkFBNkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEVnb2ZveHh4XFxEb2N1bWVudHNcXHBvcnRmb2xpby13ZWJzaXRlXFxub2RlX21vZHVsZXNcXHJlYWN0LXJlY29uY2lsZXJcXG5vZGVfbW9kdWxlc1xcc2NoZWR1bGVyXFxjanNcXHNjaGVkdWxlci5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiBzY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCkge1xuICAgICAgaWYgKGlzTWVzc2FnZUxvb3BSdW5uaW5nKSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgaGFzTW9yZVdvcmsgPSAhMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICExO1xuICAgICAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCAmJlxuICAgICAgICAgICAgICAoKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMSksXG4gICAgICAgICAgICAgIGxvY2FsQ2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpLFxuICAgICAgICAgICAgICAodGFza1RpbWVvdXRJRCA9IC0xKSk7XG4gICAgICAgICAgICBpc1BlcmZvcm1pbmdXb3JrID0gITA7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBiOiB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudFRhc2sgJiZcbiAgICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkWWllbGRUb0hvc3QoKVxuICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gY3VycmVudFRhc2suY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRUYXNrLnByaW9yaXR5TGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250aW51YXRpb25DYWxsYmFjayA9IGNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRpbnVhdGlvbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBjb250aW51YXRpb25DYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICBoYXNNb3JlV29yayA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2sgPT09IHBlZWsodGFza1F1ZXVlKSAmJiBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRUYXNrKSBoYXNNb3JlV29yayA9ICEwO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZmlyc3RUaW1lciAmJlxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlVGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgICBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBoYXNNb3JlV29yayA9ICExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgKGN1cnJlbnRUYXNrID0gbnVsbCksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsKSxcbiAgICAgICAgICAgICAgICAoaXNQZXJmb3JtaW5nV29yayA9ICExKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhc01vcmVXb3JrID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBoYXNNb3JlV29ya1xuICAgICAgICAgICAgPyBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpXG4gICAgICAgICAgICA6IChpc01lc3NhZ2VMb29wUnVubmluZyA9ICExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoKGhlYXAsIG5vZGUpIHtcbiAgICAgIHZhciBpbmRleCA9IGhlYXAubGVuZ3RoO1xuICAgICAgaGVhcC5wdXNoKG5vZGUpO1xuICAgICAgYTogZm9yICg7IDAgPCBpbmRleDsgKSB7XG4gICAgICAgIHZhciBwYXJlbnRJbmRleCA9IChpbmRleCAtIDEpID4+PiAxLFxuICAgICAgICAgIHBhcmVudCA9IGhlYXBbcGFyZW50SW5kZXhdO1xuICAgICAgICBpZiAoMCA8IGNvbXBhcmUocGFyZW50LCBub2RlKSlcbiAgICAgICAgICAoaGVhcFtwYXJlbnRJbmRleF0gPSBub2RlKSxcbiAgICAgICAgICAgIChoZWFwW2luZGV4XSA9IHBhcmVudCksXG4gICAgICAgICAgICAoaW5kZXggPSBwYXJlbnRJbmRleCk7XG4gICAgICAgIGVsc2UgYnJlYWsgYTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGVlayhoZWFwKSB7XG4gICAgICByZXR1cm4gMCA9PT0gaGVhcC5sZW5ndGggPyBudWxsIDogaGVhcFswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wKGhlYXApIHtcbiAgICAgIGlmICgwID09PSBoZWFwLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZmlyc3QgPSBoZWFwWzBdLFxuICAgICAgICBsYXN0ID0gaGVhcC5wb3AoKTtcbiAgICAgIGlmIChsYXN0ICE9PSBmaXJzdCkge1xuICAgICAgICBoZWFwWzBdID0gbGFzdDtcbiAgICAgICAgYTogZm9yIChcbiAgICAgICAgICB2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBoZWFwLmxlbmd0aCwgaGFsZkxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcbiAgICAgICAgICBpbmRleCA8IGhhbGZMZW5ndGg7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGxlZnRJbmRleCA9IDIgKiAoaW5kZXggKyAxKSAtIDEsXG4gICAgICAgICAgICBsZWZ0ID0gaGVhcFtsZWZ0SW5kZXhdLFxuICAgICAgICAgICAgcmlnaHRJbmRleCA9IGxlZnRJbmRleCArIDEsXG4gICAgICAgICAgICByaWdodCA9IGhlYXBbcmlnaHRJbmRleF07XG4gICAgICAgICAgaWYgKDAgPiBjb21wYXJlKGxlZnQsIGxhc3QpKVxuICAgICAgICAgICAgcmlnaHRJbmRleCA8IGxlbmd0aCAmJiAwID4gY29tcGFyZShyaWdodCwgbGVmdClcbiAgICAgICAgICAgICAgPyAoKGhlYXBbaW5kZXhdID0gcmlnaHQpLFxuICAgICAgICAgICAgICAgIChoZWFwW3JpZ2h0SW5kZXhdID0gbGFzdCksXG4gICAgICAgICAgICAgICAgKGluZGV4ID0gcmlnaHRJbmRleCkpXG4gICAgICAgICAgICAgIDogKChoZWFwW2luZGV4XSA9IGxlZnQpLFxuICAgICAgICAgICAgICAgIChoZWFwW2xlZnRJbmRleF0gPSBsYXN0KSxcbiAgICAgICAgICAgICAgICAoaW5kZXggPSBsZWZ0SW5kZXgpKTtcbiAgICAgICAgICBlbHNlIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIDAgPiBjb21wYXJlKHJpZ2h0LCBsYXN0KSlcbiAgICAgICAgICAgIChoZWFwW2luZGV4XSA9IHJpZ2h0KSxcbiAgICAgICAgICAgICAgKGhlYXBbcmlnaHRJbmRleF0gPSBsYXN0KSxcbiAgICAgICAgICAgICAgKGluZGV4ID0gcmlnaHRJbmRleCk7XG4gICAgICAgICAgZWxzZSBicmVhayBhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgdmFyIGRpZmYgPSBhLnNvcnRJbmRleCAtIGIuc29ydEluZGV4O1xuICAgICAgcmV0dXJuIDAgIT09IGRpZmYgPyBkaWZmIDogYS5pZCAtIGIuaWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpIHtcbiAgICAgIGZvciAodmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTsgbnVsbCAhPT0gdGltZXI7ICkge1xuICAgICAgICBpZiAobnVsbCA9PT0gdGltZXIuY2FsbGJhY2spIHBvcCh0aW1lclF1ZXVlKTtcbiAgICAgICAgZWxzZSBpZiAodGltZXIuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lKVxuICAgICAgICAgIHBvcCh0aW1lclF1ZXVlKSxcbiAgICAgICAgICAgICh0aW1lci5zb3J0SW5kZXggPSB0aW1lci5leHBpcmF0aW9uVGltZSksXG4gICAgICAgICAgICBwdXNoKHRhc2tRdWV1ZSwgdGltZXIpO1xuICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoY3VycmVudFRpbWUpIHtcbiAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMTtcbiAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZClcbiAgICAgICAgaWYgKG51bGwgIT09IHBlZWsodGFza1F1ZXVlKSlcbiAgICAgICAgICAoaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMCksIHJlcXVlc3RIb3N0Q2FsbGJhY2soKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgICAgIG51bGwgIT09IGZpcnN0VGltZXIgJiZcbiAgICAgICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChcbiAgICAgICAgICAgICAgaGFuZGxlVGltZW91dCxcbiAgICAgICAgICAgICAgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRZaWVsZFRvSG9zdCgpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLnVuc3RhYmxlX25vdygpIC0gc3RhcnRUaW1lIDwgZnJhbWVJbnRlcnZhbCA/ICExIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RIb3N0Q2FsbGJhY2soKSB7XG4gICAgICBpc01lc3NhZ2VMb29wUnVubmluZyB8fFxuICAgICAgICAoKGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gITApLCBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdEhvc3RUaW1lb3V0KGNhbGxiYWNrLCBtcykge1xuICAgICAgdGFza1RpbWVvdXRJRCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICAgICAgfSwgbXMpO1xuICAgIH1cbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KEVycm9yKCkpO1xuICAgIGV4cG9ydHMudW5zdGFibGVfbm93ID0gdm9pZCAwO1xuICAgIGlmIChcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwZXJmb3JtYW5jZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGVyZm9ybWFuY2Uubm93XG4gICAgKSB7XG4gICAgICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuICAgICAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2FsRGF0ZSA9IERhdGUsXG4gICAgICAgIGluaXRpYWxUaW1lID0gbG9jYWxEYXRlLm5vdygpO1xuICAgICAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbERhdGUubm93KCkgLSBpbml0aWFsVGltZTtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciB0YXNrUXVldWUgPSBbXSxcbiAgICAgIHRpbWVyUXVldWUgPSBbXSxcbiAgICAgIHRhc2tJZENvdW50ZXIgPSAxLFxuICAgICAgY3VycmVudFRhc2sgPSBudWxsLFxuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSAzLFxuICAgICAgaXNQZXJmb3JtaW5nV29yayA9ICExLFxuICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMSxcbiAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMSxcbiAgICAgIGxvY2FsU2V0VGltZW91dCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHNldFRpbWVvdXQgPyBzZXRUaW1lb3V0IDogbnVsbCxcbiAgICAgIGxvY2FsQ2xlYXJUaW1lb3V0ID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2xlYXJUaW1lb3V0ID8gY2xlYXJUaW1lb3V0IDogbnVsbCxcbiAgICAgIGxvY2FsU2V0SW1tZWRpYXRlID1cbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHNldEltbWVkaWF0ZSA/IHNldEltbWVkaWF0ZSA6IG51bGwsXG4gICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9ICExLFxuICAgICAgdGFza1RpbWVvdXRJRCA9IC0xLFxuICAgICAgZnJhbWVJbnRlcnZhbCA9IDUsXG4gICAgICBzdGFydFRpbWUgPSAtMTtcbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbG9jYWxTZXRJbW1lZGlhdGUpXG4gICAgICB2YXIgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2FsU2V0SW1tZWRpYXRlKHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSk7XG4gICAgICB9O1xuICAgIGVsc2UgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKSxcbiAgICAgICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcbiAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgICAgfTtcbiAgICB9IGVsc2VcbiAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2NhbFNldFRpbWVvdXQocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lLCAwKTtcbiAgICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9JZGxlUHJpb3JpdHkgPSA1O1xuICAgIGV4cG9ydHMudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkgPSAxO1xuICAgIGV4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHkgPSA0O1xuICAgIGV4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkgPSAzO1xuICAgIGV4cG9ydHMudW5zdGFibGVfUHJvZmlsaW5nID0gbnVsbDtcbiAgICBleHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gMjtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgIHRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkIHx8XG4gICAgICAgIGlzUGVyZm9ybWluZ1dvcmsgfHxcbiAgICAgICAgKChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSwgcmVxdWVzdEhvc3RDYWxsYmFjaygpKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmdW5jdGlvbiAoZnBzKSB7XG4gICAgICAwID4gZnBzIHx8IDEyNSA8IGZwc1xuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCBmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZFwiXG4gICAgICAgICAgKVxuICAgICAgICA6IChmcmFtZUludGVydmFsID0gMCA8IGZwcyA/IE1hdGguZmxvb3IoMWUzIC8gZnBzKSA6IDUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGVlayh0YXNrUXVldWUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9uZXh0ID0gZnVuY3Rpb24gKGV2ZW50SGFuZGxlcikge1xuICAgICAgc3dpdGNoIChjdXJyZW50UHJpb3JpdHlMZXZlbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZhciBwcmlvcml0eUxldmVsID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb24gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3JlcXVlc3RQYWludCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5ID0gZnVuY3Rpb24gKHByaW9yaXR5TGV2ZWwsIGV2ZW50SGFuZGxlcikge1xuICAgICAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPSAzO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoXG4gICAgICBwcmlvcml0eUxldmVsLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgbnVsbCAhPT0gb3B0aW9uc1xuICAgICAgICA/ICgob3B0aW9ucyA9IG9wdGlvbnMuZGVsYXkpLFxuICAgICAgICAgIChvcHRpb25zID1cbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBvcHRpb25zICYmIDAgPCBvcHRpb25zXG4gICAgICAgICAgICAgID8gY3VycmVudFRpbWUgKyBvcHRpb25zXG4gICAgICAgICAgICAgIDogY3VycmVudFRpbWUpKVxuICAgICAgICA6IChvcHRpb25zID0gY3VycmVudFRpbWUpO1xuICAgICAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB2YXIgdGltZW91dCA9IC0xO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGltZW91dCA9IDI1MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHRpbWVvdXQgPSAxMDczNzQxODIzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgdGltZW91dCA9IDFlNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aW1lb3V0ID0gNWUzO1xuICAgICAgfVxuICAgICAgdGltZW91dCA9IG9wdGlvbnMgKyB0aW1lb3V0O1xuICAgICAgcHJpb3JpdHlMZXZlbCA9IHtcbiAgICAgICAgaWQ6IHRhc2tJZENvdW50ZXIrKyxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsLFxuICAgICAgICBzdGFydFRpbWU6IG9wdGlvbnMsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiB0aW1lb3V0LFxuICAgICAgICBzb3J0SW5kZXg6IC0xXG4gICAgICB9O1xuICAgICAgb3B0aW9ucyA+IGN1cnJlbnRUaW1lXG4gICAgICAgID8gKChwcmlvcml0eUxldmVsLnNvcnRJbmRleCA9IG9wdGlvbnMpLFxuICAgICAgICAgIHB1c2godGltZXJRdWV1ZSwgcHJpb3JpdHlMZXZlbCksXG4gICAgICAgICAgbnVsbCA9PT0gcGVlayh0YXNrUXVldWUpICYmXG4gICAgICAgICAgICBwcmlvcml0eUxldmVsID09PSBwZWVrKHRpbWVyUXVldWUpICYmXG4gICAgICAgICAgICAoaXNIb3N0VGltZW91dFNjaGVkdWxlZFxuICAgICAgICAgICAgICA/IChsb2NhbENsZWFyVGltZW91dCh0YXNrVGltZW91dElEKSwgKHRhc2tUaW1lb3V0SUQgPSAtMSkpXG4gICAgICAgICAgICAgIDogKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMCksXG4gICAgICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgb3B0aW9ucyAtIGN1cnJlbnRUaW1lKSkpXG4gICAgICAgIDogKChwcmlvcml0eUxldmVsLnNvcnRJbmRleCA9IHRpbWVvdXQpLFxuICAgICAgICAgIHB1c2godGFza1F1ZXVlLCBwcmlvcml0eUxldmVsKSxcbiAgICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCB8fFxuICAgICAgICAgICAgaXNQZXJmb3JtaW5nV29yayB8fFxuICAgICAgICAgICAgKChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSwgcmVxdWVzdEhvc3RDYWxsYmFjaygpKSk7XG4gICAgICByZXR1cm4gcHJpb3JpdHlMZXZlbDtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBzaG91bGRZaWVsZFRvSG9zdDtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdmFyIHBhcmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwYXJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AoRXJyb3IoKSk7XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/node_modules/scheduler/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-reconciler/node_modules/scheduler/index.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"(ssr)/./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1S0FBMEQ7QUFDNUQiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcRWdvZm94eHhcXERvY3VtZW50c1xccG9ydGZvbGlvLXdlYnNpdGVcXG5vZGVfbW9kdWxlc1xccmVhY3QtcmVjb25jaWxlclxcbm9kZV9tb2R1bGVzXFxzY2hlZHVsZXJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/node_modules/scheduler/index.js\n");

/***/ })

};
;